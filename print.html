<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Avendish documentation</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="foreword.html"><strong aria-hidden="true">1.</strong> Foreword</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting started</li><li class="chapter-item expanded "><a href="getting_started/hello_world.html"><strong aria-hidden="true">2.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="getting_started/compiling.html"><strong aria-hidden="true">3.</strong> Compiling</a></li><li class="chapter-item expanded "><a href="getting_started/running.html"><strong aria-hidden="true">4.</strong> Running</a></li><li class="chapter-item expanded affix "><li class="part-title">Writing CPU processors</li><li class="chapter-item expanded "><a href="writing_processors/ports.html"><strong aria-hidden="true">5.</strong> Adding ports</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing_processors/ports.refactoring.html"><strong aria-hidden="true">5.1.</strong> Simplifying ports</a></li><li class="chapter-item expanded "><a href="writing_processors/ports.helpers.html"><strong aria-hidden="true">5.2.</strong> Helpers for ports</a></li><li class="chapter-item expanded "><a href="writing_processors/ports.metadatas.html"><strong aria-hidden="true">5.3.</strong> Port metadatas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing_processors/ports.metadatas.range.html"><strong aria-hidden="true">5.3.1.</strong> Range</a></li><li class="chapter-item expanded "><a href="writing_processors/ports.metadatas.widget.html"><strong aria-hidden="true">5.3.2.</strong> Widget</a></li><li class="chapter-item expanded "><a href="writing_processors/ports.metadatas.helpers.html"><strong aria-hidden="true">5.3.3.</strong> Helpers</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="writing_processors/audio.html"><strong aria-hidden="true">6.</strong> Audio</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing_processors/audio.polyphonic.html"><strong aria-hidden="true">6.1.</strong> Monophonic processors</a></li><li class="chapter-item expanded "><a href="writing_processors/audio.setup.html"><strong aria-hidden="true">6.2.</strong> Setup</a></li><li class="chapter-item expanded "><a href="writing_processors/audio.arguments.html"><strong aria-hidden="true">6.3.</strong> Playback state</a></li></ol></li><li class="chapter-item expanded "><a href="writing_processors/messages.html"><strong aria-hidden="true">7.</strong> Messages</a></li><li class="chapter-item expanded "><a href="writing_processors/callbacks.html"><strong aria-hidden="true">8.</strong> Callbacks</a></li><li class="chapter-item expanded "><a href="writing_processors/init.html"><strong aria-hidden="true">9.</strong> Initialization</a></li><li class="chapter-item expanded "><a href="writing_processors/midi.html"><strong aria-hidden="true">10.</strong> MIDI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing_processors/midi.example.html"><strong aria-hidden="true">10.1.</strong> Example</a></li></ol></li><li class="chapter-item expanded "><a href="writing_processors/images.html"><strong aria-hidden="true">11.</strong> Image</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing_processors/images.example.html"><strong aria-hidden="true">11.1.</strong> Example</a></li></ol></li><li class="chapter-item expanded "><a href="writing_processors/metadatas.html"><strong aria-hidden="true">12.</strong> Metadatas</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced features</li><li class="chapter-item expanded "><a href="advanced/port_types.html"><strong aria-hidden="true">13.</strong> Port data types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced/port_types.example.html"><strong aria-hidden="true">13.1.</strong> Example</a></li></ol></li><li class="chapter-item expanded "><a href="advanced/ui.html"><strong aria-hidden="true">14.</strong> Custom UI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced/ui.layout.html"><strong aria-hidden="true">14.1.</strong> Declarative layouts</a></li><li class="chapter-item expanded "><a href="advanced/ui.painting.html"><strong aria-hidden="true">14.2.</strong> Custom items</a></li><li class="chapter-item expanded "><a href="advanced/ui.messages.html"><strong aria-hidden="true">14.3.</strong> Message bus</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced/ui.messages.example.html"><strong aria-hidden="true">14.3.1.</strong> Example</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="advanced/injection.html"><strong aria-hidden="true">15.</strong> Feature injection</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced/logging.html"><strong aria-hidden="true">15.1.</strong> Logging</a></li><li class="chapter-item expanded "><a href="advanced/fft.html"><strong aria-hidden="true">15.2.</strong> FFT</a></li></ol></li><li class="chapter-item expanded "><a href="advanced/presets.html"><strong aria-hidden="true">16.</strong> Presets</a></li><li class="chapter-item expanded "><a href="advanced/sample_accurate.html"><strong aria-hidden="true">17.</strong> Sample-accurate processing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced/sample_accurate.example.html"><strong aria-hidden="true">17.1.</strong> Example</a></li></ol></li><li class="chapter-item expanded "><a href="advanced/channel_mimicking.html"><strong aria-hidden="true">18.</strong> Channel mimicking</a></li><li class="chapter-item expanded "><a href="advanced/cmake.html"><strong aria-hidden="true">19.</strong> CMake configuration</a></li><li class="chapter-item expanded affix "><li class="part-title">Writing GPU processors</li><li class="chapter-item expanded "><a href="gpu/draw.html"><strong aria-hidden="true">20.</strong> Draw nodes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="gpu/draw.layout.html"><strong aria-hidden="true">20.1.</strong> Defining a layout</a></li><li class="chapter-item expanded "><a href="gpu/draw.calls.html"><strong aria-hidden="true">20.2.</strong> API calls</a></li><li class="chapter-item expanded "><a href="gpu/draw.minimal.html"><strong aria-hidden="true">20.3.</strong> Minimal pipeline</a></li><li class="chapter-item expanded "><a href="gpu/draw.example.html"><strong aria-hidden="true">20.4.</strong> Complete example</a></li></ol></li><li class="chapter-item expanded "><a href="gpu/compute.html"><strong aria-hidden="true">21.</strong> Compute nodes</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Avendish documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="making-media-objects-with-avendish"><a class="header" href="#making-media-objects-with-avendish">Making media objects with <a href="https://github.com/celtera/avendish">Avendish</a></a></h1>
<p>This book is two things: a tutorial for the usage of <a href="https://github.com/celtera/avendish">Avendish</a>, intertwined with 
an explanation of the concepts and implementation.</p>
<p>Avendish aims to enable media objects / processors authors to write the processor in the most natural way possible, and then to map this to host softwares or languages with so-called zero-cost abstraction.</p>
<blockquote>
<p>By zero-cost abstraction, we mean zero run-time cost. However, we'll see that the system actually enables extremely short compile times compared to the norm in C++.</p>
</blockquote>
<p>The library is borne from:</p>
<ul>
<li>
<p>The necessity to reduce duplication among media processors in C++. </p>
</li>
<li>
<p>Allowing to express the quintessence of a given media processor.</p>
<ul>
<li>There should be no compromise at any point: the user of the library must be able to declare all the properties, inputs, outputs of a media processor, whether it processes audio, video, MIDI, asynchronous messages, etc...</li>
<li>UIs must be possible.</li>
<li>GPU-based processors must be possible.</li>
<li>The way this is expressed should be the simplest possible way in C++, in the sense that the code should be as natural as possible: just declaring variables should be sufficient. The lack of proper reflection in C++ still limits this in a way, but we will see that it is already possible to get quite far !</li>
<li>For a given processor, multiple potential expressions are possible. We aim to capture most possible expressions: for instance, it may be more natural for a given audio processor to implement it in a sample-wise way (each audio sample processed one-by-one), and for another to be implemented through buffer-wise processing.</li>
</ul>
</li>
<li>
<p>The observation that the implementation of a media processor has no reason of depending on any kind of binding library: those are two entirely orthogonal concerns. Yet, due to how the language works, for the longest time writing such a processor necessarily embedded it inside some kind of run-time framework: JUCE, DPF, iPlug, etc. These frameworks are all great, but also all make compromises in terms of what is possible to express. Data types will be limited to a known list, UI will have to be written with a specific UI framework, etc. In contrast, Avendish processors are much more open ; processors can be written in their &quot;canonic&quot; form. The various bindings will then try to map as much as is possible to the environments they are bound to.</p>
</li>
</ul>
<p>In addition, such frameworks are generally not suitable for embedded platforms such as micro-controllers, etc. JUCE does not work on ESP32 :-) </p>
<p>In contrast, Avendish processors can be written in a way that does not depend on <em>any</em> existing library, not even the standard C or C++ libraries, which makes them trivially portable to such platforms. The only required thing is a C++ compiler, really!</p>
<h1 id="why-c"><a class="header" href="#why-c">Why C++</a></h1>
<p>To ease porting of most effects, which are also in C++. Step by step, we will be able to lift them towards maybe higher-level descriptions, but first I believe that having something in C++ is important to allow capturing the semantics of the vast majority of media processors in existence.</p>
<p>Also because this is the language I know best =p</p>
<p>Non-C++ alternatives exist: <a href="https://faust.grame.fr/">Faust</a> and <a href="https://soul.dev/">SOUL</a> are the two most known and are great inspirations for Avendish ; they focus however mainly on audio processing. Avendish can be used to make purely message-based processors for e.g. Max/MSP and PureData, Python objects, etc. or video processing objects (currently implemented only for <a href="https://ossia.io">ossia score</a>, but could easily be ported to e.g. Jitter for Max, GEM for PureData, etc.).</p>
<h1 id="what-is-really-avendish"><a class="header" href="#what-is-really-avendish">What is really Avendish</a></h1>
<ol>
<li>An ontology for media objects.</li>
<li>An automated binding of a part of the C++ object semantics to other languages and run-time environments.</li>
<li>An example implementation of this until C++ gets proper reflection and code generation features.</li>
<li>Very, very, very, very uncompromising on its goals.</li>
<li>Lots of fun C++20 code !</li>
</ol>
<h1 id="gimme-code"><a class="header" href="#gimme-code">GIMME CODE</a></h1>
<p>Here's an example of a complete audio processor which uses an <strong>optional</strong> library of helper types:
if one wants, the exact same thing can be written without any macro or pre-existing type ; it is just a tad more verbose.</p>
<pre><code class="language-cpp">struct MyProcessor {
  // Define generic metadata
  halp_meta(name, &quot;Gain&quot;);
  halp_meta(author, &quot;Jean-MichaÃ«l Celerier&quot;);
  halp_meta(uuid, &quot;3183d03e-9228-4d50-98e0-e7601dd16a2e&quot;);

  // Define the inputs of our processor
  struct ins {
    halp::dynamic_audio_bus&lt;&quot;Input&quot;, double&gt; audio;
    halp::knob_f32&lt;&quot;Gain&quot;, halp::range{.min = 0., .max = 1.}&gt; gain;
  } inputs;

  // Define the outputs of our processor
  struct outs {
    halp::dynamic_audio_bus&lt;&quot;Output&quot;, double&gt; audio;
    halp::hbargraph_f32&lt;&quot;Measure&quot;, halp::range{-1., 1., 0.}&gt; measure;
  } outputs;

  // Define an optional UI layout
  struct ui {
    using enum halp::colors;
    using enum halp::layouts;
    halp_meta(name, &quot;Main&quot;)
    halp_meta(layout, hbox)
    halp_meta(background, mid)

    struct {
      halp_meta(name, &quot;Widget&quot;)
      halp_meta(layout, vbox)
      halp_meta(background, dark)

      const char* label = &quot;Hello !&quot;;
      halp::item&lt;&amp;ins::gain&gt; widget;
      const char* label2 = &quot;Gain control!&quot;;
    } widgets;

    halp::spacing spc{.width = 20, .height = 20};

    halp::item&lt;&amp;outs::measure&gt; widget2;
  };

  // Our process function
  void operator()(int N) {
    auto&amp; in = inputs.audio;
    auto&amp; out = outputs.audio;
    const double gain = inputs.gain;

    double measure = 0.;
    for (int i = 0; i &lt; in.channels; i++)
    {
      for (int j = 0; j &lt; N; j++)
      {
        out[i][j] = gain * in[i][j];
        measure += std::abs(out[i][j]);
      }
    }

    if(N &gt; 0 &amp;&amp; in.channels &gt; 0)
      outputs.measure = measure / (N * in.channels);
  }
};
</code></pre>
<p>Here is how it looks like when compiled against the <a href="https://ossia.io">ossia score</a> backend:</p>
<p><img src="images/example.gif" alt="Gain example" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>Here is a minimal, self-contained definition of an Avendish processor:</p>
<pre><code class="language-cpp">import std;

[[name: &quot;Hello World&quot;]]
export struct MyProcessor
{
  void operator()() { 
    std::print(&quot;Henlo\n&quot;);
  }
};
</code></pre>
<p>... at least, in an alternative universe where C++ has gotten custom attributes and reflection on those, 
and where modules and <code>std::print</code> work consistently across all compilers ; in our universe, this is still a few years away. Keep hope, dear reader, keep hope !</p>
<h1 id="getting-started-for-good"><a class="header" href="#getting-started-for-good">Getting started, for good</a></h1>
<p>Here is a minimal, self-contained definition of an Avendish processor, which works on 2022 compilers:</p>
<pre><code class="language-cpp">#pragma once
#include &lt;cstdio&gt;

struct MyProcessor
{
  static consteval auto name() { return &quot;Hello World&quot;; }

  void operator()() { 
    printf(&quot;Henlo\n&quot;);
  }
};
</code></pre>
<p>Yes, it's not much. You may even already have some in your codebase without even being aware of it ! </p>
<p>Now, you may be used to the usual APIs for making audio plug-ins and start wondering about all the things you are used too and that are missing here: </p>
<ul>
<li>Inheritance or shelving function pointers in a C struct.</li>
<li>Libraries: defining an Avendish processor does not in itself require including anything. 
A central point of the system is that everything can be defined through bare C++ constructs, without requiring the user to import types from a library. A library of helpers is nonetheless provided, to simplify some repetitive cases, but is in no way mandatory ; if anything, I encourage anyone to try to make different helper APIs that fit different coding styles.</li>
<li>Functions to process audio such as</li>
</ul>
<pre><code class="language-cpp">void process(double** inputs, double** outpus, int frames);
</code></pre>
<p>We'll see how all the usual amenities can be built on top of this and simple C++ constructs such as variables, methods and structures.</p>
<h2 id="line-by-line"><a class="header" href="#line-by-line">Line by line</a></h2>
<pre><code class="language-cpp">// This line is used to instruct the compiler to not include a header file multiple times.
#pragma once

// This line is used to allow our program to use `printf`:
#include &lt;cstdio&gt;

// This line declares a struct named HelloWorld. A struct can contain functions, variables, etc.
// It could also be a class - in C++, there is no strong semantic difference between either.
struct MyProcessor
{
  // This line declares a function that will return a visible name to show to our 
  // users.
  // - static is used so that an instance of HelloWorld is not needed: 
  //   we can just refer to the function as HelloWorld::name();
  // - consteval is used to enforce that the function can be called at compile-time, 
  //   which may enable optimizations in the backends that will generate plug-ins.
  // - auto because it does not matter much here, we know that this is a string :-)
  static consteval auto name() { return &quot;Hello World&quot;; }

  // This line declares a special function that will allow our processor to be executed as follows: 
  // 
  // HelloWorld the_processor;
  // the_processor();
  //
  // ^ the second line will call the &quot;operator()&quot; function.
  void operator()() 
  { 
    // This one should hopefully be obvious :-)
    printf(&quot;Henlo\n&quot;);
  }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiling-our-processor"><a class="header" href="#compiling-our-processor">Compiling our processor</a></h1>
<h2 id="environment-set-up"><a class="header" href="#environment-set-up">Environment set-up</a></h2>
<p>Before anything, we need a C++ compiler. The recommandation is to use Clang (at least clang-13). GCC 11 also works with some limitations. Visual Studio is sadly still not competent enough.</p>
<ul>
<li>On Windows, through <a href="https://github.com/mstorsjo/llvm-mingw/releases/tag/20220323">llvm-mingw</a>. </li>
<li>On Mac, through Xcode.</li>
<li>On Linux, through your distribution packages.</li>
</ul>
<p>Avendish's code is header-only ; however, CMake automatizes correctly linking to the relevant libraries, and generates a correct entrypoint for the targeted bindings, thus we recommend installing it.</p>
<p>Ninja is recommended: it makes the build faster.</p>
<p>The APIs and SDK that you wish to create plug-ins / bindings for must also be available: </p>
<ul>
<li>PureData: needs the PureData API.
<ul>
<li>m_pd.h and pd.lib must be findable through <code>CMAKE_PREFIX_PATH</code>.</li>
<li>On Linux this is automatic if you install PureData through your distribution.</li>
</ul>
</li>
<li>Max/MSP: needs the Max SDK.
<ul>
<li>Pass <code>-DAVND_MAXSDK_PATH=/path/to/max/sdk</code> to CMake.</li>
</ul>
</li>
<li>Python: needs pybind11.
<ul>
<li>Installable through most distro's repos.</li>
</ul>
</li>
<li>ossia: needs <a href="https://github.com/ossia/libossia">libossia</a>.</li>
<li>clap: needs <a href="https://github.com/free-audio/clap">clap</a>.</li>
<li>UIs can be built with Qt or <a href="https://github.com/Immediate-Mode-UI/Nuklear">Nuklear</a>.
<ul>
<li>Qt is installable easily through <a href="https://github.com/miurahr/aqtinstall">aqtinstall</a>.</li>
</ul>
</li>
<li>VST3: needs the Steinberg VST3 SDK.
<ul>
<li>Pass <code>-DVST3_SDK_ROOT=/path/to/vst3/sdk</code> to CMake.</li>
</ul>
</li>
<li>By default, plug-ins compatible with most DAWs through an obsolete, Vintage, almost vestigial, API will be built. This does not require any specific dependency to be installed, on the other hand it only supports audio plug-ins.</li>
</ul>
<h2 id="building-the-template"><a class="header" href="#building-the-template">Building the template</a></h2>
<p>The simplest way to get started is from the <a href="https://github.com/celtera/avendish-audio-processor-template/blob/main/CMakeLists.txt">template repository</a>: simply clear the <a href="https://github.com/celtera/avendish-audio-processor-template/blob/main/src/Processor.cpp">Processor.cpp</a> file for now and put the content in <a href="https://github.com/celtera/avendish-audio-processor-template/blob/main/src/Processor.hpp">Processor.hpp</a>.</p>
<p>Here's a complete example (from bash):</p>
<pre><code class="language-bash">$ git clone https://github.com/celtera/avendish-audio-processor-template
$ mkdir build
$ cd build
$ cmake ../avendish-audio-processor-template
$ ninja # or make -j8
</code></pre>
<p>This should produce various binaries in the build folder: for instance, a PureData object (in <code>build/pd</code>), a Python one (in <code>build/python</code>, etc.).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-the-template-in-python"><a class="header" href="#running-the-template-in-python">Running the template in Python</a></h1>
<p>Once the processor is built, we can for instance run it in Python: </p>
<p>Let's try to run our processor through the Python bindings:</p>
<pre><code class="language-bash">$ cd build/python

# Check that our processor was built correctly
$ ls
pymy_processor.so

# Run it
$ python
&gt;&gt;&gt; import pymy_processor
&gt;&gt;&gt; proc = pymy_processor.Hello_World()
&gt;&gt;&gt; proc.process()
Henlo
</code></pre>
<h1 id="running-the-template-in-puredata"><a class="header" href="#running-the-template-in-puredata">Running the template in PureData</a></h1>
<p>Similarly, one can run the template in PureData: </p>
<pre><code class="language-bash">$ cd build/pd

# Check that our processor was built correctly
$ ls
my_processor.l_ia64

# Run it
$ pd -lib my_processor
</code></pre>
<p>Make the following patch:</p>
<p><img src="getting_started/../images/getting_started/pd-hello-world.png" alt="Hello PureData" /></p>
<p>When sending a bang, the terminal in which PureData was launched should also print &quot;Henlo&quot;.
We'll see in a later chapter how to print on Pd's own console instead.</p>
<h1 id="running-in-daws"><a class="header" href="#running-in-daws">Running in DAWs</a></h1>
<p>We could, but so far our object is not really an object that makes sense in a DAW: it does not process audio in any way. We'll see in further chapters how to make audio objects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-ports"><a class="header" href="#adding-ports">Adding ports</a></h1>
<p>Our processor so far does not process much. It just reacts to an external trigger, to invoke a print function.</p>
<blockquote>
<p>Note that the way this trigger is invoked varies between environments: in Python, we called a <code>process()</code> function, while in PureData, we sent a bang to our object. That is one of the core philosophies of Avendish: bindings should make it so that the object fits as much as possible with the environment's semantics and idioms.</p>
</blockquote>
<p>Most actual media processing systems work with the concept of ports to declare inputs and outputs, and Avendish embraces this fully.</p>
<p>Here is the code of a simple processor, which computes the sum of two numbers.</p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Addition&quot;; }

  struct
  {
    struct { float value; } a;
    struct { float value; } b;
  } inputs;

  struct
  {
    struct { float value; } out;
  } outputs;

  void operator()() { outputs.out.value = inputs.a.value + inputs.b.value; }
};
</code></pre>
<p>Compiling and running this yields for instance a PureData object which can be used like this:</p>
<p><img src="writing_processors/images/addition.png" alt="Addition" /></p>
<p>Note that the object respects the usual semantics of PureData: sending a message to the leftmost inlet will trigger the computation. Sending a message to the other inlets will store the value internally but won't trigger the actual computation.</p>
<p>For some objects, other semantics may make sense: creating an alternative binding to PureData which would implement another behaviour, such as triggering the computation only on &quot;bang&quot; messages, or on any input on any inlet, would be a relatively easy task.</p>
<p>Let's try in Python:</p>
<pre><code class="language-py">&gt;&gt;&gt; import pymy_processor
&gt;&gt;&gt; proc = pymy_processor.Addition()
&gt;&gt;&gt; proc.process()
&gt;&gt;&gt; p.input_0 = 123
&gt;&gt;&gt; p.input_1 = 456
&gt;&gt;&gt; p.process()
&gt;&gt;&gt; p.output_0
579.0
</code></pre>
<p>Here the semantics follow usual &quot;object&quot; ones. You set some state on the object and call methods on it, which may change this state. </p>
<blockquote>
<p>One could also make a binding that implements functional semantics, by passing the state of the processor as an immutable object instead. Python is already slow enough, though :p</p>
</blockquote>
<h2 id="syntax-explanation"><a class="header" href="#syntax-explanation">Syntax explanation</a></h2>
<p>Some readers may be surprised by the following syntax: </p>
<pre><code class="language-cpp">struct { float value; } a;
</code></pre>
<p>What it does is declare a variable <code>a</code> whose type is an <em>unnamed</em> structure. 
Note that this is a distinct concept from <em>anonymous</em> structures: </p>
<pre><code class="language-cpp">struct { float value; };
</code></pre>
<p>which are legal in C but not in C++ (although most relevant compilers accept them), and are mostly useful for implementing unions: </p>
<pre><code class="language-cpp">union vec3 {
  struct { float x, y, z; };
  struct { float r, g, b; };
};

union vec3 v; 
v.x = 1.0; 
v.g = 2.0;
</code></pre>
<p>Motivation for using unnamed structures in Avendish is explained afterwards.</p>
<h2 id="naming-things"><a class="header" href="#naming-things">Naming things</a></h2>
<p>In an ideal world, what we would have loved is writing the following code: </p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Addition&quot;; }

  struct
  {
    float a;
    float b;
  } inputs;

  struct
  {
    float out;
  } outputs;

  void operator()() { outputs.out = inputs.a + inputs.b; }
};
</code></pre>
<p>and have our Python processor expose us variables named <code>a</code>, <code>b</code> and <code>out</code>. Sadly, without reflection on names, this is not possible yet. Thus, in the meantime we use structs to embed metadata relative to the ports: </p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Addition&quot;; }

  struct
  {
    struct { 
      static consteval auto name() { return &quot;a&quot;; } 
      float value; 
    } a;
    struct { 
      static consteval auto name() { return &quot;b&quot;; } 
      float value; 
    } b;
  } inputs;

  struct
  {
    struct { 
      static consteval auto name() { return &quot;out&quot;; } 
      float value; 
    } out;
  } outputs;

  void operator()() { outputs.out.value = inputs.a.value + inputs.b.value; }
};
</code></pre>
<p>Now our Python example is cleaner to use: </p>
<pre><code class="language-py">&gt;&gt;&gt; import pymy_processor
&gt;&gt;&gt; proc = pymy_processor.Addition()
&gt;&gt;&gt; proc.process()
&gt;&gt;&gt; p.a = 123
&gt;&gt;&gt; p.b = 456
&gt;&gt;&gt; p.process()
&gt;&gt;&gt; p.out
579.0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="refactoring"><a class="header" href="#refactoring">Refactoring</a></h1>
<p>One can see how writing:</p>
<pre><code class="language-cpp">struct { 
  static consteval auto name() { return &quot;foobar&quot;; } 
  float value; 
} foobar;
</code></pre>
<p>for 200 controls would get boring quick. In addition, the implementation of our processing function is not as clean as we'd want: in an ideal world, it would be just: </p>
<pre><code class="language-cpp">void operator()() { outputs.out = inputs.a + inputs.b; }
</code></pre>
<p>Thankfully, we can introduce our own custom abstractions without breaking anything: the only thing that matters is that they follow the &quot;shape&quot; of what a parameter is.</p>
<p>This shape is defined (as a first approximation) as follows:</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
concept parameter = requires (T t) { t.value = {}; };
</code></pre>
<p>In C++ parlance, this means that a type can be recognized as a parameter if</p>
<ul>
<li>It has a member called <code>value</code>.</li>
<li>This member is assignable with some default value.</li>
</ul>
<p>For instance: </p>
<pre><code class="language-cpp">struct bad_1 {
  const int value;
}; 

struct bad_2 {
  void value();
}; 

class bad_3 {
  int value;
}; 
</code></pre>
<p>are all invalid parameters.</p>
<p>This can be ensured easily by <a href="https://gcc.godbolt.org/z/c9Ko4ssM8">asking the compiler</a>: </p>
<pre><code class="language-cpp">static_assert(!parameter&lt;bad_1&gt;);
static_assert(!parameter&lt;bad_2&gt;);
static_assert(!parameter&lt;bad_3&gt;);
</code></pre>
<blockquote>
<p><code>static_assert</code> is a C++ feature which allows to check a predicate at compile-time. If the predicate is false, the compiler will report an error.</p>
</blockquote>
<p>Avendish will simply not recognize them and they won't be accessible anywhere.</p>
<p>Here are examples of valid parameters:</p>
<pre><code class="language-cpp">struct good_1 {
  int value;
}; 

struct good_2 {
  std::string value;
}; 

template&lt;typename T&gt;
struct assignable {
  T&amp; operator=(T x) { 
    printf(&quot;I changed !&quot;);
    this-&gt;v = x;
    return this-&gt;v;
  }
  T v;
};

class good_3 {
  public:
    assignable&lt;double&gt; value;
}; 
</code></pre>
<p>This can be ensured again by <a href="https://gcc.godbolt.org/z/P7aET4q3z">asking the compiler</a>: </p>
<pre><code class="language-cpp">static_assert(parameter&lt;good_1&gt;);
static_assert(parameter&lt;good_2&gt;);
static_assert(parameter&lt;good_3&gt;);
</code></pre>
<p>Avendish provides an helper library, <code>halp</code> (Helper Abstractions for Literate Programming), which match this pattern. However, users are encouraged to develop their own abstractions that fit their preferred coding style :-)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ports-with-the-helper-library"><a class="header" href="#ports-with-the-helper-library">Ports with the helper library</a></h1>
<p>Here is how our processor looks with the current set of helpers:</p>
<pre><code class="language-cpp">#pragma once
#include &lt;halp/controls.hpp&gt;

struct MyProcessor
{
  // halp_meta(A, B) expands to static consteval auto A() { return B; }
  halp_meta(name, &quot;Addition&quot;)

  // In a perfect world one would just define attributes on the struct instead...
  //
  //   [[name: &quot;Addition&quot;]] 
  //   struct MyProcessor { ... };
  //
  // or more realistically, `static constexpr auto name = &quot;foo&quot;;` 
  // which would be an acceptable compromise.

  struct
  {
    // val_port is a simple type which contains 
    // - a member value of type float
    // - the name() metadata method
    // - helper operators to allow easy assignment and use of the value.
    halp::val_port&lt;&quot;a&quot;, float&gt; a;
    halp::val_port&lt;&quot;b&quot;, float&gt; b;
  } inputs;

  struct
  {
    halp::val_port&lt;&quot;out&quot;, float&gt; out;
  } outputs;

  void operator()() { outputs.out = inputs.a + inputs.b; }
};
</code></pre>
<p>If one really does not like templates, the following macro could be defined instead to make custom ports: </p>
<pre><code class="language-cpp">#define my_value_port(Name, Type)                  \
  struct {                                         \
    static consteval auto name() { return #Name; } \
    Type value;                                    \
  } Name;

// Used like:
my_value_port(a, float)
my_value_port(b, std::string)
... etc ...
</code></pre>
<p>Likewise if one day the <a href="https://github.com/cplusplus/papers/issues/403">metaclasses</a> proposal comes to pass, it will be possible to convert:</p>
<pre><code class="language-cpp">meta_struct
{
  float a;
  float b;
} inputs;
</code></pre>
<p>into a struct of the right shape, automatically, at compile-time, and all the current bindings will keep working.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="port-metadatas"><a class="header" href="#port-metadatas">Port metadatas</a></h1>
<p>Our ports so far are very simple: floating-point values, without any more information attached than a name to show to the user.</p>
<p>Most of the time, we'll want to attach some semantic metadata to the ports: for instance, a range of acceptable values, the kind of UI widget that should be shown to the user, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-a-minmax-range"><a class="header" href="#defining-a-minmax-range">Defining a min/max range</a></h1>
<p>Here is how one can define a port with such a range:</p>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;foobar&quot;; } 

  struct range {
    float min = -1.;
    float max = 1.;
    float init = 0.5;
  };

  float value{};
} foobar;
</code></pre>
<p>Here is another version which will be picked up too: </p>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;foobar&quot;; } 
  static consteval auto range() {
    struct { 
      float min = -1.;
      float max = 1.;
      float init = 0.5;
    } r;
    return r;
  };

  float value{};
} foobar;
</code></pre>
<p>More generally, in most cases, Avendish will try to make sense of the things the author declares, whether they are types, variables or functions. This is not implemented entirely consistently yet, but it is a goal of the library in order to enable various coding styles and as much freedom of expression as possible for the media processor developer.</p>
<h2 id="keeping-metadata-static"><a class="header" href="#keeping-metadata-static">Keeping metadata static</a></h2>
<p>Note that we should still be careful in our struct definitions to not declare normal member variables for common metadata, which would take valuable memory and mess with our cache lines. This reduces performance for no good reason: imagine instantiating 10000 &quot;processor&quot; objects, you do not want each processor to carry the overhead of storing the range as a member variable, such as this: </p>
<pre><code class="language-cpp">struct {
  const char* name = &quot;foobar&quot;;

  struct {
    float min = -1.;
    float max = 1.;
    float init = 0.5;
  } range;

  float value{};
} foobar;

// In this case:
static_assert(sizeof(foobar) == 4 * sizeof(float) + sizeof(const char*));
// sizeof(foobar) == 24 on 64-bit systems

// While in the previous cases, the &quot;name&quot; and &quot;range&quot; information is stored in a static space in the binary ; its cost is paid only once:
static_assert(sizeof(foobar) == sizeof(float));
// sizeof(foobar) == 4
</code></pre>
<h2 id="testing-on-a-processor"><a class="header" href="#testing-on-a-processor">Testing on a processor</a></h2>
<p>If we modify our example processor this way: </p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Addition&quot;; }

  struct
  {
    struct { 
      static consteval auto name() { return &quot;a&quot;; } 
      struct range {
        float min = -10.;
        float max = 10.;
        float init = 0.;
      };
      float value; 
    } a;
    struct { 
      static consteval auto name() { return &quot;b&quot;; } 
      struct range {
        float min = -1.;
        float max = 1.;
        float init = 0.;
      };
      float value; 
    } b;
  } inputs;

  struct
  {
    struct { 
      static consteval auto name() { return &quot;out&quot;; } 
      float value; 
    } out;
  } outputs;

  void operator()() { outputs.out.value = inputs.a.value + inputs.b.value; }
};
</code></pre>
<p>then some backends will start to be able to do interesting things, like showing relevant UI widgets, or clamping the inputs / outputs.</p>
<p>This is not possible in all back-ends, sadly. Consider for instance PureData: the way one adds a port is by passing a pointer to a floating-point value to Pd, which will write directly the inbound value at the memory address: there is no point at which we could plug-in to perform clamping of the value. </p>
<p>Two alternatives would be possible in this case: </p>
<ul>
<li>Change the back-end to instead expect all messages on the first inlet, as those can be captured. This would certainly yield lower performance as one now would have to pass a symbol indicating the parameter so that the object knows to which port the input should map.</li>
<li>Implement an abstraction layer which would duplicate the parameters with their clamped version, and perform the clamping on all parameters whenever the process function gets called. This would however be hurtful in terms of performance and memory use.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-ui-widgets"><a class="header" href="#defining-ui-widgets">Defining UI widgets</a></h1>
<p>Avendish can recognize a few names that will indicate that a widget of a certain type must be created.</p>
<p>For instance: </p>
<pre><code class="language-cpp">struct {
  enum { knob };
  static consteval auto name() { return &quot;foobar&quot;; } 

  struct range {
    float min = -1.;
    float max = 1.;
    float init = 0.5;
  };

  float value{};
} foobar;
</code></pre>
<p>Simply adding the enum definition in the struct will allow the bindings to detect it at compile-time, and instantiate an appropriate UI control.</p>
<p>The following widget names are currently recognized: </p>
<pre><code>bang, impulse
button, pushbutton
toggle, checkbox,
hslider, vslider, slider
spinbox,
knob,
lineedit,
choices, enumeration
combobox, list
xy,
color,
hbargraph, vbargraph, bargraph
</code></pre>
<p>This kind of widget definition is here to enable host DAWs to automatically generate appropriate UIs automatically.</p>
<p>A further chapter will present how to create entirely custom painted UIs and widgets.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widget-helpers"><a class="header" href="#widget-helpers">Widget helpers</a></h1>
<p>To simplify the common use case of defining a port such as &quot;slider with a range&quot;, a set of common helper types is provided.</p>
<p>Here is our example, now as refined as it can be ; almost no character is superfluous or needlessly repeated except the names of controls:</p>
<pre><code class="language-cpp">#pragma once
#include &lt;halp/controls.hpp&gt;

struct MyProcessor
{
  halp_meta(name, &quot;Addition&quot;)

  struct
  {
    halp::hslider_f32&lt;&quot;a&quot;, halp::range{.min = -10, .max = 10, .init = 0}&gt; a;
    halp::knob_f32&lt;&quot;b&quot; , halp::range{.min = -1, .max = 1, .init = 0}&gt; b;
  } inputs;

  struct
  {
    halp::hbargraph_f32&lt;&quot;out&quot;, halp::range{.min = -11, .max = 11, .init = 0}&gt; out;
  } outputs;

  void operator()() { outputs.out = inputs.a + inputs.b; }
};
</code></pre>
<p>This is how an environment such as <em>ossia score</em> renders it: </p>
<p><img src="writing_processors/images/addition-score.gif" alt="Addition" /></p>
<p>Note that even with our helper types, the following holds:</p>
<pre><code class="language-cpp">static_assert(sizeof(MyProcessor) == 3 * sizeof(float));
</code></pre>
<p>That is, an instance of our object weighs in memory exactly the size of its inputs and outputs, nothing else. In addition, the binding libraries try extremely hard to not allocate any memory dynamically, which leads to very concise memory representations of our media objects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-audio-processors"><a class="header" href="#writing-audio-processors">Writing audio processors</a></h1>
<p>The processors we wrote until now only processed &quot;control&quot; values.</p>
<p>As a convention, those are values that change infrequently, relative to the audio rate: every few milliseconds, as opposed to every few dozen microseconds for individual audio samples.</p>
<h2 id="argument-based-processors"><a class="header" href="#argument-based-processors">Argument-based processors</a></h2>
<p>Let's see how one can write a simple audio filter in Avendish: </p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Distortion&quot;; }

  float operator()(float input) 
  {
    return std::tanh(input); 
  }
};
</code></pre>
<p>That's it. That's the processor :-)</p>
<p>Maybe you are used to writing processors that operate with buffers of samples. Fear not, here is another valid Avendish audio processor, which should reassure most readers:</p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Distortion&quot;; }
  static consteval auto input_channels() { return 2; }
  static consteval auto output_channels() { return 2; }

  void operator()(double** inputs, double** outputs, int frames)
  {
    for (int c = 0; c &lt; input_channels(); ++c)
    {
      for (int k = 0; k &lt; frames; k++)
      {
        outputs[c][k] = std::tanh(inputs[c][k]);
      }
    }
  }
};
</code></pre>
<p>The middle-ground of a processor that processes a single channel is also possible (and so is the possibility to use floats or doubles for the definition of the processor):</p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Distortion&quot;; }

  void operator()(float* inputs, float* outputs, int frames)
  {
    for (int k = 0; k &lt; frames; k++)
    {
      outputs[k] = std::tanh(inputs[k]);
    }
  }
};
</code></pre>
<p>Those are all ways that enable quickly writing very simple effects (although a lot of ground is already covered).
For more advanced systems, with side-chains and such, it is preferable to use proper ports instead.</p>
<h2 id="port-based-processors"><a class="header" href="#port-based-processors">Port-based processors</a></h2>
<p>Here are three examples of valid audio ports:</p>
<ul>
<li>Sample-wise</li>
</ul>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;In&quot;; }
  float sample{};
};
</code></pre>
<ul>
<li>Channel-wise</li>
</ul>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;Out&quot;; }
  float* channel{};
};
</code></pre>
<ul>
<li>Bus-wise, with a fixed channel count. Here, bindings will ensure that there are always as many channels allocated.</li>
</ul>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;Ins&quot;; }
  static constexpr int channels() { return 2; }
  float** samples{}; // At some point this should be renamed bus...
};
</code></pre>
<ul>
<li>Bus-wise, with a modifiable channel count. Here, bindings will put exactly as many channels as the end-user of the software requested ; this count will be contained in <code>channels</code>. </li>
</ul>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;Outs&quot;; }
  int channels = 0;
  double** samples{}; // At some point this should be renamed bus...
};
</code></pre>
<blockquote>
<p>An astute reader may wonder why one could not fix a channel count by doing <code>const int channels = 2;</code> instead of <code>int channels() { return 2; };</code>. Sadly, this would make our types non-assignable, which makes things harder. It would also use bytes for each instance of the processor. A viable middle-ground could be <code>static constexpr int channels = 2;</code> but C++ does not allow static variables in unnamed types, thus this does not leave a lot of choice.</p>
</blockquote>
<h2 id="process-function-for-ports"><a class="header" href="#process-function-for-ports">Process function for ports</a></h2>
<p>For ports-based processor, the process function takes the number of frames as argument. Here is a complete, bare example of a gain processor. </p>
<pre><code class="language-cpp">struct Gain {
  static constexpr auto name() { return &quot;Gain&quot;; }
  struct {
    struct {
      static constexpr auto name() { return &quot;Input&quot;; }
      const double** samples;
      int channels;
    } audio;

    struct {
      static constexpr auto name() { return &quot;Gain&quot;; }
      struct range {
        const float min = 0.;
        const float max = 1.;
        const float init = 0.5;
      };

      float value;
    } gain;
  } inputs;

  struct {
    struct {
      static constexpr auto name() { return &quot;Output&quot;; }
      double** samples;
      int channels;
    } audio;
  } outputs;
  
  void operator()(int N) {
    auto&amp; in = inputs.audio.samples;
    auto&amp; out = outputs.audio.samples;

    for (int i = 0; i &lt; p1.channels; i++) 
      for (int j = 0; j &lt; N; j++) 
        out[i][j] = inputs.gain.value * in[i][j];
  }
};
</code></pre>
<h2 id="helpers"><a class="header" href="#helpers">Helpers</a></h2>
<p><code>halp</code> provides helper types for these common cases: </p>
<pre><code class="language-cpp">halp::audio_sample&lt;&quot;A&quot;, double&gt; audio;
halp::audio_channel&lt;&quot;B&quot;, double&gt; audio;
halp::fixed_audio_bus&lt;&quot;C&quot;, double, 2&gt; audio;
halp::dynamic_audio_bus&lt;&quot;D&quot;, double&gt; audio;
</code></pre>
<blockquote>
<p>Important: it is not possible to mix different types of audio ports in a single processor: audio sample and audio bus operate necessarily on different time-scales that are impossible to combine in a single function. Technically, it would be possible to combine audio channels and audio buses, but for the sake of simplicity this is currently forbidden.</p>
</blockquote>
<blockquote>
<p>Likewise, it is forbidden to mix float and double inputs for audio ports (as it simply does not make sense: no host in existence is able to provide audio in two different formats at the same time).</p>
</blockquote>
<h2 id="gain-processor-helpers-version"><a class="header" href="#gain-processor-helpers-version">Gain processor, helpers version</a></h2>
<p>The exact same example as above, just shorter to write :)</p>
<pre><code class="language-cpp">struct Gain {
  static constexpr auto name() { return &quot;Gain&quot;; }
  struct {
    halp::dynamic_audio_bus&lt;&quot;Input&quot;, double&gt; audio;
    halp::hslider_f32&lt;&quot;Gain&quot;, avnd::range{0., 1., 0.5}&gt; gain;
  } inputs;

  struct {
    halp::dynamic_audio_bus&lt;&quot;Output&quot;, double&gt; audio;
  } outputs;
  
  void operator()(int N) {
    auto&amp; in = inputs.audio;
    auto&amp; out = outputs.audio;
    const float gain = inputs.gain;

    for (int i = 0; i &lt; in.channels; i++) 
      for (int j = 0; j &lt; N; j++) 
        out[i][j] = gain * in[i][j];
  }
};
</code></pre>
<h2 id="further-work"><a class="header" href="#further-work">Further work</a></h2>
<p>We currently have the following matrix of possible forms of audio ports: </p>
<table><thead><tr><th></th><th>1 channel</th><th>N channels</th></tr></thead><tbody>
<tr><td>1 frame</td><td><code>float sample;</code></td><td><code>???</code></td></tr>
<tr><td>N frames</td><td><code>float* channel;</code></td><td><code>float** samples;</code></td></tr>
</tbody></table>
<p>For the N channels / 1 frame case, one could imagine for instance: </p>
<pre><code class="language-cpp">struct {
  float bus[2]; // Fixed channels case
}
</code></pre>
<p>or </p>
<pre><code class="language-cpp">struct {
  float* bus; // Dynamic channels case
}
</code></pre>
<p>to indicate a per-sample, multi-channel bus, but this has not been implemented yet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monophonic-processors"><a class="header" href="#monophonic-processors">Monophonic processors</a></h1>
<p>There are three special cases: </p>
<ol>
<li>Processors with one sample input and one sample output.</li>
<li>Processors with one channel input and one channel output.</li>
<li>Processors with one dynamic bus input, one dynamic bus output, and no fixed channels being specified.</li>
</ol>
<p>In these three cases, the processor is recognized as polyphony-friendly. That means that in cases 1 and 2, the processor will be instantiated potentially multiple times automatically, if used in e.g. a stereo DAW.</p>
<p>In case 3, the channels of inputs and outputs will be set to the same count, which comes from the host.</p>
<h2 id="polyphonic-processors-should-use-types-for-their-io"><a class="header" href="#polyphonic-processors-should-use-types-for-their-io">Polyphonic processors should use types for their I/O</a></h2>
<p>Let's consider the following processor:</p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Distortion&quot;; }
  struct {
    struct { float value; } gain;
  } inputs;

  double operator()(double input) 
  {
    accumulator = std::fmod(accumulator+1.f, 10.f);
    return std::tanh(inputs.gain.value * input + accumulator); 
  }
  
private:
  double accumulator{};
};
</code></pre>
<p>We have three different values involved: </p>
<ul>
<li><code>input</code> is the audio sample that is to be processed.</li>
<li><code>inputs.gain.value</code> is an external control which increases or decreases the distortion.</li>
<li><code>accumulator</code> is an internal variable used by the processing algorithm.</li>
</ul>
<p>Now consider this in the context of polyphony: the only thing that we can do is instantiate <code>MyProcessor</code> three times.</p>
<ul>
<li>We cannot call <code>operator()</code> of a single instance on multiple channels, as the internal state must stay independent of the channels.</li>
<li>But now the inputs are duplicated for all instances. If we want to implement a filter bank with thousands of duplicated processors in parallel, this would be a huge waste of memory if they all depend on the same <code>gain</code> value.</li>
</ul>
<p>Thus, it is recommended in this case to use the following form: </p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Distortion&quot;; }
  struct inputs {
      struct { float value; } gain;
  };
  struct outputs { };

  double operator()(double input, const inputs&amp; ins, outputs&amp; outs) 
  {
    accumulator = std::fmod(accumulator+1.f, 10.f);
    return std::tanh(ins.gain.value * input + accumulator); 
  }

private:
  double accumulator{};
};
</code></pre>
<p>Here, Avendish will instantiate a single <code>inputs</code> array, which will be shared across all polyphony voices, which will likely use less memory and be more performant in case of large amount of parameters &amp; voices.</p>
<p>Here is what I would term the &quot;canonic&quot; of this version, with additionally our helpers to reduce typing, and the audio samples passed through ports instead of through arguments:</p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return &quot;Distortion&quot;; }
  struct inputs {
    halp::audio_sample&lt;&quot;In&quot;, double&gt; audio;
    halp::hslider_f32&lt;&quot;Gain&quot;, halp::range{.min = 0, .max = 100, .init = 1}&gt; gain;
  };
  struct outputs { 
    halp::audio_sample&lt;&quot;A&quot;, double&gt; audio;
  };

  void operator()(const inputs&amp; ins, outputs&amp; outs) 
  {
    accumulator = std::fmod(accumulator + 0.01f, 10.f);
    outs.audio = std::tanh(ins.gain * ins.audio + accumulator); 
  }

private:
  double accumulator{};
};
</code></pre>
<p>Passing inputs and outputs as types is also possible for all the other forms described previously - everything is possible, write your plug-ins as it suits you best :) and who knows, maybe with metaclasse one would also be able to generate the more efficient form directly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-setup"><a class="header" href="#audio-setup">Audio setup</a></h1>
<p>It is fairly common for audio systems to need to have some buffers allocated or perform pre-computations depending on the sample rate and buffer size of the system.</p>
<p>This can be done by adding the following method in the processor:</p>
<pre><code class="language-cpp">void prepare(/* some_type */ info) {
    ...
}
</code></pre>
<p><code>some_type</code> can be a custom type with the following allowed fields: </p>
<ul>
<li><code>rate</code>: will be filled with the sample rate.</li>
<li><code>frames</code>: will be filled with the maximum frame (buffer) size.</li>
<li><code>input_channels</code> / <code>output_channels</code>: for processors with unspecified numbers of channels, it will be notified here.</li>
<li>Alternatively, just specifying <code>channels</code> works too if inputs and outputs are expected to be the same.</li>
</ul>
<p>Those variables must be assignable, and are all optional (remember the foreword: Avendish is <strong>UNCOMPROMISING</strong>).</p>
<p>Here are some valid examples:</p>
<ul>
<li>No member at all: this can be used to just notify the processor than processing is about to start.</li>
</ul>
<pre><code class="language-cpp">struct setup_a { };
void prepare(setup_a info) {
    ...
}
</code></pre>
<ul>
<li>Most common use case</li>
</ul>
<pre><code class="language-cpp">struct setup_b {
  float rate{};
  int frames{};
};
void prepare(setup_b info) {
    ...
}
</code></pre>
<ul>
<li>For variable channels in simple audio filters:</li>
</ul>
<pre><code class="language-cpp">struct setup_c {
  float rate{};
  int frames{};
  int channels{};
};
void prepare(setup_c info) {
    ...
}
</code></pre>
<h1 id="how-does-this-work-"><a class="header" href="#how-does-this-work-">How does this work ?</a></h1>
<p>If you are interested in the implementation, it is actually fairly simple.</p>
<ul>
<li>First we extract the function arguments of <code>prepare</code> if the function exists (see <code>avnd/common/function_reflection.hpp</code> for the method), to get the type <code>T</code> of the first argument.</li>
<li>Then we do the following if it exists:</li>
</ul>
<pre><code class="language-cpp">using type = /* type of T in prepare(T t) */;
if constexpr(requires (T t) { t.frames = 123; })
  t.frames = ... the buffer size reported by the DAW ...;
if constexpr(requires (T t) { t.rate = 44100; })
  t.rate = ... the sample-rate reported by the DAW ...;
</code></pre>
<p>This way, only the cost of the variables that are actually used by the algorithm is ever incurred, which is of course not super important but a good reference implementation for this way of doing for other parts of the system where it matters more. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-arguments"><a class="header" href="#audio-arguments">Audio arguments</a></h1>
<p>In addition of the global set-up step, one may require per-process-step arguments.
Most common needs are for instance the current tempo, etc.</p>
<p>The infrastructure put in place for this is very similar to the one previously mentioned for 
the setup step.</p>
<p>The way it is done is simply by passing it as the last argument of the processing <code>operator()</code> function.</p>
<p>If there is such a type, it will contain at least the frames.</p>
<blockquote>
<p>Note: due to a lazy developer, currently this type has to be called <code>tick</code>.</p>
</blockquote>
<p>Example:</p>
<pre><code class="language-cpp">struct MyProcessor {
  ...

  struct tick {
    int frames;
    double tempo;
  };

  void operator()(tick tick) { ... }
  float operator()(float in, tick tick) { ... }
  void operator()(float* in, float* out, tick tick) { ... }
  void operator()(float** in, float** out, tick tick) { ... }

  // And also the versions that take input and output types as arguments
  void operator()(const inputs&amp; in, outputs&amp; out, tick tick) { ... }
  float operator()(float in, const inputs&amp; in, outputs&amp; out, tick tick) { ... }
  void operator()(float* in, float* out, const inputs&amp; in, outputs&amp; out, tick tick) { ... }
  void operator()(float** in, float** out, const inputs&amp; in, outputs&amp; out, tick tick) { ... }

  // And also the double-taking versions, not duplicated here :-)
};
</code></pre>
<p>The currently supported members are: </p>
<ul>
<li><code>frames</code>: the buffer size</li>
</ul>
<p>The plan is to introduce: </p>
<ul>
<li><code>tempo</code> and all things relative to musicality, e.g. current bar, etc. 
<ul>
<li>But first we have to define it in a proper way, which is compatible with VST, CLAP, etc.</li>
</ul>
</li>
<li><code>time_since_start</code></li>
<li>and other similar timing-related things which will all be able to be opt-in.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="messages"><a class="header" href="#messages">Messages</a></h1>
<p>So far, we already have something which allows to express a great deal of audio plug-ins, as well as many objects that do not operate in a manner synchronized to a constant sound input, but also in a more asynchronous way, and with things more complicated than single <code>float</code>, <code>int</code> or <code>string</code> values.</p>
<p>A snippet of code is worth ten thousand words: here is how one defines a message input.</p>
<pre><code class="language-cpp">struct MyProcessor {
  struct messages {
    struct {
      static consteval auto name() { return &quot;dump&quot;; }
      void operator()(MyProcessor&amp; p, double arg1, std::string_view arg2) {
        std::cout &lt;&lt; arg1 &lt;&lt; &quot;;&quot; &lt;&lt; arg2 &lt;&lt; &quot;\n&quot;;
      }
    } my_message;
  };
};
</code></pre>
<p>Note that the <code>messages</code> are stored in a structure named <code>messages</code>. It could also be the name of the value, but this would likely use at least a few bytes per instance which would be wasted as messages are not supposed to have states themselves.</p>
<p>Messages are of course only meaningful in environments which support them. 
One argument messages are equivalent to parameters.
If there is more than one argument, not all host systems may be able to handle them ; for instance, it does not make much sense for VST3 plug-ins. On the other hand, programming language bindings or systems such as Max and PureData have no problem with them.</p>
<h2 id="passing-existing-functions"><a class="header" href="#passing-existing-functions">Passing existing functions</a></h2>
<p>The following syntaxes are also possible:</p>
<pre><code class="language-cpp">void free_function() { printf(&quot;Free function\n&quot;); }

struct MyProcessor {
  void my_member(int x);

  struct messages {
    // Using a pointer-to-member function
    struct {
      static consteval auto name() { return &quot;member&quot;; }
      static consteval auto func() { return &amp;MyProcessor::my_member; }
    } member;

    // Using a lambda-function
    struct
    {
      static consteval auto name() { return &quot;lambda_function&quot;; }
      static consteval auto func() {
        return [] { printf(&quot;lambda\n&quot;); };
      }
    } lambda;

    // Using a free function
    struct
    {
      static consteval auto name() { return &quot;function&quot;; }
      static consteval auto func() { return free_function; }
    } freefunc;
  };
};
</code></pre>
<p>In every case, if one wants access to the processor object, it has to be the first argument of the function (except the non-static-member-function case where it is not necessary as the function already has access to the <code>this</code> pointer by definition).</p>
<h2 id="type-checking"><a class="header" href="#type-checking">Type-checking</a></h2>
<p>Messages are type-checked: in the example above, for instance, PureData will return an error for the message <code>[dump foo bar&gt;</code>. For the message <code>[dump 0.1 bar&gt;</code> things will however work out just fine :-)</p>
<h2 id="arbitrary-inputs"><a class="header" href="#arbitrary-inputs">Arbitrary inputs</a></h2>
<p>It may be necessary to have messages that accept an arbitrary number of inputs.
Here is how: </p>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;args&quot;; }
  void operator()(MyProcessor&amp; p, std::ranges::input_range auto range) {
    for(const std::variant&amp; argument : range) {
      // Print the argument whatever the content
      // (a library such as fmt can do that directly)
      std::visit([](auto&amp; e) { std::cout &lt;&lt; e &lt;&lt; &quot;\n&quot;; }, argument);

      // Try to do something useful with it - here the types depend on what the binding give us. So far only Max and Pd support that so the only possible types are floats, doubles and std::string_view
      if(std::get_if&lt;double&gt;(argument)) { ... }
      else if(std::get_if&lt;std::string_view&gt;(argument)) { ... }
      // ... etc
    }
  }
} my_variadic_message;
</code></pre>
<h1 id="overloading"><a class="header" href="#overloading">Overloading</a></h1>
<p>Overloading is not supported yet, but there are plans for it.</p>
<h1 id="how-does-the-above-code-work-"><a class="header" href="#how-does-the-above-code-work-">How does the above code work ?</a></h1>
<p>I think that this case is pretty nice and a good example of how C++ can greatly improve type safety over C APIs: a common problem for instance with Max or Pd is accessing the incorrect member of an union when iterating the arguments to a message.</p>
<p>Avendish has the following method, which transforms a Max or Pd argument list, into an iterable coroutine-based range of <code>std::variant</code>.</p>
<pre><code class="language-cpp">using atom_iterator = avnd::generator&lt;std::variant&lt;double, std::string_view&gt;&gt;;
inline atom_iterator make_atom_iterator(int argc, t_atom* argv)
{
  for (int i = 0; i &lt; argc; ++i) {
    switch (argv[i].a_type) {
      case A_FLOAT: {
        co_yield argv[i].a_w.w_float;
        break;
      }
      case A_SYM: {
        co_yield std::string_view{argv[i].a_w.w_sym-&gt;s_name};
        break;
      }
      default:
        break;
    }
  }
}
</code></pre>
<p>Here, <code>atom_iterator</code> is what gets passed to <code>my_variadic_message</code>. It allows to deport the iteration of the loop over the arguments into the calling code, but handles the matching from type to union member in a generic way and transforms them into safer <code>std::variant</code> instances on-the-fly, which removes an entire class of possible errors while not costing much : in my experiments for instance, the compiler is able to elide entirely any form of dynamic memory allocation which would normally be required there.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="callbacks"><a class="header" href="#callbacks">Callbacks</a></h1>
<p>Just like messages allow to define functions that will be called from an outside request, it is also possible to define callbacks: functions that our processor will call, and which will be sent to the outside world.</p>
<p>Just like for messages, this does not really make sense for instance for audio processors ; however it is pretty much necessary to make useful Max or Pd objects.</p>
<p>Callbacks are defined as part of the <code>outputs</code> struct.</p>
<h2 id="defining-a-callback-with-stdfunction"><a class="header" href="#defining-a-callback-with-stdfunction">Defining a callback with std::function</a></h2>
<p>This is a first possibility, which is pretty simple:</p>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;bong&quot;; }
  std::function&lt;void(float)&gt; call;
}; 
</code></pre>
<p>The bindings will make sure that a function is present in <code>call</code>, so that our code can call it: </p>
<pre><code class="language-cpp">struct MyProcessor {
  static consteval auto name() { return &quot;Distortion&quot;; }

  struct {
    struct {
      static consteval auto name() { return &quot;overload&quot;; }
      std::function&lt;void(float)&gt; call;
    } overload; 
  } outputs;

  float operator()(float input) 
  {
    if(input &gt; 1.0)
      outputs.overload.call(input);

    return std::tanh(input); 
  }
};
</code></pre>
<p>However, we also want to be able to live without std:: types ; in particular, std::function is a quite complex beast which does type-erasure, potential dynamic memory allocations, and may not be available on all platforms.</p>
<p>Thus, it is also possible to define callbacks with a simple pair of function-pointer &amp; context: </p>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;overload&quot;; }
  struct {       
    void (*function)(void*, float);
    void* context;
  } call;
} overload;
</code></pre>
<p>The bindings will fill the function and function pointer, so that one can call them: </p>
<pre><code class="language-cpp">float operator()(float input) 
{
  if(input &gt; 1.0)
  {
    auto&amp; call = outputs.overload.call;
    call.function(call.context, input);
  }
  return std::tanh(input); 
}
</code></pre>
<p>Of course, this is fairly verbose: thankfully, helpers are provided to make this as simple as <code>std::function</code> but without the overhead (until <code>std::function_view</code> gets implemented):</p>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return &quot;overload&quot;; }
  halp::basic_callback&lt;void(float)&gt; call;
} overload;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initialization"><a class="header" href="#initialization">Initialization</a></h1>
<p>Some media systems provide a way for objects to be passed initialization arguments.</p>
<p>Avendish supports this with a special &quot;initialize&quot; method. Ultimately, I'd like to be able to simply use C++ constructors for this, but haven't managed to yet.</p>
<p>Here's an example: </p>
<pre><code class="language-cpp">struct MyProcessor {
void initialize(float a, std::string_view b)
{
  std::cout &lt;&lt; a &lt;&lt; &quot; ; &quot; &lt;&lt; b &lt;&lt; std::endl;
}
...
};
</code></pre>
<p>Max and Pd will report an error if the object is not initialized correctly, e.g. like this: </p>
<pre><code>[my_processor 1.0 foo]  // OK
[my_processor foo 1.0]  // Not OK
[my_processor] // Not OK
[my_processor 0 0 0 1 2 3] // Not OK
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="midi-io"><a class="header" href="#midi-io">MIDI I/O</a></h1>
<p>Some media systems may have a concept of MIDI input / output. Note that currently this is only implemented for DAW-ish bindings: ossia, VST3, CLAP... Max and Pd do not support it yet (but if there is a standard for passing MIDI messages between objects there I'd love to hear about it !).</p>
<p>There are a few ways to specify MIDI ports.</p>
<p>Here is how one specifies unsafe MIDI ports:</p>
<pre><code class="language-cpp">struct
{
  static consteval auto name() { return &quot;MIDI&quot;; }
  struct
  {
    uint8_t bytes[3]{};
    int timestamp{}; // relative to the beginning of the tick
  }* midi_messages{};
  std::size_t size{};
} midi_port;
</code></pre>
<p>Or, more clearly:</p>
<pre><code class="language-cpp">// the name does not matter
struct midi_message {
  uint8_t bytes[3]{};
  int timestamp{}; // relative to the beginning of the tick
};

struct
{
  static consteval auto name() { return &quot;MIDI&quot;; }
  midi_message* midi_messages{};
  std::size_t size{};
} midi_port;
</code></pre>
<p>Here, Avendish bindings will allocate a large enough buffer to store MIDI messages ; this is mainly to enable writing dynamic-allocation-free backends where such a buffer may be allocated statically. </p>
<p>It is also possible to do this if you don't expect to run your code on Arduinos:</p>
<pre><code class="language-cpp">struct
{
  // Using a non-fixed size type here will enable MIDI messages &gt; 3 bytes, if for instance your 
  // processor expects to handle SYSEX messages.
  struct msg {
    std::vector&lt;uint8_t&gt; bytes;
    int64_t timestamp{};
  };

  std::vector&lt;msg&gt; midi_messages;
} midi_port;
</code></pre>
<h2 id="helpers-1"><a class="header" href="#helpers-1">Helpers</a></h2>
<p>The library provides helper types which are a good compromise between these two solutions, as they are based on <code>boost::container::small_vector</code>: for small numbers of MIDI messages, there will be no memory allocation, but pathological cases (an host sending a thousand MIDI messages in a single tick) can still be handled without loosing messages. </p>
<p>The type is very simple:</p>
<pre><code class="language-cpp">halp::midi_bus&lt;&quot;In&quot;&gt; midi;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="midi-synth-example"><a class="header" href="#midi-synth-example">MIDI synth example</a></h1>
<p>This example is a very simple synthesizer. Note that for the sake of simplicity for the implementer, we use two additional libraries: </p>
<ul>
<li><a href="https://github.com/jcelerier/libremidi"><code>libremidi</code></a> provides an useful <code>enum</code> of common MIDI messages types.</li>
<li><a href="https://github.com/ossia/libossia"><code>libossia</code></a> provides frequency &lt;-&gt; MIDI note and gain &lt;-&gt; MIDI velocity conversion operations.</li>
</ul>
<pre><code class="language-cpp">#pragma once
#include &lt;halp/audio.hpp&gt;
#include &lt;halp/controls.hpp&gt;
#include &lt;halp/meta.hpp&gt;
#include &lt;halp/midi.hpp&gt;
#include &lt;halp/sample_accurate_controls.hpp&gt;
#include &lt;libremidi/message.hpp&gt;
#include &lt;ossia/network/dataspace/gain.hpp&gt;
#include &lt;ossia/network/dataspace/time.hpp&gt;
#include &lt;ossia/network/dataspace/value_with_unit.hpp&gt;

namespace examples
{
/**
 * This example exhibits a simple, monophonic synthesizer.
 * It relies on some libossia niceties.
 */
struct Synth
{
  halp_meta(name, &quot;My example synth&quot;);
  halp_meta(c_name, &quot;synth_123&quot;);
  halp_meta(category, &quot;Demo&quot;);
  halp_meta(author, &quot;Jean-MichaÃ«l Celerier&quot;);
  halp_meta(description, &quot;A demo synth&quot;);
  halp_meta(uuid, &quot;93eb0f78-3d97-4273-8a11-3df5714d66dc&quot;);

  struct
  {
    /** MIDI input: simply a list of timestamped messages.
     * Timestamp are in samples, 0 is the first sample.
     */
    halp::midi_bus&lt;&quot;In&quot;&gt; midi;
  } inputs;

  struct
  {
    halp::fixed_audio_bus&lt;&quot;Out&quot;, double, 2&gt; audio;
  } outputs;

  struct conf
  {
    int sample_rate{44100};
  } configuration;

  void prepare(conf c) { configuration = c; }

  int in_flight = 0;
  ossia::frequency last_note{};
  ossia::linear last_volume{};
  double phase = 0.;

  /** Simple monophonic synthesizer **/
  void operator()(int frames)
  {
    // 1. Process the MIDI messages. We'll just play the latest note-on
    // in a not very sample-accurate way..

    for (auto&amp; m : inputs.midi.midi_messages)
    {
      // Let's ignore channels
      switch ((libremidi::message_type) (m.bytes[0] &amp; 0xF0))
      {
        case libremidi::message_type::NOTE_ON:
          in_flight++;

          // Let's leverage the ossia unit conversion framework (adapted from Jamoma):
          // bytes is interpreted as a midi pitch and then converted to frequency.
          last_note = ossia::midi_pitch{m.bytes[1]};

          // Store the velocity in linear gain
          last_volume = ossia::midigain{m.bytes[2]};
          break;

        case libremidi::message_type::NOTE_OFF:
          in_flight--;
          break;
        default:
          break;
      }
    }

    // 2. Quit if we don't have any more note to play
    if (in_flight &lt;= 0)
      return;

    // 3. Output some bleeps
    double increment
        = ossia::two_pi * last_note.dataspace_value / double(configuration.sample_rate);
    auto&amp; out = outputs.audio.samples;

    for (int64_t j = 0; j &lt; frames; j++)
    {
      out[0][j] = last_volume.dataspace_value * std::sin(phase);
      out[1][j] = out[0][j];

      phase += increment;
    }
  }
};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image-ports"><a class="header" href="#image-ports">Image ports</a></h1>
<p>Some media systems have the ability to process images. Avendish is not restricted here :-)</p>
<p>Note that this part of the system is still pretty much in flux, in particular with regards of how allocations are supposed to be handled.
Any feedback on this is welcome.</p>
<p>First, here is how we define a viable texture type:</p>
<pre><code class="language-cpp">struct my_texture
{
  enum format { RGBA }; // The only recognized one so far
  unsigned char* bytes;
  int width;
  int height;
  bool changed;
};
</code></pre>
<p>Then, a texture port:</p>
<pre><code class="language-cpp">struct {
  rgba_texture texture;
} input;
</code></pre>
<p>Note that currently, it is <em>the responsibility of the plug-in author</em> to allocate the texture and set the <code>changed</code> bool for output ports. Input textures come from outside.</p>
<p>Due to the large cost of uploading a texture, <code>changed</code> is used to indicate both to the plug-in author that input textures have been touched,and for the plug-in author to indicate to the external environment that the output has changed and must be re-uploaded to the GPU.</p>
<h2 id="gpu-processing"><a class="header" href="#gpu-processing">GPU processing</a></h2>
<p>... is not currently supported properly, but is under active investigation.</p>
<p>The two possibilities going forward are: </p>
<ul>
<li>Wrap / conceptify an API not dissimilar to abstraction APIs such as <a href="https://github.com/bkaradzic/bgfx">BGFX</a> or <a href="https://www.qt.io/blog/graphics-in-qt-6.0-qrhi-qt-quick-qt-quick-3d">Qt RHI</a> which abstract over modern graphics APIs such as Vulkan, Metal and D3D (and retain compatibility with OpenGL).</li>
<li>Make bindings that support compilation to GPU programs, for instance with CUDA or <a href="https://github.com/seanbaxter/shaders/blob/master/README.md">Circle</a>. This is what I think is the best way going forward :-)</li>
</ul>
<h2 id="helpers-2"><a class="header" href="#helpers-2">Helpers</a></h2>
<p>A few types are provided:</p>
<ul>
<li><code>halp::rgba_texture</code></li>
<li><code>halp::texture_input&lt;&quot;Name&quot;&gt;</code> provides methods to get an RGBA pixel: </li>
</ul>
<pre><code class="language-cpp">auto [r,g,b,a] = tex.get(10, 20);
</code></pre>
<ul>
<li><code>halp::texture_output&lt;&quot;Name&quot;&gt;</code> provides methods to set a RGBA pixel: </li>
</ul>
<pre><code class="language-cpp">tex.set(10, 20, {.r = 10, .g = 100, .b = 34, .a = 255});
tex.set(10, 20, 10, 100, 34, 255);
</code></pre>
<p>as well as useful method to initialize and mark the texture ready for upload: </p>
<pre><code class="language-cpp">// Call this in the constructor or before processing starts
tex.create(100, 100);

// Call this after making changes to the texture
tex.upload();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image-processor-example"><a class="header" href="#image-processor-example">Image processor example</a></h1>
<p>This example is a very simple image filter. It takes an input image and downscales &amp; degrades it.</p>
<pre><code class="language-cpp">#pragma once
#include &lt;halp/audio.hpp&gt;
#include &lt;halp/controls.hpp&gt;
#include &lt;halp/meta.hpp&gt;
#include &lt;halp/sample_accurate_controls.hpp&gt;
#include &lt;halp/texture.hpp&gt;
#include &lt;cmath&gt;

namespace examples
{
struct TextureFilterExample
{
  halp_meta(name, &quot;My example texture filter&quot;);
  halp_meta(c_name, &quot;texture_filt&quot;);
  halp_meta(category, &quot;Demo&quot;);
  halp_meta(author, &quot;Jean-MichaÃ«l Celerier&quot;);
  halp_meta(description, &quot;Example texture filter&quot;);
  halp_meta(uuid, &quot;3183d03e-9228-4d50-98e0-e7601dd16a2e&quot;);

  struct
  {
    halp::texture_input&lt;&quot;In&quot;&gt; image;
  } inputs;

  struct
  {
    halp::texture_output&lt;&quot;Out&quot;&gt; image;
  } outputs;

  // Some initialization can be done in the constructor.
  TextureFilterExample() noexcept
  {
    // Allocate some initial data
    outputs.image.create(1, 1);
  }

  void operator()()
  {
    auto&amp; in_tex = inputs.image.texture;
    auto&amp; out_tex = outputs.image.texture;

    // Since GPU readbacks are asynchronous: reading textures may take some time and
    // thus the data may not be available from the beginning.
    if (in_tex.bytes == nullptr)
      return;

    // Texture hasn't changed since last time, no need to recompute anything
    if (!in_tex.changed)
      return;
    in_tex.changed = false;

    // We (dirtily) downscale by a factor of 16
    if (out_tex.width != in_tex.width || out_tex.height != in_tex.height)
      outputs.image.create(in_tex.width / 16, in_tex.height / 16);

    for (int y = 0; y &lt; in_tex.height / 16; y++)
    {
      for (int x = 0; x &lt; in_tex.width / 16; x++)
      {
        // Get a pixel
        auto [r, g, b, a] = inputs.image.get(x * 16, y * 16);

        // (Dirtily) Take the luminance and compute its contrast
        double contrasted = std::pow((r + g + b) / (3. * 255.), 4.);

        // (Dirtily) Posterize
        uint8_t col = uint8_t(contrasted * 8) * (255 / 8.);

        // Update the output texture
        outputs.image.set(x, y, col, col, col, 255);
      }
    }

    // Call this when the texture changed
    outputs.image.upload();
  }
};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metadatas"><a class="header" href="#metadatas">Metadatas</a></h1>
<p>So far the main metadata we saw for our processor is its name: </p>
<pre><code class="language-cpp">static consteval auto name() { return &quot;Foo&quot;; }
</code></pre>
<p>Or with the helper macro:</p>
<pre><code class="language-cpp">halp_meta(name, &quot;Foo&quot;)
</code></pre>
<p>There are a few more useful metadatas that can be used and which will be used depending on whether the bindings support exposing them.
Here is a list in order of importance; it is recommended that strings are used for all of these and that they are filled as much as possible.</p>
<ul>
<li><code>name</code>: the pretty name of the object.</li>
<li><code>c_name</code>: a C-identifier-compatible name for the object. This is necessary for instance for systems such as Python, PureData or Max which do not support spaces or special characters in names.</li>
<li><code>uuid</code>: a string such as <code>8a4be4ec-c332-453a-b029-305444ee97a0</code>, generated for instance with the <code>uuidgen</code> command on Linux, Mac and Windows, or with <a href="https://www.uuidgenerator.net/">uuidgenerator.net</a> otherwise. This provides a computer-identifiable unique identifier for your plug-in, to ensure that hosts don't have collisions between plug-ins of the same name and different vendors when reloading them (sadly, on some older APIs this is unavoidable).</li>
<li><code>description</code>: a textual description of the processor.</li>
<li><code>vendor</code>: who distributes the plug-in.</li>
<li><code>product</code>: product name if the plug-in is part of a larger product.</li>
<li><code>version</code>: a version string, ideally convertible to an integer as some older APIs expect integer versions.</li>
<li><code>category</code>: a category for the plug-in. &quot;Audio&quot;, &quot;Synth&quot;, &quot;Distortion&quot;, &quot;Chorus&quot;... there's no standard, but one can check for instance the names used <a href="https://lv2plug.in/ns/lv2core">in LV2</a> or the list mentioned by <a href="https://distrho.github.io/DPF/group__PluginMacros.html">DISTRHO</a>.</li>
<li><code>copyright</code>: <code>(c) the plug-in authors 2022-xxxx</code></li>
<li><code>license</code>: an <a href="https://spdx.org/licenses/">SPDX identifier</a> for the license or a link towards a license document</li>
<li><code>url</code>: URL for the plug-in if any.</li>
<li><code>email</code>: A contact e-mail if any.</li>
<li><code>manual_url</code>: an url for a user manual if any.</li>
<li><code>support_url</code>: an url for user support, a forum, chat etc. if any.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supported-port-types"><a class="header" href="#supported-port-types">Supported port types</a></h1>
<p>The supported port types depend on the back-end. There is, however, some flexibility.</p>
<h2 id="simple-ports"><a class="header" href="#simple-ports">Simple ports</a></h2>
<h3 id="float"><a class="header" href="#float">Float</a></h3>
<p>They should work everywhere.</p>
<pre><code class="language-cpp">struct {
  float value;
} my_port;
</code></pre>
<h3 id="double"><a class="header" href="#double">Double</a></h3>
<p>They will not work in Max / Pd message processors (but will work in Max / Pd audio processors)
as their API expect a pointer to an existing <code>float</code> value.</p>
<pre><code class="language-cpp">struct {
  double value;
} my_port;
</code></pre>
<h3 id="int"><a class="header" href="#int">Int</a></h3>
<p>Same than double.</p>
<pre><code class="language-cpp">struct {
  int value;
} my_port;
</code></pre>
<h3 id="bool"><a class="header" href="#bool">Bool</a></h3>
<p>Same than double.</p>
<pre><code class="language-cpp">struct {
  bool value;
} my_port;
</code></pre>
<blockquote>
<p>Note that depending on the widget you use, UIs may create a <code>toggle</code>, 
a maintained <code>button</code> or a momentary <code>bang</code>.</p>
</blockquote>
<h3 id="string"><a class="header" href="#string">String</a></h3>
<p>Will not work in environments such as VST3 for obvious reasons.</p>
<pre><code class="language-cpp">struct {
  std::string value;
} my_port;
</code></pre>
<h2 id="enumerations"><a class="header" href="#enumerations">Enumerations</a></h2>
<p>Enumerations are interesting.
There are multiple ways to implement them.</p>
<h3 id="mapping-a-string-to-a-value"><a class="header" href="#mapping-a-string-to-a-value">Mapping a string to a value</a></h3>
<p>Consider the following port:</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
using my_pair = std::pair&lt;std::string_view, T&gt;;
struct {
  halp_meta(name, &quot;Enum 1&quot;);
  enum widget { combobox };

  struct range {
    my_pair&lt;float&gt; values[3]{{&quot;Foo&quot;, -10.f}, {&quot;Bar&quot;, 5.f}, {&quot;Baz&quot;, 10.f}};
    int init{1}; // == Bar
  };

  float value{}; // Will be initialized to 5.f
} combobox;
</code></pre>
<p>Here, using a range definition of the form:</p>
<pre><code class="language-cpp">struct range {
    &lt;string -&gt; value map&gt; values[N] = { 
      { key_1, value_1}, { key_2, value_2 }, ... 
    };

    &lt;integer&gt; init = /* initial index */;
};
</code></pre>
<p>allows to initialize a combobox in the UI, with a predetermined set of values.
The value type is the actual one which will be used for the port - Avendish will translate 
as needed.</p>
<h3 id="enumerating-with-only-string"><a class="header" href="#enumerating-with-only-string">Enumerating with only string</a></h3>
<p>Consider the following port:</p>
<pre><code class="language-cpp">struct {
  halp_meta(name, &quot;Enum 2&quot;);
  enum widget { enumeration };

  struct range {
    std::string_view values[4]{&quot;Roses&quot;, &quot;Red&quot;, &quot;Violets&quot;, &quot;Blue&quot;};
    int init{1}; // Red
  };

  std::string_view value;
};
</code></pre>
<p>Here, we can use <code>std::string_view</code>: the assigned value will always be 
one from the range::values array ; these strings live in static memory 
so there is no need to duplicate them in an <code>std::string</code>.</p>
<p>It is also possible to use an <code>int</code> for the port value:</p>
<pre><code class="language-cpp">struct {
  halp_meta(name, &quot;Enum 3&quot;);
  enum widget { enumeration };

  struct range {
    std::string_view values[4]{&quot;Roses&quot;, &quot;Red&quot;, &quot;Violets&quot;, &quot;Blue&quot;};
    int init{1}; // Red
  };

  int value{};
};
</code></pre>
<p>Here, the int will just be the index of the selected thing.</p>
<h3 id="enumerating-with-proper-enums--"><a class="header" href="#enumerating-with-proper-enums--">Enumerating with proper enums :-)</a></h3>
<p>Finally, we can also use actual enums.</p>
<pre><code class="language-cpp">enum my_enum { A, B, C };
struct {
  halp_meta(name, &quot;Enum 3&quot;);
  enum widget { enumeration };

  struct range
  {
    std::string_view values[3]{&quot;A&quot;, &quot;B&quot;, &quot;C&quot;};
    my_enum init = my_enum::B;
  };

  my_enum value{};
}
</code></pre>
<blockquote>
<p>The enum must be contiguous, representable in an int32 and start at 0: 
<code>enum { A = 3, B, C };</code> will not work. 
<code>enum { A, B, C, AA = 10 };</code> will not work.
<code>enum { A, B, C, ... 4 billion values later ..., XXXX };</code> will not work.
<code>enum { A, B, C };</code> will work.</p>
</blockquote>
<p>An helper is provided, which is sadly a macro as we cannot do proper enum reflection yet:</p>
<pre><code class="language-cpp">halp__enum(&quot;Simple Enum&quot;, Peg, Square, Peg, Round, Hole) my_port;
</code></pre>
<p>declares a port named &quot;Simple Enum&quot;. The default value will be &quot;Peg&quot;, the 4 enumerators are Square, Peg, Round, Hole.</p>
<h2 id="advanced-types"><a class="header" href="#advanced-types">Advanced types</a></h2>
<h3 id="2d-position-xy"><a class="header" href="#2d-position-xy">2D position: xy</a></h3>
<p>Here a special shape of struct is recognized:</p>
<pre><code class="language-cpp">struct {
  struct { float x, y; } value;
} my_port;
</code></pre>
<h3 id="color"><a class="header" href="#color">Color</a></h3>
<p>Here a special shape of struct is recognized:</p>
<pre><code class="language-cpp">struct {
  struct { float r, g, b, a; } value;
} my_port;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example"><a class="header" href="#example">Example</a></h1>
<pre><code class="language-cpp">#pragma once
#include &lt;avnd/concepts/audio_port.hpp&gt;
#include &lt;avnd/concepts/parameter.hpp&gt;
#include &lt;halp/audio.hpp&gt;
#include &lt;halp/controls.hpp&gt;
#include &lt;halp/controls_fmt.hpp&gt;
#include &lt;halp/meta.hpp&gt;
#include &lt;halp/sample_accurate_controls.hpp&gt;
#include &lt;boost/pfr.hpp&gt;
#include &lt;cmath&gt;

namespace examples
{

struct ControlGallery
{
  halp_meta(name, &quot;Control gallery&quot;);
  halp_meta(c_name, &quot;control_gallery&quot;);
  halp_meta(category, &quot;Demo&quot;);
  halp_meta(author, &quot;&lt;AUTHOR&gt;&quot;);
  halp_meta(description, &quot;&lt;DESCRIPTION&gt;&quot;);
  halp_meta(uuid, &quot;a9b0e2c6-61e9-45df-a75d-27abf7fb43d7&quot;);

  struct
  {
    //! Buttons are level-triggers: true as long as the button is pressed
    halp::accurate&lt;halp::maintained_button&lt;&quot;Press me ! (Button)&quot;&gt;&gt; button;

    //! In contrast, impulses are edge-triggers: there is only a value at the moment of the click.
    halp::accurate&lt;halp::impulse_button&lt;&quot;Press me ! (Impulse)&quot;&gt;&gt; impulse_button;

    //! Common widgets
    halp::accurate&lt;halp::hslider_f32&lt;&quot;Float slider&quot;, halp::range{0., 1., 0.5}&gt;&gt;
        float_slider;
    halp::accurate&lt;halp::knob_f32&lt;&quot;Float knob&quot;, halp::range{0., 1., 0.5}&gt;&gt; float_knob;
    //// // FIXME
    //// struct {
    ////   // FIXME meta_control(Control::LogFloatSlider, &quot;Float slider (log)&quot;, 0., 1., 0.5);
    ////   ossia::timed_vec&lt;float&gt; values{};
    //// } log_float_slider;
    ////

#if defined(__clang__) || defined(_MSC_VER)
    // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=104720
    halp::accurate&lt;halp::hslider_i32&lt;&quot;Int slider&quot;, halp::range{0., 1000., 10.}&gt;&gt;
        int_slider;
    halp::accurate&lt;halp::spinbox_i32&lt;&quot;Int spinbox&quot;, halp::range{0, 1000, 10}&gt;&gt;
        int_spinbox;
#endif

    //! Will look like a checkbox
    halp::accurate&lt;halp::toggle&lt;&quot;Toggle&quot;, halp::toggle_setup{.init = true}&gt;&gt; toggle;

    //! Same, but allows to choose what is displayed.
    // FIXME halp::accurate&lt;halp::chooser_toggle&lt;&quot;Toggle&quot;, {&quot;Falsey&quot;, &quot;Truey&quot;}, false&gt;&gt; chooser_toggle;

    //! Allows to edit some text.
    halp::accurate&lt;halp::lineedit&lt;&quot;Line edit&quot;, &quot;Henlo&quot;&gt;&gt; lineedit;

    //! First member of the pair is the text, second is the value.
    //! Defining comboboxes and enumerations is a tiny bit more complicated
    struct : halp::sample_accurate_values&lt;halp::combo_pair&lt;float&gt;&gt;
    {
      halp_meta(name, &quot;Combo box&quot;);
      enum widget
      {
        combobox
      };

      struct range
      {
        halp::combo_pair&lt;float&gt; values[3]{{&quot;Foo&quot;, -10.f}, {&quot;Bar&quot;, 0.f}, {&quot;Baz&quot;, 10.f}};
        int init{1}; // Bar
      };

      float value{};
    } combobox;

    //! Here value will be the string
    struct : halp::sample_accurate_values&lt;std::string_view&gt;
    {
      halp_meta(name, &quot;Enum 2&quot;);
      enum widget
      {
        enumeration
      };

      struct range
      {
        std::string_view values[4]{&quot;Roses&quot;, &quot;Red&quot;, &quot;Violets&quot;, &quot;Blue&quot;};
        int init{1}; // Red
      };

      // FIXME: string_view: allow outside bounds
      std::string_view value;
    } enumeration_a;

    //! Here value will be the index of the string... but even better than that
    //! is below:
    struct : halp::sample_accurate_values&lt;int&gt;
    {
      halp_meta(name, &quot;Enum 3&quot;);
      enum widget
      {
        enumeration
      };

      struct range
      {
        std::string_view values[4]{&quot;Roses 2&quot;, &quot;Red 2&quot;, &quot;Violets 2&quot;, &quot;Blue 2&quot;};
        int init{1}; // Red
      };

      int value{};
    } enumeration_b;

    /// // FIXME
    /// //! Same as Enum but won't reject strings that are not part of the list.
    /// struct {
    ///   static const constexpr std::array&lt;const char*, 3&gt; choices() {
    ///     return {&quot;Square&quot;, &quot;Sine&quot;, &quot;Triangle&quot;};
    ///   };
    ///   // FIXME meta_control(Control::UnvalidatedEnum, &quot;Unchecked enum&quot;, 1, choices());
    ///   ossia::timed_vec&lt;std::string&gt; values{};
    /// } unvalidated_enumeration;

    //! It's also possible to use this which will define an enum type and
    //! map to it automatically.
    //! e.g. in source one can then do:
    //!
    //!   auto&amp; param = inputs.simpler_enumeration;
    //!   using enum_type = decltype(param)::enum_type;
    //!   switch(param.value) {
    //!      case enum_type::Square:
    //!        ...
    //!   }
    //!
    //! OSC messages can use either the int index or the string.
    using enum_t = halp__enum(&quot;Simple Enum&quot;, Peg, Square, Peg, Round, Hole);
    halp::accurate&lt;enum_t&gt; simpler_enumeration;

    //! Crosshair XY chooser
    halp::accurate&lt;halp::xy_pad_f32&lt;&quot;XY&quot;, halp::range{-5.f, 5.f, 0.f}&gt;&gt; position;

    //! Color chooser. Colors are in 8-bit RGBA by default.
    halp::accurate&lt;halp::color_chooser&lt;&quot;Color&quot;&gt;&gt; color;

  } inputs;

  void operator()()
  {
    const bool has_impulse = !inputs.impulse_button.values.empty();
    const bool has_button = std::any_of(
        inputs.button.values.begin(),
        inputs.button.values.end(),
        [](const auto&amp; p) { return p.second == true; });

    if (!has_impulse &amp;&amp; !has_button)
      return;

    boost::pfr::for_each_field(
        inputs,
        [] &lt;typename Control&gt; (const Control&amp; input) {
          {
            auto val = input.values.begin()-&gt;second;
            fmt::print(&quot;changed: {} {}&quot;, Control::name(), val);
          }
    });
  }
};

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-user-interfaces"><a class="header" href="#creating-user-interfaces">Creating user interfaces</a></h1>
<p>We have seen so far that we can specify widgets for our controls. Multiple back-ends may render these widgets in various ways.
This is already a good start for making user interfaces, but most media systems generally have more specific user interface needs.</p>
<p>Avendish allows three levels of UI definition: </p>
<ol>
<li>Automatic: nothing to do, all the widgets corresponding to inputs and outputs of the processor will be generated automatically in a list. This is not pretty but sufficient for many simple cases. For instance, here is how some Avendish plug-ins render in <em>ossia score</em>.</li>
</ol>
<p><img src="advanced/images/ui-basic.png" alt="Basic UI" /></p>
<ol start="2">
<li>Giving layout hints. A declarative syntax allows to layout said items and text in usual containers, auomatically and with arbitrary nesting: hbox, vbox, tabs, split view... Here is, again, an example in <em>ossia score</em>.</li>
</ol>
<p><img src="advanced/images/ui-layout.png" alt="Basic UI" /></p>
<ol start="3">
<li>Creating entirely custom items with a Canvas-based API. It is also possible to load images, make custom animations and handle mouse events.</li>
</ol>
<p><img src="advanced/images/ui-image.gif" alt="Basic UI" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layout-based-uis"><a class="header" href="#layout-based-uis">Layout-based UIs</a></h1>
<p>To define a custom UI, one has to add a <code>struct ui</code> in the processor definition.</p>
<pre><code class="language-cpp">struct MyProcessor {
  struct ui {
   
  };
};
</code></pre>
<p>By default, this will do nothing: we have to fill it. <code>ui</code> will be the top-level widget.
Child widgets can be added simply by defining struct members.
Containers are defined by adding a <code>layout()</code> function which returns an enum value, which may 
currently be any of the following names:</p>
<pre><code>hbox,
vbox,
container,
group,
split,
tabs,
grid,
spacing,
control,
custom
</code></pre>
<p>For instance:</p>
<pre><code class="language-cpp">struct ui
{
  static constexpr auto layout() { enum { hbox } d{}; return d; }
  struct {
    static constexpr auto layout() { enum { vbox } d{}; return d; }
    const char* text = &quot;text&quot;;
    decltype(&amp;ins::int_ctl) int_widget = &amp;ins::int_ctl;
  } widgets;

  struct {
    static constexpr auto layout() { enum { spacing } d{}; return d; }
    static constexpr auto width() { return 20; }
    static constexpr auto height() { return 20; }
  } a_spacing;

  const char* text = &quot;text2&quot;;
};
</code></pre>
<p>This defines, conceptually, the following layout:</p>
<pre><code class="language-ascii">|-----------------------------|
|  |  text  |                 |
|  |        |                 |
|  | =widg= |  &lt;20px&gt;  text2  |
|  |        |                 |
|  |        |                 |
|-----------------------------|
</code></pre>
<h2 id="layouts"><a class="header" href="#layouts">Layouts</a></h2>
<h3 id="hbox-vbox"><a class="header" href="#hbox-vbox">HBox, VBox</a></h3>
<p>These will layout things either horizontally or vertically.</p>
<h3 id="split"><a class="header" href="#split">Split</a></h3>
<p>Each children will be separated by a split line (thus generally one would use it to separate layouts).</p>
<h3 id="grid"><a class="header" href="#grid">Grid</a></h3>
<p>This will layout children items in a grid.</p>
<p>Either of <code>rows()</code> and <code>columns()</code> properties can be defined, but not both:</p>
<pre><code>static constexpr auto rows() { return 3; }
static constexpr auto columns() { return 3; }
</code></pre>
<p>If <code>columns()</code> is defined, children widget will be laid out in the first row until the column count is reached, then in the second row, etc. until there are no more children items, and conversely if <code>rows()</code> is defined.</p>
<p>That is, given: </p>
<pre><code class="language-cpp">struct {
  static constexpr auto layout() { enum { grid } d{}; return d; }
  static constexpr auto columns() { return 3; }
  const char* text1 = &quot;A&quot;;
  const char* text2 = &quot;B&quot;;
  const char* text3 = &quot;C&quot;;
  const char* text4 = &quot;D&quot;;
  const char* text5 = &quot;E&quot;;
} a_grid;
</code></pre>
<p>The layout will be:</p>
<pre><code class="language-ascii">|---------|
| A  B  C | 
| D  E    |
|---------|
</code></pre>
<p>Instead, if <code>rows()</code> is defined to 3:</p>
<pre><code class="language-ascii">|------|
| A  D | 
| B  E | 
| C    |
|------|
</code></pre>
<h3 id="tabs"><a class="header" href="#tabs">Tabs</a></h3>
<p>Tabs will display children items in tabs.
Each children item should have a <code>name()</code> property which will be shown in the tab bar.</p>
<pre><code class="language-cpp">struct {
  static constexpr auto layout() { enum { tabs } d{}; return d; }
  struct {
    static constexpr auto layout() { enum { hbox } d{}; return d; }
    static constexpr auto name() { return &quot;First tab&quot;; }
    const char* text1 = &quot;A&quot;;
    const char* text2 = &quot;B&quot;;
  } a_hbox;
  struct {
    static constexpr auto layout() { enum { hbox } d{}; return d; }
    static constexpr auto name() { return &quot;Second tab&quot;; }
    const char* text3 = &quot;C&quot;;
    const char* text4 = &quot;D&quot;;
  } a_vbox;
} a_tabs;
</code></pre>
<h2 id="properties"><a class="header" href="#properties">Properties</a></h2>
<h3 id="background-color"><a class="header" href="#background-color">Background color</a></h3>
<p>Background colors can be chosen from a standardized set: for now, those are fairly abstract to allow things to work in a variety of environments.</p>
<pre><code>darker,
dark,
mid,
light,
lighter
</code></pre>
<p>Setting the color is done by adding this to a layout:</p>
<pre><code class="language-cpp">static constexpr auto background() { enum { dark } d{}; return d; }
</code></pre>
<h3 id="explicit-positioning"><a class="header" href="#explicit-positioning">Explicit positioning</a></h3>
<p>In &quot;group&quot; or &quot;container&quot; layouts, widgets will not be positioned automatically. <code>x</code> and <code>y</code> methods can be used for that.</p>
<pre><code class="language-cpp">static constexpr auto x() { return 20; }
static constexpr auto y() { return 20; }
</code></pre>
<h3 id="explicit-sizing"><a class="header" href="#explicit-sizing">Explicit sizing</a></h3>
<p>Containers can be given an explicit (device independent) pixel size with </p>
<pre><code class="language-cpp">static constexpr auto width() { return 100; }
static constexpr auto height() { return 50; }
</code></pre>
<p>Otherwise, things will be made to fit in a best-effort way.</p>
<h2 id="items"><a class="header" href="#items">Items</a></h2>
<h2 id="text-labels"><a class="header" href="#text-labels">Text labels</a></h2>
<p>The simplest item is the text label: simply adding a <code>const char*</code> member is sufficient. </p>
<h2 id="controls"><a class="header" href="#controls">Controls</a></h2>
<p>One can add a control (either input or output) simply by adding a member pointer to it: </p>
<pre><code class="language-cpp">struct MyProcessor {
  struct ins {
    halp::hslider_f32&lt;&quot;Foo&quot;&gt; foo;
  } inputs;

  struct ui
  {
    static constexpr auto layout() { enum { hbox } d{}; return d; }
    const char* text = &quot;text&quot;;
    decltype(&amp;ins::foo) int_widget = &amp;ins::foo;
  };
};
</code></pre>
<p>The syntax without helpers currently needs some repeating as C++ does not yet allow <code>auto</code> as member fields, otherwise it'd just be:</p>
<pre><code class="language-cpp">auto int_widget = &amp;ins::foo;
</code></pre>
<h1 id="helpers-3"><a class="header" href="#helpers-3">Helpers</a></h1>
<p>Helpers simplify common tasks ; here, C++20 designated-initializers allow us to have a very pretty API and reduce repetitions:</p>
<h2 id="widget-helpers-1"><a class="header" href="#widget-helpers-1">Widget helpers</a></h2>
<pre><code class="language-cpp">halp::label l1{
    .text = &quot;some long foo&quot;
  , .x = 100
  , .y = 25
};

halp::item&lt;&amp;ins::foo&gt; widget{
    .x = 75
  , .y = 50
};
</code></pre>
<h2 id="properties-helpers"><a class="header" href="#properties-helpers">Properties helpers</a></h2>
<pre><code class="language-cpp">struct ui {
 // If your compiler is recent enough you can do this, 
 // otherwise layout and background enums have to be qualified:
 using enum halp::colors;
 using enum halp::layouts;
 
 halp_meta(name, &quot;Main&quot;)
 halp_meta(layout, hbox)
 halp_meta(background, mid)

 struct {
   halp_meta(name, &quot;Widget&quot;)
   halp_meta(layout, vbox)
   halp_meta(background, dark)
   halp::item&lt;&amp;ins::int_ctl&gt; widget;
   halp::item&lt;&amp;outs::measure&gt; widget2;
 } widgets;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-items"><a class="header" href="#custom-items">Custom items</a></h1>
<p>One can also define and use custom items. This is however very experimental and only support in the ossia bindings so far :-)</p>
<h2 id="non-interactive-items"><a class="header" href="#non-interactive-items">Non-interactive items</a></h2>
<p>Here is a non-interactive item:</p>
<pre><code class="language-cpp">struct custom_anim
{
  // Static item metadatas: mandatory
  static constexpr double width() { return 200.; }
  static constexpr double height() { return 200.; }
  static constexpr double layout() { enum { custom } d{}; return d; }

  // In practice with the helpers, we use a type with the mandatory parts
  // already defined and just focus on our item's specificities ; this is 
  // enabled by this typedef.
  using item_type = custom_anim;

  // Item properties: those are mandatory
  double x = 0.0;
  double y = 0.0;
  double scale = 1.0;

  // Our paint method. avnd::painter is a concept which maps to the most usual 
  // canvas-like APIs. It is not necessary to indicate it - it just will give better
  // error messages in case of mistake, and code completion (yes) in IDEs such as QtCreator
  void paint(avnd::painter auto ctx)
  {
    constexpr double cx = 30., cy = 30.;
    constexpr double side = 40.;
  
    ctx.set_stroke_color({.r = 92, .g = 53, .b = 102, .a = 255});
    ctx.set_fill_color({173, 127, 168, 255});

    ctx.translate(100, 100);
    ctx.rotate(rot += 0.1);
  
    for(int i = 0; i &lt; 10; i++)
    {
      ctx.translate(10, 10);
      ctx.rotate(5.+ 0.1 * rot);
      ctx.scale(0.8, 0.8);
      ctx.begin_path();
  
      ctx.draw_rect(-side / 2., -side / 2., side, side);
      ctx.fill();
      ctx.stroke();
    }
  
    ctx.update();
  }

  double rot{};
};
</code></pre>
<p>This produces the small squares animation here: </p>
<p><img src="advanced/images/ui-image.gif" alt="Basic UI" /></p>
<h2 id="interactive-items-for-controlling-single-ports"><a class="header" href="#interactive-items-for-controlling-single-ports">Interactive items for controlling single ports</a></h2>
<p>This is <em>even more</em> experimental :)</p>
<p>Here is what I believe to be the first entirely UI-library-independent UI slider defined in C++.</p>
<pre><code class="language-cpp">// This type allows to define a sequence of operations which will modify a value, 
// in order to allow handling undo-redo properly. 
// The std::function members are filled by the bindings.
template&lt;typename T&gt;
struct transaction
{
  std::function&lt;void()&gt; start;
  std::function&lt;void(const T&amp;)&gt; update;
  std::function&lt;void()&gt; commit;
  std::function&lt;void()&gt; rollback;
};

// look ma, no inheritance
struct custom_slider
{
  // Same as above
  static constexpr double width() { return 100.; }
  static constexpr double height() { return 20.; }

  // Needed for changing the ui. It's the type above - it's already defined as-is 
  // in the helpers library.
  halp::transaction&lt;double&gt; transaction;

  // Called when the value changes from the host software.
  void set_value(const auto&amp; control, double value)
  {
    this-&gt;value = avnd::map_control_to_01(control, value);
  }

  // When transaction.update() is called, this converts the value in the slider 
  // into one fit for the control definition passed as argument.
  static auto value_to_control(auto&amp; control, double value)
  {
    return avnd::map_control_from_01(control, value);
  }

  // Paint method: same as above
  void paint(avnd::painter auto ctx)
  {
    ctx.set_stroke_color({200, 200, 200, 255});
    ctx.set_stroke_width(2.);
    ctx.set_fill_color({120, 120, 120, 255});
    ctx.begin_path();
    ctx.draw_rect(0., 0., width(), height());
    ctx.fill();
    ctx.stroke();

    ctx.begin_path();
    ctx.set_fill_color({90, 90, 90, 255});
    ctx.draw_rect(2., 2., (width() - 4) * value, (height() - 4));
    ctx.fill();
  }

  // Return true to handle the event. x, y, are the positions of the item in local coordinates.
  bool mouse_press(double x, double y)
  {
    transaction.start();
    mouse_move(x, y);
    return true;
  }

  // Obvious :-)
  void mouse_move(double x, double y)
  {
    const double res = std::clamp(x / width(), 0., 1.);
    transaction.update(res);
  }

  // Same
  void mouse_release(double x, double y)
  {
    mouse_move(x, y);
    transaction.commit();
  }
  
  double value{};
};

// This wraps a custom widget in all the data which is mandatory to have so that we do not have to repeat it.
// This is also already provided in the helper library ; using it looks like: 
// 
// halp::custom_item&lt;custom_slider, &amp;inputs::my_control&gt;
template&lt;typename T, auto F&gt;
struct custom_item
{
  static constexpr double layout() { enum { custom } d{}; return d; }
  using item_type = T;

  double x = 0.0;
  double y = 0.0;
  double scale = 1.0;
  decltype(F) control = F;
};
</code></pre>
<h2 id="painter-api"><a class="header" href="#painter-api">Painter API</a></h2>
<p>Here is the complete supported API so far:</p>
<pre><code class="language-cpp">#pragma once

/* SPDX-License-Identifier: GPL-3.0-or-later OR BSL-1.0 OR CC0-1.0 OR CC-PDCC OR 0BSD */

namespace avnd
{
template&lt;typename T&gt;
concept painter = requires (T t) {
  // Paths:
  t.begin_path();
  t.close_path();
  t.stroke();
  t.fill();

  //        x , y
  t.move_to(0., 0.);
  t.line_to(0., 0.);

  //       x , y , w , h , startAngle, arcLength
  t.arc_to(0., 1., 2., 3., 11.       , 12.);

  //         c1x, c1y, c2x, c2y, endx, endy
  t.cubic_to(0. ,  1., 2. , 3. , 11. , 12.);
  //        x1, y1, x2, y2
  t.quad_to(0., 1., 2., 3.);

  // Transformations:
  //          x , y
  t.translate(0., 0.);
  t.scale(0., 0.);
  t.rotate(0.);
  t.reset_transform();

  // Colors:
  //                  R    G    B    A
  t.set_stroke_color({255, 255, 255, 127});
  t.set_stroke_width(2.);
  t.set_fill_color({255, 255, 255, 127});

  // Text:
  t.set_font(&quot;Comic Sans&quot;);
  t.set_font_size(10.0); // In points

  //          x , y , text
  t.draw_text(0., 0., &quot;Hello World&quot;);

  // Drawing
  //          x1, y1, x2 , y2
  t.draw_line(0., 0., 10., 10.);

  //          x , y , w  , h
  t.draw_rect(0., 0., 10., 10.);

  //                  x , y , w  , h  , r
  t.draw_rounded_rect(0., 0., 10., 10., 5.);

  //            x , y , filename
  t.draw_pixmap(0., 0., &quot;pixmap&quot;);

  //             x , y , w  , h
  t.draw_ellipse(0., 0., 10., 10.);

  //            cx, cy, radius
  t.draw_circle(0., 0., 20.);
};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ui-message-bus"><a class="header" href="#ui-message-bus">UI message bus</a></h1>
<p>Some UIs may have more complicated logic that cannot just be represented through 
widgets changing single controls: pressing a button may trigger the loading of a file, 
the entire reconfiguration of the UI, etc.</p>
<p>Thus, the engine may have to be notified of such changes happening in the UI. The way this is 
generally done is through thread-safe queues exchanging messages.</p>
<p>An experimental implementation of this has been done in <em>ossia score</em>. 
Here is a skeleton for how to write such a plug-in: </p>
<pre><code class="language-cpp">using message_to_ui = ...;
using message_to_engine = ...;

struct MyProcessor {
  // Receive a message on the processing thread from the UI
  void process_message(message_to_engine msg)
  {
    // 3. The engine received the message from the UI.
    //    It can for instance send a confirmation that the message has been received:
    send_message(message_to_ui{ ... });
  }

  // Send a message from the processing thread to the ui
  std::function&lt;void(message_to_ui)&gt; send_message;

  struct ui {
    // Define the UI here as seen previously.

    struct bus {
      // 1. Set up connections from UI widgets to the message bus
      void init(ui&amp; ui)
      {
        ui.some.widget.on_some_event = [&amp;] {
          // 2. Some action occured on the UI: this callback is called.
          //    We send a message to the engine: 
          this-&gt;send_message(message_to_engine{...});
        };
      }

      // Receive a message on the UI thread from the processing thread
      static void process_message(ui&amp; self, processor_to_ui msg)
      {
        // 4. The UI has received the confirmation from the engine, 
        //    we made a safe round-trip between our threads :-)
      }

      // Send a message from the ui to the processing thread
      std::function&lt;void(ui_to_processor)&gt; send_message;
    }
  };
}
</code></pre>
<p>Note that <code>message_to_ui</code> and <code>message_to_engine</code> can be any simple type: </p>
<ul>
<li>Ints, floats, strings, etc.</li>
<li><code>std::vector</code></li>
<li><code>std::variant</code></li>
<li>Any combination and nesting of those in an aggregate struct. </li>
</ul>
<p>For example, the following type will automatically be serialized &amp; deserialized:</p>
<pre><code class="language-cpp">struct ui_to_processor {
  int foo;
  std::string bar;
  std::variant&lt;float, double&gt; x;
  std::vector&lt;float&gt; y;
  struct {
    int x, y;
  } baz;
};
</code></pre>
<p>So far this has only been tested on a single computer but this could be tried over a network too.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-bus-example"><a class="header" href="#message-bus-example">Message bus example</a></h1>
<pre><code class="language-cpp">ï»¿#pragma once

/* SPDX-License-Identifier: GPL-3.0-or-later */

#include &lt;avnd/concepts/processor.hpp&gt;
#include &lt;avnd/concepts/painter.hpp&gt;
#include &lt;avnd/wrappers/controls.hpp&gt;
#include &lt;halp/custom_widgets.hpp&gt;
#include &lt;halp/audio.hpp&gt;
#include &lt;halp/controls.hpp&gt;
#include &lt;halp/layout.hpp&gt;
#include &lt;halp/meta.hpp&gt;
#include &lt;cmath&gt;

#include &lt;cstdio&gt;

namespace examples::helpers
{
struct custom_button
{
    static constexpr double width() { return 100.; }
    static constexpr double height() { return 100.; }

    void paint(avnd::painter auto ctx)
    {
      ctx.set_stroke_color({200, 200, 200, 255});
      ctx.set_stroke_width(2.);
      ctx.set_fill_color({100, 100, 100, 255});
      ctx.begin_path();
      ctx.draw_rounded_rect(0., 0., width(), height(), 5);
      ctx.fill();
      ctx.stroke();

      ctx.set_fill_color({0, 0, 0, 255});
      ctx.begin_path();
      ctx.draw_text(20., 20., fmt::format(&quot;{}&quot;, press_count));
      ctx.fill();
    }

    bool mouse_press(double x, double y)
    {
      on_pressed();
      return true;
    }

    void mouse_move(double x, double y)
    {
    }

    void mouse_release(double x, double y)
    {
    }

    int press_count{0};

    std::function&lt;void()&gt; on_pressed = [] { };
};

/**
 * This example shows how communication through a thread-safe message
 * bus between the UI and the engine can be achieved.
 *
 * The data flow in the example does a complete round-trip
 * from the UI to the engine and back to the UI again:
 *
 * - When the button is clicked in the UI, it calls custom_button::on_pressed
 * - In the ui::bus::init this generates a message from this, sent through
 *   ui::bus::send_message.
 * - Behind the scene, the bindings serialize the message and ask the host to kindly
 *   pass it to the engine thread.
 * - Engine thread receives the deserialized message in MessageBusUi::process_message
 * - Engine thread sends a feedback to the ui through MessageBusUi::send_message
 * - Bindings transfer it back to the ui thread, ui::bus::process_message(ui, the_message)
 *   gets called
 *
 * To implement multiple messages one can simply use std::variant as the argument type:
 *
 *   std::variant&lt;message1, message2, etc...&gt;
 *
 * Note that you don't have to implement serialization manually:
 * as long as the messages are aggregates, things happen magically :-)
 *
 */
struct MessageBusUi
{
  static consteval auto name() { return &quot;MessageBusUi example&quot;; }
  static consteval auto c_name() { return &quot;avnd_mbus_ui&quot;; }
  static consteval auto uuid() { return &quot;4ed8e7fd-a1fa-40a7-bbbe-13ee50044248&quot;; }

  struct { } inputs;
  struct { } outputs;

  void operator()(int N) { }

  // Here are some message types. Their type names do not matter, only that they are
  // aggregates. What matters is that they are used as arguments to process_message.

  // This one will be serialized / deserialized as it is not a trivial type
  struct ui_to_processor {
    int foo;
    std::string bar;
    std::variant&lt;float, double&gt; x;
    std::vector&lt;float&gt; y;
    struct {
      int x, y;
    } baz;
  };

  // This one will be memcpy'd as it is a trivial type
  struct processor_to_ui {
    float bar;
    struct {
      int x, y;
    } baz;
  };

  // 1. Receive a message on the processing thread from the UI
  void process_message(const ui_to_processor&amp; msg)
  {
    fprintf(stderr, &quot;Got message in processing thread !\n&quot;);
    send_message(processor_to_ui{.bar = 1.0, .baz{3, 4}});
  }

  // 2. Send a message from the processing thread to the ui
  std::function&lt;void(processor_to_ui)&gt; send_message;

  // Define our UI
  struct ui {
    halp_meta(layout, halp::layouts::container)
    halp_meta(width, 100)
    halp_meta(height, 100)

    struct {
      halp_meta(layout, halp::layouts::container)
      halp::custom_actions_item&lt;custom_button&gt; button{
          .x = 10
        , .y = 10
        // We'd like to define our callback here,
        // sadly C++ scoping rules do not allow it as soon as there is nesting
      };
    } foo;

    // Define the communication between UI and processor.
    struct bus {
      // 3. Set up connections
      void init(ui&amp; ui)
      {
        ui.foo.button.on_pressed = [&amp;] {
          fprintf(stderr, &quot;Sending message from UI thread !\n&quot;);
          this-&gt;send_message(ui_to_processor{.foo = 123, .bar = &quot;hiii&quot;, .x = 0.5f, .y = { 1, 3, 5 }});
        };
      }

      // 4. Receive a message on the UI thread from the processing thread
      static void process_message(ui&amp; self, processor_to_ui msg)
      {
        fprintf(stderr, &quot;Got message in ui thread ! %d %d\n&quot;, msg.baz.x, msg.baz.y);
        self.foo.button.press_count++;
      }

      // 5. Send a message from the ui to the processing thread
      std::function&lt;void(ui_to_processor)&gt; send_message;
    };
  };
};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="feature-injection"><a class="header" href="#feature-injection">Feature injection</a></h1>
<p>Many processors may require some kind of common, cross-cutting algorithm or system for their proper operation.</p>
<p>Processors can optionally declare a template argument, which will contain the implementations of these &quot;cross-cutting concerns&quot; supported by the backend.</p>
<p>For now, there are two: </p>
<ul>
<li>A logging system</li>
<li>An 1D FFT </li>
</ul>
<pre><code class="language-cpp">template&lt;typename Conf&gt;
// Get a compile error if the bindings cannot provide the thing.
requires (halp::has_fft_1d&lt;Conf, double&gt; &amp;&amp; halp::has_logger&lt;Conf&gt;)
struct MyProcessor {
  using logger = typename Conf::logger_type;
  using fft_type = typename Conf::template fft_type&lt;double&gt;;
};
</code></pre>
<p>This means that for instance, a processor can log to the Pd or Max console through <code>post(...)</code>, to stdout on Python, etc. and that they are relieved of the need to go look for an FFT algorithm.</p>
<p>Hosts like <em>ossia score</em> will be able to plug-in their own FFT implementation optimized for the platform on which the plug-in is running (and binaries will stop having 45 duplicate FFT implementations...).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging-feature"><a class="header" href="#logging-feature">Logging feature</a></h1>
<p>The API is modeled after <a href="https://github.com/gabime/spdlog">spdlog</a> and expects the <a href="https://github.com/fmtlib/fmt">fmt</a> syntax: </p>
<pre><code class="language-cpp">#pragma once

/* SPDX-License-Identifier: GPL-3.0-or-later */

#include &lt;halp/log.hpp&gt;
#include &lt;halp/messages.hpp&gt;
#include &lt;halp/meta.hpp&gt;

// Sadly this example makes GCC segfault:
// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=102990
namespace examples::helpers
{
/**
 * This examples shows how things can look with a small helper
 * library to abstract common use cases.
 */
template &lt;typename C&gt;
requires
    // Here we pass template arguments as a primitive form of dependency injection.
    // Out effect is saying: &quot;I want to be passed configured with a type
    // holding a &quot;logger_type&quot; typedef
    // which will be something matching the logger concept.
    halp::has_logger&lt;C&gt;
struct Logger
{
  // halp_meta is simply a macro that expands to a consteval function.
  // Hopefully C++ would use a similar syntax for reflexion.
  halp_meta(name, &quot;Helpers&quot;)
  halp_meta(c_name, &quot;avnd_helpers_logger&quot;)
  halp_meta(uuid, &quot;3a646521-48f4-429b-a2b1-d67beb0d65cf&quot;)

  // We store our logger in the class to make things simpler.
  // no_unique_address makes sure that it stays a zero-memory-cost abstraction
  // if possible.
  [[no_unique_address]] typename C::logger_type logger;

  // Helpers for referring to local functions.
  // Ideally metaclasses would make that obsolete.
  void example(float x) {
    logger.trace(&quot;example: {}&quot;, x);
    logger.info(&quot;example: {}&quot;, x);
    logger.debug(&quot;example: {}&quot;, x);
    logger.warn(&quot;example: {}&quot;, x);
    logger.error(&quot;example: {}&quot;, x);
    logger.critical(&quot;example: {}&quot;, x);
  }

  struct
  {
    halp::func_ref&lt;&quot;member&quot;, &amp;Logger&lt;C&gt;::example&gt; my_message;
  } messages;
};
}
</code></pre>
<blockquote>
<p>Avendish currently will look for <code>fmtlib</code> for its logger implementation, until <code>std::format</code> gets implemented by compiler authors.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fft-feature"><a class="header" href="#fft-feature">FFT feature</a></h1>
<p>FFT operates on complex numbers ; you can expect a <code>real()</code> and <code>complex()</code> members.
Here is a simple example, which looks for the band with the most amplitude.</p>
<pre><code class="language-cpp">#pragma once
#include &lt;halp/audio.hpp&gt;
#include &lt;halp/controls.hpp&gt;
#include &lt;halp/meta.hpp&gt;
#include &lt;halp/fft.hpp&gt;
#include &lt;cmath&gt;

namespace examples::helpers
{

/**
 * This examples shows how one can get an FFT implementation to be
 * dependency-injected at compile-time. Check the Logger example for more explanations.
 *
 * The idea is that the host software / plugin wrapper will provide its own FFT implementation.
 * This way, we don't end up with 450 different FFT implementations in a single binary,
 * and the algorithm is abstracted from the actual way to compute the FFT which does not
 * matter - it could be FFTW, MKL, etc... depending on the licensing requirements
 * of the project, or be left up to the host which will instantiate the plug-in.
 */

template &lt;halp::has_fft_1d&lt;double&gt; C&gt;
struct PeakBand
{
  halp_meta(name, &quot;Peak band&quot;)
  halp_meta(c_name, &quot;avnd_peak_band&quot;)
  halp_meta(uuid, &quot;5610b62e-ef1f-4a34-abe0-e57816bc44c2&quot;)

  struct
  {
    halp::audio_channel&lt;&quot;In&quot;, double&gt; audio;
  } inputs;

  struct
  {
    halp::val_port&lt;&quot;Peak&quot;, double&gt; peak;
    halp::val_port&lt;&quot;Band&quot;, int&gt; band;
  } outputs;

  // Instantiate the FFT provided by the configuration.
  // Syntax is a bit ugly as we are already in a template
  // causing the need for the &quot;::template &quot; thing ; in C++23
  // it should be possible to omit typename.
  using fft_type = typename C::template fft_type&lt;double&gt;;
  fft_type fft;

  void prepare(halp::setup info)
  {
    // Initialize potential internal FFT buffers
    fft.reset(info.frames);
  }

  void operator()(int frames)
  {
    outputs.peak = 0.;

    // Process the fft
    auto cplx = fft.execute(inputs.audio.channel, frames);

    // Compute the band with the highest amplitude
    for (int k = 0; k &lt; frames / 2; k++)
    {
      const double mag_squared = std::norm(cplx[k]);
      if (mag_squared &gt; outputs.peak)
      {
        outputs.peak = mag_squared;
        outputs.band = k;
      }
    }

    outputs.peak = std::sqrt(outputs.peak);
  }
};

}
</code></pre>
<blockquote>
<p>Avendish currently provides a very simple and unoptimized FFT for the sake of testing. Contributions of bindings to more efficient FFT libraries are very welcome :-)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="presets"><a class="header" href="#presets">Presets</a></h1>
<p>An experimental presets feature has been prototyped for the Vintage back-end.</p>
<p>Here is how one may define presets:</p>
<pre><code class="language-cpp">// Our inputs
struct
{
  halp::hslider_f32&lt;&quot;Preamp&quot;&gt; preamp;
  halp::hslider_f32&lt;&quot;Volume&quot;&gt; volume;
} inputs;

// We define the type of our programs, like in the other cases
// it ends up being introspected automatically.
struct program {
  std::string_view name;
  decltype(Presets::inputs) parameters;
};

// Definition of the presets:
// Note: it's an array instead of a function because
// it's apparently hard to deduce N in array&lt;..., N&gt;, unlike in C arrays.
static constexpr const program programs[]{
    {.name{&quot;Low gain&quot;}, .parameters{.preamp = {0.3}, .volume = {0.6}}},
    {.name{&quot;Hi gain&quot;},  .parameters{.preamp = {1.0}, .volume = {1.0}}},
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sample-accurate-processing"><a class="header" href="#sample-accurate-processing">Sample-accurate processing</a></h1>
<p>So far, we saw that control ports / parameters would have a single <code>value</code> member, which as one can expects, 
stays constant for at least the entire duration of a tick.</p>
<p>However, some hosts (such as <em>ossia score</em>) are able to give precise timestamps to control values.</p>
<p>If an algorithm supports this level of precision, it can be expressed by extending value ports in the following way:</p>
<pre><code class="language-cpp">struct { 
  static consteval auto name() { return &quot;Control&quot;; } 

  /* a value_map type */ values;
  float value; 
} control;
</code></pre>
<ul>
<li><code>value</code> will always carry the &quot;running&quot; value at the beginning of the tick, like before.</li>
<li><code>values</code> is a type which should be API-wise more-or-less compatible with <code>std::map&lt;int, type_of_value&gt;</code>. </li>
</ul>
<p>For every message received in the tick, <code>values</code> will be set (which means that they can also be empty if no message at all was received on that port).</p>
<p>There are actually three options for implementing <code>values</code>.</p>
<ul>
<li>
<p>Option A: <code>std::map&lt;int, float&gt; values</code>: the simplest case. Can be slow. A helper which uses <code>boost::small_flat_map</code> is provided: it provides neat performance and won't allocate unless the port is spammed. </p>
</li>
<li>
<p>Option B: <code>std::optional&lt;float&gt;* values;</code>: here, a <code>std::optional&lt;float&gt;</code> array of the same length than audio channels will be allocated. Indexing is the same than for audio samples.</p>
</li>
<li>
<p>Option C can only be used for inputs:</p>
</li>
</ul>
<pre><code class="language-cpp">struct timestamped_value {
  T value;
  int frame;
 };
  std::span&lt;timestamped_value&gt; values;
</code></pre>
<p>This is the most efficient storage if you expect to receive few values (and also the most &quot;my device has extremely little RAM&quot;-friendly one), however the ability to just do <code>values[frame_index]</code> is lost as the index now only goes up to the allocated messages (which can be zero if no message was received for this tick).</p>
<h1 id="helpers-4"><a class="header" href="#helpers-4">Helpers</a></h1>
<p>A single helper is provided for now: <code>halp::accurate&lt;T&gt;</code>.</p>
<p>It can be used like this to wrap an existing control type to add it a sample-accurate storage buffer:</p>
<pre><code>halp::accurate&lt;halp::val_port&lt;&quot;Out&quot;, float&gt;&gt; my_port;
halp::accurate&lt;halp::knob_i32&lt;&quot;Blah&quot;, int&gt;&gt; my_widget;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sample-accurate-processing-example"><a class="header" href="#sample-accurate-processing-example">Sample-accurate processing example</a></h1>
<pre><code class="language-cpp">#pragma once
#include &lt;avnd/concepts/audio_port.hpp&gt;
#include &lt;avnd/concepts/parameter.hpp&gt;
#include &lt;halp/audio.hpp&gt;
#include &lt;halp/controls.hpp&gt;
#include &lt;halp/meta.hpp&gt;
#include &lt;halp/sample_accurate_controls.hpp&gt;
#include &lt;cmath&gt;

namespace examples
{
struct SampleAccurateFilterExample
{
  halp_meta(name, &quot;My sample-accurate filter&quot;);
  halp_meta(c_name, &quot;sample_acc_filt&quot;);
  halp_meta(category, &quot;Demo&quot;);
  halp_meta(author, &quot;&lt;AUTHOR&gt;&quot;);
  halp_meta(description, &quot;&lt;DESCRIPTION&gt;&quot;);
  halp_meta(uuid, &quot;43818edd-63de-458b-a6a5-08033cefc051&quot;);

  /**
   * Here we define an input and an output pair.
   */
  struct
  {
    halp::accurate&lt;halp::val_port&lt;&quot;In&quot;, float&gt;&gt; value;
  } inputs;

  struct
  {
    halp::accurate&lt;halp::val_port&lt;&quot;Out&quot;, float&gt;&gt; value;
  } outputs;

  void operator()()
  {
    // The output is copied at the same timestamp at which each input happened.
    for (auto&amp; [timestamp, value] : inputs.value.values)
    {
      outputs.value.values[timestamp] = cos(value * value) * cos(value);
    }
  }
};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-channel-mimicking"><a class="header" href="#audio-channel-mimicking">Audio channel mimicking</a></h1>
<p>As discussed when introducing audio ports, for the sake of simplicity, a processor with one input and one output audio bus, if it does not specify a specific channel count, is assumed to have as many input as it has output channels.</p>
<p>For instance, consider the following case:</p>
<pre><code class="language-cpp">struct
{
  halp::audio_input_bus&lt;&quot;Main Input&quot;&gt; audio;
} inputs;

struct
{
  halp::audio_output_bus&lt;&quot;Output&quot;&gt; audio;
} outputs;
</code></pre>
<p>Here, everything is fine: the host can send 1, 2, ... channels to the input, and Avendish will make sure that the audio output matches that.</p>
<p>Now imagine that we add another bus: </p>
<pre><code class="language-cpp">struct ins
{
  halp::audio_input_bus&lt;&quot;Main Input&quot;&gt; audio;
  halp::audio_input_bus&lt;&quot;Sidechain&quot;&gt; sidechain;
} inputs;

struct outs
{
  halp::audio_output_bus&lt;&quot;Output&quot;&gt; audio;
} outputs;
</code></pre>
<p>Even if for us, humans, it is reasonable to assume that there will be as many output channels, as there are in the main input, it is not something that a computer can assume that easily.</p>
<p>Thus, there is a way to indicate that a given port will use the same channel count as a specific input.</p>
<p>In raw terms, this is done by adding the following function in the output port definition:</p>
<pre><code class="language-cpp">static constexpr auto mimick_channel = &amp;ins::audio;
</code></pre>
<p>Taking the member function pointer to an input will allow Avendish to match the channel count at run-time.</p>
<p>An helper is provided: for instance, in the above case, it would give: </p>
<pre><code class="language-cpp">struct ins
{
  halp::audio_input_bus&lt;&quot;Main Input&quot;&gt; audio;
  halp::audio_input_bus&lt;&quot;Sidechain&quot;&gt; sidechain;
} inputs;

struct outs
{
  halp::mimic_audio_bus&lt;&quot;Output&quot;, &amp;ins::audio&gt; audio;
} outputs;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-with-cmake"><a class="header" href="#configuration-with-cmake">Configuration with CMake</a></h1>
<p>So far, the &quot;building&quot; side of things has been left under the carpet.</p>
<p>It is actually not very complicated.</p>
<p>We have:</p>
<ul>
<li>A processor, <code>MyProcessor</code>.</li>
<li>A binding for which we want to build this processor, for instance a Python or VST3 binding.</li>
</ul>
<p>What CMake does is that it generates a small <code>.cpp</code> file that combines both.</p>
<p>Here is for instance how it is done for Python: </p>
<pre><code class="language-cpp">/* SPDX-License-Identifier: GPL-3.0-or-later */

#include &lt;@AVND_MAIN_FILE@&gt;
#include &lt;avnd/binding/python/configure.hpp&gt;
#include &lt;avnd/binding/python/processor.hpp&gt;

PYBIND11_MODULE(py@AVND_C_NAME@, m)
{
  using type = decltype(avnd::configure&lt;python::config, @AVND_MAIN_CLASS@&gt;())::type;
  static const python::processor&lt; type &gt; instance{m};
}
</code></pre>
<p>Here, <code>AVND_MAIN_FILE</code>, <code>AVND_C_NAME</code> and <code>AVND_MAIN_CLASS</code> are options that are passed to CMake. 
For an actual processor though, it's likely that you would have to write your own entrypoint.</p>
<p>Here is the Clap entrypoint, which is fairly similar: </p>
<pre><code class="language-cpp">/* SPDX-License-Identifier: GPL-3.0-or-later */

#include &lt;@AVND_MAIN_FILE@&gt;
#include &lt;avnd/binding/clap/audio_effect.hpp&gt;
#include &lt;avnd/binding/clap/configure.hpp&gt;

using plug_type = decltype(avnd::configure&lt;avnd_clap::config, @AVND_MAIN_CLASS@&gt;())::type;
using effect_type = avnd_clap::SimpleAudioEffect&lt;plug_type&gt;;

AVND_EXPORTED_SYMBOL const struct clap_plugin_entry clap_plugin_entry = {
   CLAP_VERSION,
   +[] (const char* path) -&gt; bool { /* init */ return true; },
   +[] () { /* deinit */ },
   +[] () -&gt; uint32_t { /* count */ return 1; },
   +[] (uint32_t) -&gt; const clap_plugin_descriptor* { return &amp;effect_type::descriptor; },

   +[] (const clap_host *host, const char *plugin_id) -&gt; const clap_plugin* { return new effect_type{host}; },

   +[] () -&gt; uint32_t { return 0; },
   +[] (uint32_t) -&gt; const clap_plugin_invalidation_source* { return nullptr; },

   +[] () { /* refresh */ },
};
</code></pre>
<h2 id="cmake-functions"><a class="header" href="#cmake-functions">CMake functions</a></h2>
<p>The CMake script currently provides pre-made integrations with the bindings we support.</p>
<p>There are helper functions that build every binding possible in one go:</p>
<pre><code class="language-cmake"># Create bindings for everything under the sun
avnd_make_all(...)

# Create bindings for general object-based systems: 
# - PureData, Max/MSP
# - Python
# - Ossia
# - Standalone demo examples
avnd_make_object(...)

# Create bindings for audio APIs: Vintage, VST3, Clap
avnd_make_audioplug(...)
</code></pre>
<p>Which just call the individual functions:</p>
<pre><code class="language-cmake">avnd_make_vst3(...)
avnd_make_pd(...)
avnd_make_max(...)
etc...
</code></pre>
<p>These functions all have the same syntax:</p>
<pre><code>avnd_make_all(
  # The CMake target:
  TARGET PerSampleProcessor2

  # The file to include to get a complete definition of the processor
  MAIN_FILE examples/Raw/PerSampleProcessor2.hpp

  # The C++ class name
  MAIN_CLASS examples::PerSampleProcessor2

  # A name to give for systems which depend on C-ish names for externals, like Max/MSP and PureData.
  C_NAME avnd_persample_2
)
</code></pre>
<h2 id="doing-it-by-hand"><a class="header" href="#doing-it-by-hand">Doing it by hand</a></h2>
<p>This is not very hard: Avendish is a header-only library, so you just have to add the <code>avendish/include</code> folder to your include path, 
and the <code>-std=c++20</code> flag to your build-system.</p>
<blockquote>
<p>Depending on your compiler, you may also need to add flags such as <code>-fconcepts</code> (GCC &lt;= 9) ; <code>-fcoroutines</code> (GCC &lt;= 11) ; <code>-fcoroutines-ts</code> (Clang &lt;= 14).</p>
</blockquote>
<blockquote>
<p>Until the reflection TS gets merged, we have a dependency on Boost.PFR so you also need to include <code>boost</code>. Boost.PFR is header-only.</p>
</blockquote>
<blockquote>
<p>You also likely want to add <code>fmt</code> to get nice logging.</p>
</blockquote>
<p>Finally, we have to wrap our class with the binding.</p>
<pre><code class="language-cpp">// Defines struct MyProcessor { ... };
#include &quot;MyProcessor.hpp&quot;
#include &quot;MyBinding.hpp&quot;
// Set up those typedefs to provide services to plug-ins which need it
struct my_config {
   using logger_type = ...;
   using fft_1d_type = ...;
};

int main()
{
  // This will instantiate my_processor with the configuration passed as template argument if needed:
  using plug_type = decltype(avnd::configure&lt;my_config, my_processor&gt;())::type;

  // Finally create the binding object
  MyBinding&lt;plug_type&gt; the_binding;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gpu-based-draw-nodes"><a class="header" href="#gpu-based-draw-nodes">GPU-based draw nodes</a></h1>
<p>The techniques shown so far for writing cross-system audio and media processors can be extended to the general ontology of &quot;modern GPU pipeline&quot;, 
in order to define API-independent GPU-based objects.</p>
<p>Here are some useful readings to get an idea of the problem space: </p>
<ul>
<li><a href="https://alain.xyz/blog/comparison-of-modern-graphics-apis">https://alain.xyz/blog/comparison-of-modern-graphics-apis</a></li>
<li><a href="https://www.qt.io/blog/qt-quick-on-vulkan-metal-direct3d">https://www.qt.io/blog/qt-quick-on-vulkan-metal-direct3d</a></li>
<li><a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/RHI/">https://docs.unrealengine.com/4.27/en-US/API/Runtime/RHI/</a></li>
<li><a href="https://zeux.io/2020/02/27/writing-an-efficient-vulkan-renderer/">https://zeux.io/2020/02/27/writing-an-efficient-vulkan-renderer/</a></li>
<li><a href="https://zeux.io/2020/02/27/writing-an-efficient-vulkan-renderer/">https://www.o3de.org/docs/atom-guide/dev-guide/rhi/</a></li>
</ul>
<p>What we are trying to do is define a declarative RHI (see Qt RHI, NVRHI, Unreal RHI, etc.): we do not want to call any API function 
in order to preserve independence of the written nodes from the underlyling API: stating that one needs to allocate and upload a buffer prior to executing 
a pipeline should not depend on any concrete GPU API and should be doable in the simplest possible way: the code 
should be defined in terms of its absolute minimal requirements in order to enable it to work on the widest range of systems possible.</p>
<p>Just like we have done so far, we provide &quot;helper types&quot; which are entirely optional but can reduce wrist strain :-)
Bindings have zero dependency on any of the helper types and namespaces (<code>halp</code>, <code>gpp</code>) shown here -- everything depends on the shape of things.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ul>
<li>We assume a specific shader language (Vulkan-compatible GLSL 4.5), any ideas to improve this are welcome.</li>
<li>The only binding so far is being developed in <a href="https://ossia.io">ossia score</a> on top of the Qt RHI which inspired this quite a bit.</li>
</ul>
<h2 id="defining-a-primitive-pipeline-ontology"><a class="header" href="#defining-a-primitive-pipeline-ontology">Defining a primitive pipeline ontology</a></h2>
<p>A GPU pipeline carries much more information than the average audio object, as GPUs are pretty configurable and specialized systems, with various possible qualifications on their inputs and outputs that are unfamiliar to the programmer accustomed to working with a CPU.</p>
<p>The core of a GPU pipeline is the program that will run on it: a shader. Shaders are in themselves very similar to data-flow objects: they define inputs (often the mesh data, textures, and parameters to control the rendering) and outputs (often the color). </p>
<p>The pipeline may have multiple stages: most commonly and in an extremely broad and inaccurate way, the vertex stage positions triangles in the GPU API's coordinate system, and the fragment stage renders these triangles.</p>
<p>The pipeline has a layout: it is the definition of its inputs and outputs. For instance, such a layout may be:</p>
<ul>
<li>
<p>A <code>vec2</code> attribute input at location 0 representing each vertex's position.</p>
</li>
<li>
<p>A <code>vec4</code> attribute input at location 1 representing each vertex's color.</p>
</li>
<li>
<p>A texture at binding 0.</p>
</li>
<li>
<p>A buffer at binding 1 containing parameters for drawing the texture. For instance:</p>
</li>
</ul>
<pre><code class="language-glsl">uniform my_parameters {
  vec4 global_color;
  vec2 sun_position;
  float brightness;
};
</code></pre>
<p>The way it conceptually works is that, for each vertex of each triangle, the vertex shader is called with that vertex, plus the shared global parameters bound. Here is an example</p>
<pre><code class="language-glsl">// Input attributes
layout(location = 0) in vec3 position;
layout(location = 1) in vec4 color;

// Outputs of the vertex shader
layout(location = 0) out vec3 v_color;

// Where we tell the GPU at which position the current 
// fragment is.
out gl_PerVertex { vec4 gl_Position; };

// Shared parameters
layout(std140, binding = 0) uniform my_parameters {
  vec4 global_color;
  vec2 sun_position;
  float brightness;
};

// The actual vertex program
void main() 
{
  // Do some math that transforms pos's coordinates to show it where we want.
  vec4 pos = vec4(position.xt, 0.0, 1.);
  /* ... many matrix multiplications go here ... */
  gl_Position = pos;

  // Just copy the associated color directly to the next stage
  v_color = color;
}
</code></pre>
<p>Once this is done, the outputs of this stage are passed to the fragment shader, which 
will end up computing the color that is to be shown on screen: </p>
<pre><code class="language-glsl">// Input of the fragment shader ; must be the same name, types and locations
// than the output of the vertex shader
layout(location = 0) in vec3 v_color;

// Output of the fragment shader: a color
layout(location = 0) out vec4 fragColor;

// Shared parameters ; must be the same name, types and locations
// than in the vertex shader
layout(std140, binding = 0) uniform my_parameters {
  vec4 global_color;
  vec2 sun_position;
  float brightness;
};

layout(binding = 1) uniform sampler2D tex;

// The actual fragment program
void main() {
  vec4 color = v_color
             + global_color
             + texture(tex, gl_FragCoord);

  fragColor = brightness * color;
}
</code></pre>
<p>The main problem is ensuring that the pipeline's layout as used from the C++ code matches the pipeline's layout as declared in the shader ; as every time there is an information duplication in a system, there is the possibility for errors there.</p>
<p>Here, we have duplication: </p>
<ul>
<li>Between the outputs of the vertex and the input of the fragment - some drivers and APIs are lenient regarding errors here, others are not.</li>
<li>In the C++ side, which must have some way to tell the GPU:
<ul>
<li>The first attribute  will be a vec2</li>
<li>The second attribute will be a vec4</li>
<li>The texture is bound at position 1</li>
<li>etc etc.</li>
</ul>
</li>
</ul>
<p>The idea is that we can use the same principles than saw before to define our layout through a C++ struct, and get our library to automatically generate the relevant inputs and outputs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-the-layout"><a class="header" href="#defining-the-layout">Defining the layout</a></h1>
<p>Defining the layout of a draw pipeline is fairly similar to defining the inputs and outputs of our nodes:</p>
<pre><code class="language-cpp">struct layout
{
  // Indicate that this is a layout for a graphics pipeline
  enum { graphics };

  struct vertex_input 
  {
    struct my_first_attribute { 
      // ...
    } my_first_attribute;

    struct my_second_attribute { 
      // ...
    } my_second_attribute;

    // etc...
  };

  struct vertex_output 
  {
    // ...
  };

  struct fragment_input 
  {
    // ...
  };
  struct fragment_output 
  {
    // ...
  };
  
  struct bindings 
  {
    struct my_ubo 
    {
      // ..
    } my_ubo;

    struct my_sampler 
    {
      // ..
    } my_sampler;
  };
};
</code></pre>
<h2 id="defining-attributes"><a class="header" href="#defining-attributes">Defining attributes</a></h2>
<p>An attribute is defined by the matching C++ data type.</p>
<p>For instance:</p>
<pre><code class="language-glsl">layout(location = 1) in vec3 v_pos;
</code></pre>
<p>is defined through the following C++ code:</p>
<pre><code class="language-cpp">struct {
  // Name of the variable in the shader
  static constexpr auto name() { return &quot;v_pos&quot;; }

  // Location
  static constexpr int location() { return 1; }
 
  // Optional standardized semantic usage for compatibility with usual engines
  enum { position };

  // Corresponding data type
  float data[3];
} my_first_attribute;
</code></pre>
<p>An helper macro is provided to reduce typing:</p>
<pre><code class="language-cpp">// location, name, type, meaning
gpp_attribute(1, v_pos, float[3], position) my_first_attribute;
</code></pre>
<h2 id="defining-samplers"><a class="header" href="#defining-samplers">Defining samplers</a></h2>
<p>Samplers are locations to which textures are bound during the execution of a pipeline.
They are defined in the <code>bindings</code> section of the <code>layout</code> struct.</p>
<p>For instance:</p>
<pre><code class="language-glsl">layout(binding = 2) uniform sampler2D my_tex;
</code></pre>
<p>is defined through:</p>
<pre><code class="language-cpp">struct bindings {
  struct { 
    // Name of the variable in the shader
    static constexpr auto name() { return &quot;my_tex&quot;; }
  
    // Location
    static constexpr int binding() { return 2; }
   
    // Type flag
    enum { sampler2D };  
  } my_sampler;
};
</code></pre>
<p>or the helper version:</p>
<pre><code class="language-cpp">struct bindings {
  gpp::sampler&lt;&quot;my_tex&quot;, 2&gt;  my_sampler;
};
</code></pre>
<h2 id="defining-uniform-buffers"><a class="header" href="#defining-uniform-buffers">Defining uniform buffers</a></h2>
<pre><code class="language-glsl">layout(std140, binding = 2) uniform my_params {
  vec2 coords;
  float foo;
};
</code></pre>
<p>is defined as follows:</p>
<pre><code class="language-cpp">struct bindings {
  struct custom_ubo {
    static constexpr auto name() { return &quot;my_params&quot;; }
    static constexpr int binding() { return 2; }
    enum { std140, ubo };
  
    struct {
      static constexpr auto name() { return &quot;coords&quot;; }
      float value[2];
    } coords;
  
    struct
    {
      static constexpr auto name() { return &quot;foo&quot;; }
      float value;
    } foo;
  } ubo;
};
</code></pre>
<p>And can be refactored a bit to:</p>
<pre><code class="language-cpp">struct bindings {
  struct {
    halp_meta(name, &quot;my_params&quot;);
    halp_meta(binding, 2);
    halp_flags(std140, ubo);
  
    gpp::uniform&lt;&quot;coords&quot;, float[2]&gt; coords;
    gpp::uniform&lt;&quot;foo&quot;, float&gt; foo;
  } ubo;
};
</code></pre>
<p>Note that this is only used as a way to enable us to synthesize the UBO layout in the shader.
In particular, depending on the types used, the GLSL variable packing rules are sometimes different than the C++ ones, 
thus we cannot just send this struct as-is to GPU memory. Maybe when metaclasses happen one will be able to write something
akin to:</p>
<pre><code class="language-cpp">std140_struct { ... } ubo;
</code></pre>
<blockquote>
<p>Note that not everything GLSL feature is supported yet, but is on the roadmap: arrays, ssbos, sampler2DShadow, etc...
Contributions welcome !</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-calls"><a class="header" href="#api-calls">API calls</a></h1>
<p>In general, programming for the GPU involves some level of calling into a graphics API: OpenGL, Vulkan, Metal, or various abstractions on top of them such as the Qt, Unreal, etc... RHIs, libraries such as BGFX, etc.</p>
<p>Like every non-declarative code, this has the sad side-effect of tying you to said library ; it's pretty hard to migrate to, say, Qt's RHI to pure OpenGL or BGFX.
Here, we propose a method that aims to keep the algorithms reusable by having them state their needs without making any API calls.</p>
<p>The API comes with three optional methods that can be reimplemented to control behaviour for now: </p>
<pre><code class="language-cpp">// Allocates ressources and sends data from the CPU to the GPU.
// This method *must* be implemented if there are uniforms or samplers that 
// aren't bound to ports (and the pipeline wouldn't be very useful otherwise)
/* ??? */ update();

// Releases allocated ressources
// This method must take care of releasing anything allocated in update()
/* ??? */ release();

// Submit a draw call. If not implemented a default draw call will be done 
// for the mesh in input of the node.
/* ??? */ draw();
</code></pre>
<h2 id="defining-a-call"><a class="header" href="#defining-a-call">Defining a call</a></h2>
<p>Here is how an <code>update()</code> method which allocates and update a texture may look:</p>
<pre><code class="language-cpp">gpp::texture_handle tex_handle{};

gpp::co_update update()
{
    int sz = 16*16*4;
    // If the texture hasn't been allocated yet
    if(!tex_handle)
    {
      // Request an allocation
      this-&gt;tex_handle = co_yield gpp::texture_allocation{
          .binding = 0
        , .width = 16
        , .height = 16
      };
    }

    // Generate some data
    tex.resize(sz);
    for(int i = 0; i &lt; sz; i++)
      tex[i] = rand();

    // Upload it to the GPU
    co_yield gpp::texture_upload{
        .handle = tex_handle
      , .offset = 0
      , .size = sz
      , .data = tex.data()
    };
  }
}
</code></pre>
<h2 id="commands"><a class="header" href="#commands">Commands</a></h2>
<p>Note that there isn't any direct API call here. Instead, we return user-defined structs: 
for instance, <code>texture_allocation</code> is simply defined like this:</p>
<pre><code class="language-cpp">struct texture_allocation
{
  // Some keywords to allow the command to be matched to an API call
  enum { allocation, texture };

  // What this call is supposed to return
  using return_type = texture_handle;

  // Parameters of the command
  int binding;
  int width;
  int height;
};
</code></pre>
<p>The actual concrete type does not matter: the only important thing is for the following to be possible with the returned struct <code>C</code>:</p>
<pre><code class="language-cpp">// Identify the command
C::allocation; 
C::texture;

// Create a return value
typename C::return_type ret;

// Access the parameters of the call
void f(C&amp; command) {
  int b = command.binding;
  int w = command.weight;
  int h = command.height;
  // etc.
}
</code></pre>
<p>This allows complete independence from the graphics API, as a node only specifies exactly the allocation / update / draw calls it needs to do in the most generic possible way ; for instance, a node that only allocates and uploads a texture should be easily bindable to any graphics API on earth.</p>
<p>An in-progress set of common commands is provided.</p>
<h2 id="coroutines"><a class="header" href="#coroutines">Coroutines</a></h2>
<p>To allow this to work, <code>gpp::co_update</code> is a coroutine type.
Here too, the binding code does not depend on the concrete type of the coroutine ; only that it matches a concept.</p>
<p><code>gpp::co_update</code> is defined as:</p>
<pre><code class="language-cpp">// All the possible commands that can be used in update()
using update_action = std::variant&lt;
  static_allocation, static_upload,
  dynamic_vertex_allocation, dynamic_vertex_upload, buffer_release,
  dynamic_index_allocation, dynamic_index_upload,
  dynamic_ubo_allocation, dynamic_ubo_upload, ubo_release,
  sampler_allocation, sampler_release,
  texture_allocation, texture_upload, texture_release,
  get_ubo_handle
&gt;;

// What the commands are allowed to return
using update_handle = std::variant&lt;std::monostate, buffer_handle, texture_handle, sampler_handle&gt;;

// Definition of the update() coroutine type
using co_update = gpp::generator&lt;update_action, update_handle&gt;;
</code></pre>
<p>Where <code>gpp::generator</code> is a type similar to <code>std::generator</code> which is not available yet in C++20 but will be in C++23.</p>
<h2 id="benefits-of-the-approach"><a class="header" href="#benefits-of-the-approach">Benefits of the approach</a></h2>
<p>This has interesting benefits besides the separation of concern which is achieved: </p>
<ol>
<li>It allows to restrict what kind of call can be done in which function.
For instance, the Qt RHI forbids uploading data during a draw operation: the coroutine type for <code>draw</code> does not contain 
the update commands, which allows to enforce this at compile-time. Yay C++ :-)</li>
</ol>
<p>A node which only ever uploads textures could optimize a little bit by defining instead: </p>
<pre><code class="language-cpp">using update_action = std::variant&lt;texture_allocation, texture_upload, texture_release&gt;;
using update_handle = std::variant&lt;std::monostate, texture_handle&gt;;

using my_co_update = gpp::generator&lt;update_action, update_handle&gt;;
</code></pre>
<blockquote>
<p>Of course, we would love this to be performed automatically as part of compiler optimizations... it seems that the science is not there yet though !</p>
</blockquote>
<ol start="2">
<li>
<p>This gives some amount of named-parameter-ness for GPU API calls which is also a good way to reduce bugs :-)</p>
</li>
<li>
<p>As no &quot;library&quot; functions are called, the possibility to have ODR issues due to multiple function definitions is less likely, and can trivially be solved by wrapping the entirety of the user-provided code and command definitions in a custom namespace as the namespaces do not matter at all.</p>
</li>
</ol>
<h1 id="how-does-it-work-"><a class="header" href="#how-does-it-work-">How does it work ??</a></h1>
<p>It's very simple: the code which invokes <code>update()</code> more-or-less looks like this:</p>
<pre><code class="language-cpp">void invoke_update()
{
  if constexpr(requires { node.update(); })
  {
    for (auto&amp; promise : node.update())
    {
      promise.result = visit(update_handler{}, promise.command);
    }
  }
}
</code></pre>
<p>where <code>update_handler</code> looks like:</p>
<pre><code class="language-cpp">struct update_handler
{
  template&lt;typename C&gt;
  auto operator()(C command) {
    if constexpr(requires { C::allocation; })
    {
      if constexpr(requires { C::texture; })
        my_gpu_api_allocate_texture(command.width, command.height);
      else if constexpr(requires { C::ubo; })
        my_gpu_api_allocate_buffer(command.size);
      else ...
    }
    else ...
  }
};
</code></pre>
<p>One can check that given the amount of abstraction involved, the compiler can still generate <a href="https://gcc.godbolt.org/z/rcqT91d7f">reasonable amounts of code</a> for this (when provided with a decent std::variant implementation :p).</p>
<blockquote>
<p>Note that the implementation does not depend on the variant type being <code>std::variant</code> -- I also tested with <code>boost.variant2</code> and <code>mpark::variant</code> which follow the same concepts.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minimal-shaders"><a class="header" href="#minimal-shaders">Minimal shaders</a></h1>
<p>Sometimes only very simple fragment shaders are needed.</p>
<p>In this case, one can omit all the functions and most of the pipeline layout, 
and only define for instance an UBO, samplers and a fragment shader.</p>
<pre><code class="language-cpp">#pragma once
#include &lt;gpp/meta.hpp&gt;
#include &lt;gpp/ports.hpp&gt;
#include &lt;gpp/commands.hpp&gt;
#include &lt;gpp/layout.hpp&gt;

#include &lt;halp/controls.hpp&gt;

namespace examples
{
struct GpuSolidColorExample
{
  halp_meta(name, &quot;Solid color&quot;);
  halp_meta(uuid, &quot;c9a5fd8e-b66e-41ff-8feb-bca2cdab4990&quot;);

  struct layout {
    enum { graphics };

    // Here we only need a fragment output
    struct fragment_output {
      gpp_attribute(0, fragColor, float[4]) fragColor;
    } fragment_output;

    // We define one UBO with a vec4: our solid color
    struct bindings {
      struct custom_ubo {
        halp_meta(name, &quot;custom&quot;);
        halp_meta(binding, 0);
        halp_flags(std140, ubo);

        gpp::uniform&lt;&quot;color&quot;, float[4]&gt; col;
      } ubo;
    };
  };

  struct {
    // Make this uniform visible as a port
    gpp::uniform_control_port&lt;
        halp::color_chooser&lt;&quot;Color&quot;&gt;
      , &amp;layout::bindings::custom_ubo::col
    &gt; color;
  } inputs;

  struct {
    // Make an output port from the fragment output
    gpp::color_attachment_port&lt;&quot;Color output&quot;, &amp;layout::fragment_output&gt; out;
  } outputs;

  // Trivial fragment shader
  std::string_view fragment() {
    return R&quot;_(
void main() {
  fragColor = color;
}
)_&quot;;
  }
};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="draw-example"><a class="header" href="#draw-example">Draw example</a></h1>
<p>This example draw a triangle with two controls.</p>
<ul>
<li>One control is an uniform exposed directly to the object.</li>
<li>Another is a CPU-only control which the author of the node then maps to another uniform in a custom way.</li>
<li>The texture also comes from the node's code.</li>
</ul>
<pre><code class="language-cpp">#pragma once
#include &lt;halp/static_string.hpp&gt;
#include &lt;halp/controls.hpp&gt;
#include &lt;avnd/common/member_reflection.hpp&gt;

#include &lt;gpp/meta.hpp&gt;
#include &lt;gpp/ports.hpp&gt;
#include &lt;gpp/commands.hpp&gt;

#include &lt;cmath&gt;
namespace examples
{

struct GpuFilterExample
{
  halp_meta(name, &quot;Helpers GPU pipeline&quot;);
  halp_meta(uuid, &quot;ebe6f07a-5e7f-4cf8-bd2b-e5dc3e22a1f9&quot;);

  // Define the layout of our pipeline in C++ simply through the structure of a struct
  static constexpr struct layout
  {
    halp_flags(graphics);
    struct vertex_input {
      gpp_attribute(0, v_position, float[3], position) pos;
      gpp_attribute(1, v_texcoord, float[2], texcoord) tex;
    } vertex_input;

    struct vertex_output {
      gpp_attribute(0, texcoord,float[2], texcoord) tex;
      gpp::vertex_position_out position;
    } vertex_output;

    struct fragment_input {
      gpp_attribute(0, texcoord, float[2], texcoord) tex;
    } fragment_input;

    struct fragment_output {
      gpp_attribute(0, fragColor, float[4], color) col;
    } fragment_output;

    // Define the ubos, samplers, etc.
    struct bindings
    {
      struct custom_ubo {
        halp_meta(name, &quot;custom&quot;);
        halp_flags(std140, ubo);

        static constexpr int binding() { return 0; }

        gpp::uniform&lt;&quot;foo&quot;, float[2]&gt; pad;
        gpp::uniform&lt;&quot;bar&quot;, float&gt; slider;
      } ubo;

      gpp::sampler&lt;&quot;tex&quot;, 1&gt; texture_input;
    } bindings;
  } lay{};
  using bindings = decltype(layout::bindings);
  using uniforms = decltype(bindings::ubo);

  struct {
    // If samplers &amp; buffers are referenced here the GPU side of things
    // will be automatically allocated as they are expect to come from &quot;outside&quot;
    gpp::uniform_control_port&lt;halp::hslider_f32&lt;&quot;Alpha&quot;&gt;, &amp;uniforms::slider&gt; bright;

    // It's also possible to have purely CPU-side controls to manage e.g. texture sizes, etc...
    halp::hslider_f32&lt;&quot;Other&quot;&gt; other;
  } inputs;

  struct {
    gpp::color_attachment_port&lt;&quot;Main out&quot;, &amp;layout::fragment_output::col&gt; fragColor;
  } outputs;

  std::string_view vertex()
  {
    return R&quot;_(
void main()
{
  texcoord = v_texcoord;
  gl_Position = vec4(v_position.x / 3., v_position.y / 3, 0.0, 1.);
}
)_&quot;;
  }

  std::string_view fragment()
  {
    return R&quot;_(
void main()
{
  fragColor = vec4(texture(tex, texcoord.xy * foo).rgb, bar) ;
}
)_&quot;;
  }

  gpp::co_update update()
  {
    // In this example we test the automatic UBO filling with the inputs declared above.

    // Here the surrounding environment makes sure that the UBO already has a handle
    auto ubo = co_yield gpp::get_ubo_handle{
      .binding = lay.bindings.ubo.binding()
    };

    // Upload some data into it, using an input (non-uniform) of our node
    using namespace std;
    float xy[2] = {cos(inputs.other), sin(inputs.other)};

    co_yield gpp::dynamic_ubo_upload{
        .handle = ubo,
        .offset = 0,
        .size = sizeof(xy),
        .data = &amp;xy
    };

    // The sampler is not used by the inputs block, so we have to allocate it ourselves
    int sz = 16*16*4;
    if(!tex_handle)
    {
      this-&gt;tex_handle = co_yield gpp::texture_allocation{
          .binding = lay.bindings.texture_input.binding()
        , .width = 16
        , .height = 16
      };
    }

    // And upload some data
    tex.resize(sz);
    for(int i = 0; i &lt; sz; i++)
      tex[i] = rand();

    co_yield gpp::texture_upload{
        .handle = tex_handle
      , .offset = 0
      , .size = sz
      , .data = tex.data()
    };
  }

  gpp::co_release release()
  {
    if(tex_handle) {
      co_yield gpp::texture_release{.handle = tex_handle};
      tex_handle = nullptr;
    }
  }

private:
  std::vector&lt;uint8_t&gt; tex;
  gpp::texture_handle tex_handle{};
};

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compute-nodes"><a class="header" href="#compute-nodes">Compute nodes</a></h1>
<p>Compute is simpler than draw, as the pipeline only has one shader (the compute shader).
Instead of <code>draw</code>, the method in which to run compute dispatch calls is called <code>dispatch</code>.</p>
<p>Here is an example:</p>
<pre><code class="language-cpp">#pragma once
#include &lt;halp/static_string.hpp&gt;
#include &lt;halp/controls.hpp&gt;
#include &lt;avnd/common/member_reflection.hpp&gt;
#include &lt;fmt/format.h&gt;
#include &lt;fmt/printf.h&gt;

#include &lt;gpp/meta.hpp&gt;
#include &lt;gpp/ports.hpp&gt;
#include &lt;gpp/commands.hpp&gt;

namespace examples
{

struct GpuComputeExample
{
  // halp_meta is a short hand for defining a static function:
  // #define halp_meta(name, val) static constexpr auto name() return { val; }
  halp_meta(name, &quot;Compute pipeline&quot;);
  halp_meta(uuid, &quot;03bce361-a2ca-4959-95b4-6aac3b6c07b5&quot;);

  static constexpr int downscale = 16;

  // Define the layout of our pipeline in C++ simply through the structure of a struct
  struct layout
  {
    halp_meta(local_size_x, 16)
    halp_meta(local_size_y, 16)
    halp_meta(local_size_z, 1)
    halp_flags(compute);

    struct bindings
    {
      // Each binding is a struct member
      struct {
        halp_meta(name, &quot;my_buf&quot;);
        halp_meta(binding, 0);
        halp_flags(std140, buffer, load, store);

        using color = float[4];
        gpp::uniform&lt;&quot;result&quot;, color*&gt; values;
      } my_buf;

      // Define the members of our ubos
      struct custom_ubo {
        halp_meta(name, &quot;custom&quot;);
        halp_meta(binding, 1);
        halp_flags(std140, ubo);

        gpp::uniform&lt;&quot;width&quot;, int&gt; width;
        gpp::uniform&lt;&quot;height&quot;, int&gt; height;
      } ubo;

      struct  {
        halp_meta(name, &quot;img&quot;)
        halp_meta(format, &quot;rgba32f&quot;)
        halp_meta(binding, 2);
        halp_flags(image2D, readonly);
      } image;
    } bindings;
  };

  using bindings = decltype(layout::bindings);
  using uniforms = decltype(bindings::ubo);

  // Definition of our ports which will get parsed by the
  // software that instantiate this class
  struct {
      // Here we use some helper types in the usual fashion
      gpp::image_input_port&lt;&quot;Image&quot;, &amp;bindings::image&gt; tex;

      gpp::uniform_control_port&lt;
        halp::hslider_i32&lt;&quot;Width&quot;, halp::range{1, 1000, 100}&gt;
        , &amp;uniforms::width
      &gt; width;

      gpp::uniform_control_port&lt;
        halp::hslider_i32&lt;&quot;Height&quot;, halp::range{1, 1000, 100}&gt;
        , &amp;uniforms::height
      &gt; height;
  } inputs;

  // The output port on which we write the average color
  struct {
    struct {
      halp_meta(name, &quot;color&quot;)
      float value[4];
    } color_out;
  } outputs;

  std::string_view compute()
  {
    return R&quot;_(
void main()
{
  // Note: the algorithm is most likely wrong as I know FUCK ALL
  // about compute shaders ; fixes welcome ;p

  ivec2 call = ivec2(gl_GlobalInvocationID.xy);
  vec4 color = vec4(0,0,0,0);

  for(int i = 0; i &lt; gl_WorkGroupSize.x; i++)
  {
    for(int j = 0; j &lt; gl_WorkGroupSize.y; j++)
    {
      uint x = call.x * gl_WorkGroupSize.x + i;
      uint y = call.y * gl_WorkGroupSize.y + j;

      if (x &lt; width &amp;&amp; y &lt; height)
      {
        color += imageLoad(img, ivec2(x,y));
      }
    }
  }

  if(gl_LocalInvocationIndex &lt; ((width * height) / gl_WorkGroupSize.x * gl_WorkGroupSize.y))
  {
    result[gl_GlobalInvocationID.y * gl_WorkGroupSize.x + gl_GlobalInvocationID.x] = color;
  }
}
)_&quot;;
  }

  // Allocate and update buffers
  gpp::co_update update()
  {
    // Deallocate if the size changed
    const int w = this-&gt;inputs.width / downscale;
    const int h = this-&gt;inputs.height / downscale;
    if(last_w != w || last_h != h)
    {
      if(this-&gt;buf) {
        co_yield gpp::buffer_release{.handle = buf};
        buf = nullptr;
      }
      last_w = w;
      last_h = h;
    }

    if(w &gt; 0 &amp;&amp; h &gt; 0)
    {
      // No buffer: reallocate
      const int bytes = w * h * sizeof(float) * 4;
      if(!this-&gt;buf)
      {
        this-&gt;buf = co_yield gpp::static_allocation{
           .binding = lay.bindings.my_buf.binding()
         , .size = bytes
        };
      }
    }
  }

  // Relaease allocated data
  gpp::co_release release()
  {
    if(buf) {
      co_yield gpp::buffer_release{.handle = buf};
      buf = nullptr;
    }
  }

  // Do the GPU dispatch call
  gpp::co_dispatch dispatch()
  {
    if(!buf)
      co_return;

    const int w = this-&gt;inputs.width / downscale;
    const int h = this-&gt;inputs.height / downscale;
    const int bytes = w * h * sizeof(float) * 4;

    // Run a pass
    co_yield gpp::begin_compute_pass{};

    co_yield gpp::compute_dispatch{.x = 1, .y = 1, .z = 1};

    // Request an asynchronous readback
    gpp::buffer_awaiter readback = co_yield gpp::readback_buffer{
        .handle = buf
      , .offset = 0
      , .size = bytes
    };

    co_yield gpp::end_compute_pass{};

    // The readback can be fetched once the compute pass is done
    // (this needs to be improved in terms of asyncness)
    auto [data, size] = co_yield readback;

    using color = float[4];
    auto flt = reinterpret_cast&lt;const color*&gt;(data);

    // finish summing on the cpu
    auto&amp; final = outputs.color_out.value;
    std::ranges::fill(final, 0.f);

    for(int i = 0; i &lt; w * h; i++) {
      for(int j = 0; j &lt; 4; j++)
        final[j] += flt[i][j];
    }

    double pixels_total = this-&gt;inputs.width * this-&gt;inputs.height;
    final[0] /= pixels_total;
    final[1] /= pixels_total;
    final[2] /= pixels_total;
    final[3] /= pixels_total;
  }

private:
  static constexpr auto lay = layout{};
  int last_w{}, last_h{};
  gpp::buffer_handle buf{};
  std::vector&lt;float&gt; zeros{};
};

}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
