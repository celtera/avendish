<!DOCTYPE HTML>
<html lang="en" class="ayu sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Avendish documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "ayu";
            const default_dark_theme = "ayu";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Avendish documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="making-media-objects-with-avendish"><a class="header" href="#making-media-objects-with-avendish">Making media objects with <a href="https://github.com/celtera/avendish">Avendish</a></a></h1>
<p>This book is two things: a tutorial for the usage of <a href="https://github.com/celtera/avendish">Avendish</a>, intertwined with
an explanation of the concepts and implementation.</p>
<p>Avendish aims to enable media objects / processors authors to write the processor in the most natural way possible, and then to map this to host softwares or languages with so-called zero-cost abstraction.</p>
<blockquote>
<p>By zero-cost abstraction, we mean zero run-time cost. However, we'll see that the system actually enables extremely short compile times compared to the norm in C++.</p>
</blockquote>
<p>The library is borne from:</p>
<ul>
<li>
<p>The necessity to reduce duplication among media processors in C++.</p>
</li>
<li>
<p>Allowing to express the quintessence of a given media processor.</p>
<ul>
<li>There should be no compromise at any point: the user of the library must be able to declare all the properties, inputs, outputs of a media processor, whether it processes audio, video, MIDI, asynchronous messages, etc...</li>
<li>UIs must be possible.</li>
<li>GPU-based processors must be possible.</li>
<li>The way this is expressed should be the simplest possible way in C++, in the sense that the code should be as natural as possible: just declaring variables should be sufficient. The lack of proper reflection in C++ still limits this in a way, but we will see that it is already possible to get quite far !</li>
<li>For a given processor, multiple potential expressions are possible. We aim to capture most possible expressions: for instance, it may be more natural for a given audio processor to implement it in a sample-wise way (each audio sample processed one-by-one), and for another to be implemented through buffer-wise processing.</li>
</ul>
</li>
<li>
<p>The observation that the implementation of a media processor has no reason of depending on any kind of binding library: those are two entirely orthogonal concerns. Yet, due to how the language works, for the longest time writing such a processor necessarily embedded it inside some kind of run-time framework: JUCE, DPF, iPlug, etc. These frameworks are all great, but also all make compromises in terms of what is possible to express. Data types will be limited to a known list, UI will have to be written with a specific UI framework, etc. In contrast, Avendish processors are much more open ; processors can be written in their "canonic" form. The various bindings will then try to map as much as is possible to the environments they are bound to.</p>
</li>
</ul>
<p>In addition, such frameworks are generally not suitable for embedded platforms such as micro-controllers, etc. JUCE does not work on ESP32 :-)</p>
<p>In contrast, Avendish processors can be written in a way that does not depend on <em>any</em> existing library, not even the standard C or C++ libraries, which makes them trivially portable to such platforms. The only required thing is a C++ compiler, really!</p>
<p>Note that due to limited funding and time of the developer, not all backends support all features. In some cases this is because the backend has no way to implement the feature at all (for instance, a <code>string</code> output port in a VST plug-in), in other cases just because by lack of time, but it's on the roadmap! In general features are prototyped implemented in the <a href="https://ossia.io">ossia score</a> back-end first. Then they are migrated to the others back-end when the feature has proven useful and the API has been tested with a few different plug-ins and use-cases.</p>
<h1 id="why-c"><a class="header" href="#why-c">Why C++</a></h1>
<p>To ease porting of most effects, which are also in C++. Step by step, we will be able to lift them towards maybe higher-level descriptions, but first I believe that having something in C++ is important to allow capturing the semantics of the vast majority of media processors in existence.</p>
<p>Also because this is the language I know best =p</p>
<p>Non-C++ alternatives exist: <a href="https://faust.grame.fr/">Faust</a> and <a href="https://soul.dev/">SOUL</a> are the two most known and are great inspirations for Avendish ; they focus however mainly on audio processing. Avendish can be used to make purely message-based processors for e.g. Max/MSP and PureData, Python objects, etc. or video processing objects (currently implemented only for <a href="https://ossia.io">ossia score</a>, but could easily be ported to e.g. Jitter for Max, GEM for PureData, etc.).</p>
<h1 id="what-is-really-avendish"><a class="header" href="#what-is-really-avendish">What is really Avendish</a></h1>
<ol>
<li>An ontology for media objects.</li>
<li>An automated binding of a part of the C++ object semantics to other languages and run-time environments.</li>
<li>An example implementation of this until C++ gets proper reflection and code generation features.</li>
<li>Very, very, very, very uncompromising on its goals.</li>
<li>Lots of fun C++20 code !</li>
</ol>
<h1 id="gimme-code"><a class="header" href="#gimme-code">GIMME CODE</a></h1>
<p>Here's an example of a complete audio processor which uses an <strong>optional</strong> library of helper types:
if one wants, the exact same thing can be written without any macro or pre-existing type ; it is just a tad more verbose.</p>
<pre><code class="language-cpp">struct MyProcessor {
  // Define generic metadata
  halp_meta(name, "Gain");
  halp_meta(author, "Professional DSP Development, Ltd.");
  halp_meta(uuid, "3183d03e-9228-4d50-98e0-e7601dd16a2e");

  // Define the inputs of our processor
  struct ins {
    halp::dynamic_audio_bus&lt;"Input", double&gt; audio;
    halp::knob_f32&lt;"Gain", halp::range{.min = 0., .max = 1.}&gt; gain;
  } inputs;

  // Define the outputs of our processor
  struct outs {
    halp::dynamic_audio_bus&lt;"Output", double&gt; audio;
    halp::hbargraph_f32&lt;"Measure", halp::range{-1., 1., 0.}&gt; measure;
  } outputs;

  // Define an optional UI layout
  struct ui {
    using enum halp::colors;
    using enum halp::layouts;
    halp_meta(name, "Main")
    halp_meta(layout, hbox)
    halp_meta(background, mid)

    struct {
      halp_meta(name, "Widget")
      halp_meta(layout, vbox)
      halp_meta(background, dark)

      const char* label = "Hello !";
      halp::item&lt;&amp;ins::gain&gt; widget;
      const char* label2 = "Gain control!";
    } widgets;

    halp::spacing spc{.width = 20, .height = 20};

    halp::item&lt;&amp;outs::measure&gt; widget2;
  };

  // Our process function
  void operator()(int N) {
    auto&amp; in = inputs.audio;
    auto&amp; out = outputs.audio;
    const double gain = inputs.gain;

    double measure = 0.;
    for (int i = 0; i &lt; in.channels; i++)
    {
      for (int j = 0; j &lt; N; j++)
      {
        out[i][j] = gain * in[i][j];
        measure += std::abs(out[i][j]);
      }
    }

    if(N &gt; 0 &amp;&amp; in.channels &gt; 0)
      outputs.measure = measure / (N * in.channels);
  }
};
</code></pre>
<p>Here is how it looks like when compiled against the <a href="https://ossia.io">ossia score</a> backend:</p>
<p><img src="images/example.gif" alt="Gain example" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>Here is a minimal, self-contained definition of an Avendish processor:</p>
<pre><code class="language-cpp">import std;

[[name: "Hello World"]]
export struct MyProcessor
{
  void operator()() { 
    std::print("Henlo\n");
  }
};
</code></pre>
<p>... at least, in an alternative universe where C++ has gotten custom attributes and reflection on those,
and where modules and <code>std::print</code> work consistently across all compilers ; in our universe, this is still a few years away. Keep hope, dear reader, keep hope -- and read until the end of the page!</p>
<h1 id="getting-started-for-good"><a class="header" href="#getting-started-for-good">Getting started, for good</a></h1>
<p>Here is a minimal, self-contained definition of an Avendish processor, which works on 2022 compilers:</p>
<pre><code class="language-cpp">#pragma once
#include &lt;cstdio&gt;

struct MyProcessor
{
  static consteval auto name() { return "Hello World"; }

  void operator()() { 
    printf("Henlo\n");
  }
};
</code></pre>
<p>Yes, it's not much. You may even already have some in your codebase without even being aware of it !</p>
<p>Now, you may be used to the usual APIs for making audio plug-ins and start wondering about all the things you are used too and that are missing here:</p>
<ul>
<li>Inheritance or shelving function pointers in a C struct.</li>
<li>Libraries: defining an Avendish processor does not in itself require including anything.
A central point of the system is that everything can be defined through bare C++ constructs, without requiring the user to import types from a library. A library of helpers is nonetheless provided, to simplify some repetitive cases, but is in no way mandatory ; if anything, I encourage anyone to try to make different helper APIs that fit different coding styles.</li>
<li>Functions to process audio such as</li>
</ul>
<pre><code class="language-cpp">void process(double** inputs, double** outpus, int frames);
</code></pre>
<p>We'll see how all the usual amenities can be built on top of this and simple C++ constructs such as variables, methods and structures.</p>
<h2 id="line-by-line"><a class="header" href="#line-by-line">Line by line</a></h2>
<pre><code class="language-cpp">// This line is used to instruct the compiler to not include a header file multiple times.
#pragma once

// This line is used to allow our program to use `printf`:
#include &lt;cstdio&gt;

// This line declares a struct named MyProcessor. A struct can contain functions, variables, etc.
// It could also be a class - in C++, there is no strong semantic difference between either.
struct MyProcessor
{
  // This line declares a function that will return a visible name to show to our 
  // users.
  // - static is used so that an instance of MyProcessor is not needed: 
  //   we can just refer to the function as MyProcessor::name();
  // - consteval is used to enforce that the function can be called at compile-time, 
  //   which may enable optimizations in the backends that will generate plug-ins.
  // - auto because it does not matter much here, we know that this is a string :-)
  static consteval auto name() { return "Hello World"; }

  // This line declares a special function that will allow our processor to be executed as follows: 
  // 
  // MyProcessor the_processor;
  // the_processor();
  //
  // ^ the second line will call the "operator()" function.
  void operator()() 
  { 
    // This one should hopefully be obvious :-)
    printf("Henlo\n");
  }
};
</code></pre>
<h1 id="2025-update-its-happening"><a class="header" href="#2025-update-its-happening">2025 update: it's happening!</a></h1>
<p>C++ reflection and custom attributes / annotations will be part of C++26!
The actual syntax once support for it is implemented in Avendish, will certainly look like:</p>
<pre><code class="language-cpp">import std;
import metadata;

[[=metadata::name{"Hello World"}]]
[[=metadata::description{"An introductory example"}]]
export struct MyProcessor
{
  void operator()() { 
    std::print("Henlo\n");
  }
};
</code></pre>
<p>Thanks to the library's open-ended approach, all existing code will continue working :-)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiling-our-processor"><a class="header" href="#compiling-our-processor">Compiling our processor</a></h1>
<h2 id="environment-set-up"><a class="header" href="#environment-set-up">Environment set-up</a></h2>
<p>Before anything, we need a C++ compiler. The recommandation is to use Clang (at least clang-13). GCC 11 also works with some limitations. Visual Studio is sadly still not competent enough.</p>
<ul>
<li>On Windows, through <a href="https://github.com/mstorsjo/llvm-mingw/releases/tag/20220323">llvm-mingw</a>.</li>
<li>On Mac, through Xcode.</li>
<li>On Linux, through your distribution packages.</li>
</ul>
<p>Avendish's code is header-only ; however, CMake automatizes correctly linking to the relevant libraries, and generates a correct entrypoint for the targeted bindings, thus we recommend installing it.</p>
<p>Ninja is recommended: it makes the build faster. Below are a few useful set-up commands for various operating systems.</p>
<h4 id="archlinux-manjaro-etc"><a class="header" href="#archlinux-manjaro-etc">ArchLinux, Manjaro, etc</a></h4>
<pre><code>$ sudo pacman -S base-devel cmake ninja clang gcc boost
</code></pre>
<h4 id="debian-ubuntu-etc"><a class="header" href="#debian-ubuntu-etc">Debian, Ubuntu, etc</a></h4>
<pre><code>$ sudo apt install build-essential cmake ninja-build libboost-dev
</code></pre>
<h4 id="macos-with-homebrew"><a class="header" href="#macos-with-homebrew">macOS with Homebrew</a></h4>
<p>Xcode is required. Then:</p>
<pre><code>$ brew install cmake ninja boost
</code></pre>
<h4 id="windows-with-msys2--mingw"><a class="header" href="#windows-with-msys2--mingw">Windows with MSYS2 / MinGW</a></h4>
<pre><code>$ pacman -S pactoys
$ pacboy -S cmake:p ninja:p toolchain:p boost:p
</code></pre>
<h3 id="install-backend-specific-dependencies"><a class="header" href="#install-backend-specific-dependencies">Install backend-specific dependencies</a></h3>
<p>The APIs and SDK that you wish to create plug-ins / bindings for must also be available:</p>
<ul>
<li>PureData: needs the PureData API.
<ul>
<li><code>m_pd.h</code> and <code>pd.lib</code> must be findable through <code>CMAKE_PREFIX_PATH</code>.</li>
<li>On Linux this is automatic if you install PureData through your distribution.</li>
</ul>
</li>
<li>Max/MSP: needs the Max SDK.
<ul>
<li>Pass <code>-DAVND_MAXSDK_PATH=/path/to/max/sdk</code> to CMake.</li>
</ul>
</li>
<li>Python: needs pybind11.
<ul>
<li>Installable through most distro's repos.</li>
</ul>
</li>
<li>ossia: needs <a href="https://github.com/ossia/libossia">libossia</a>.</li>
<li>clap: needs <a href="https://github.com/free-audio/clap">clap</a>.</li>
<li>UIs can be built with Qt or <a href="https://github.com/Immediate-Mode-UI/Nuklear">Nuklear</a>.
<ul>
<li>Qt is installable easily through <a href="https://github.com/miurahr/aqtinstall">aqtinstall</a>.</li>
</ul>
</li>
<li>VST3: needs the Steinberg VST3 SDK.
<ul>
<li>Pass <code>-DVST3_SDK_ROOT=/path/to/vst3/sdk</code> to CMake.</li>
</ul>
</li>
<li>By default, plug-ins compatible with most DAWs through an obsolete, Vintage, almost vestigial, API will be built. This does not require any specific dependency to be installed, on the other hand it only supports audio plug-ins.</li>
</ul>
<h2 id="building-the-template"><a class="header" href="#building-the-template">Building the template</a></h2>
<p>The simplest way to get started is from the <a href="https://github.com/celtera/avendish-audio-processor-template/blob/main/CMakeLists.txt">template repository</a>: simply clear the <a href="https://github.com/celtera/avendish-audio-processor-template/blob/main/src/Processor.cpp">Processor.cpp</a> file for now and put the content in <a href="https://github.com/celtera/avendish-audio-processor-template/blob/main/src/Processor.hpp">Processor.hpp</a>.</p>
<p>Here's a complete example (from bash):</p>
<pre><code class="language-bash">$ git clone https://github.com/celtera/avendish-audio-processor-template
$ mkdir build
$ cd build
$ cmake ../avendish-audio-processor-template
$ ninja # or make -j8
</code></pre>
<p>This should produce various binaries in the build folder: for instance, a PureData object (in <code>build/pd</code>), a Python one (in <code>build/python</code>, etc.).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-the-template-in-python"><a class="header" href="#running-the-template-in-python">Running the template in Python</a></h1>
<p>Once the processor is built, we can for instance run it in Python:</p>
<p>Let's try to run our processor through the Python bindings:</p>
<pre><code class="language-bash">$ cd build/python

# Check that our processor was built correctly
$ ls
pymy_processor.so

# Run it
$ python
&gt;&gt;&gt; import pymy_processor
&gt;&gt;&gt; proc = pymy_processor.Hello_World()
&gt;&gt;&gt; proc.process()
Henlo
</code></pre>
<h1 id="running-the-template-in-puredata"><a class="header" href="#running-the-template-in-puredata">Running the template in PureData</a></h1>
<p>Similarly, one can run the template in PureData:</p>
<pre><code class="language-bash">$ cd build/pd

# Check that our processor was built correctly
$ ls
my_processor.l_ia64

# Run it
$ pd -lib my_processor
</code></pre>
<p>Make the following patch:</p>
<p><img src="getting_started/../images/getting_started/pd-hello-world.png" alt="Hello PureData" /></p>
<p>When sending a bang, the terminal in which PureData was launched should also print "Henlo".
We'll see in a later chapter how to print on Pd's own console instead.</p>
<h1 id="running-in-daws"><a class="header" href="#running-in-daws">Running in DAWs</a></h1>
<p>We could, but so far our object is not really an object that makes sense in a DAW: it does not process audio in any way. We'll see in further chapters how to make audio objects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-ports"><a class="header" href="#adding-ports">Adding ports</a></h1>
<blockquote>
<p>Supported bindings: all</p>
</blockquote>
<p>Our processor so far does not process much. It just reacts to an external trigger, to invoke a print function.</p>
<blockquote>
<p>Note that the way this trigger is invoked varies between environments: in Python, we called a <code>process()</code> function, while in PureData, we sent a bang to our object. That is one of the core philosophies of Avendish: bindings should make it so that the object fits as much as possible with the environment's semantics and idioms.</p>
</blockquote>
<p>Most actual media processing systems work with the concept of ports to declare inputs and outputs, and Avendish embraces this fully.</p>
<p>Here is the code of a simple processor, which computes the sum of two numbers.</p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return "Addition"; }

  struct
  {
    struct { float value; } a;
    struct { float value; } b;
  } inputs;

  struct
  {
    struct { float value; } out;
  } outputs;

  void operator()() { outputs.out.value = inputs.a.value + inputs.b.value; }
};
</code></pre>
<p>Compiling and running this yields for instance a PureData object which can be used like this:</p>
<p><img src="writing_processors/images/addition.png" alt="Addition" /></p>
<p>Note that the object respects the usual semantics of PureData: sending a message to the leftmost inlet will trigger the computation. Sending a message to the other inlets will store the value internally but won't trigger the actual computation.</p>
<p>For some objects, other semantics may make sense: creating an alternative binding to PureData which would implement another behaviour, such as triggering the computation only on "bang" messages, or on any input on any inlet, would be a relatively easy task.</p>
<p>Let's try in Python:</p>
<pre><code class="language-py">&gt;&gt;&gt; import pymy_processor
&gt;&gt;&gt; proc = pymy_processor.Addition()
&gt;&gt;&gt; proc.process()
&gt;&gt;&gt; p.input_0 = 123
&gt;&gt;&gt; p.input_1 = 456
&gt;&gt;&gt; p.process()
&gt;&gt;&gt; p.output_0
579.0
</code></pre>
<p>Here the semantics follow usual "object" ones. You set some state on the object and call methods on it, which may change this state.</p>
<blockquote>
<p>One could also make a binding that implements functional semantics, by passing the state of the processor as an immutable object instead. Python is already slow enough, though :p</p>
</blockquote>
<h2 id="syntax-explanation"><a class="header" href="#syntax-explanation">Syntax explanation</a></h2>
<p>Some readers may be surprised by the following syntax:</p>
<pre><code class="language-cpp">struct { float value; } a;
</code></pre>
<p>What it does is declare a variable <code>a</code> whose type is an <em>unnamed</em> structure.
Note that this is a distinct concept from <em>anonymous</em> structures:</p>
<pre><code class="language-cpp">struct { float value; };
</code></pre>
<p>which are legal in C but not in C++ (although most relevant compilers accept them), and are mostly useful for implementing unions:</p>
<pre><code class="language-cpp">union vec3 {
  struct { float x, y, z; };
  struct { float r, g, b; };
};

union vec3 v; 
v.x = 1.0; 
v.g = 2.0;
</code></pre>
<p>Motivation for using unnamed structures in Avendish is explained afterwards.</p>
<h2 id="naming-things"><a class="header" href="#naming-things">Naming things</a></h2>
<p>In an ideal world, what we would have loved is writing the following code:</p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return "Addition"; }

  struct
  {
    float a;
    float b;
  } inputs;

  struct
  {
    float out;
  } outputs;

  void operator()() { outputs.out = inputs.a + inputs.b; }
};
</code></pre>
<p>and have our Python processor expose us variables named <code>a</code>, <code>b</code> and <code>out</code>. Sadly, without reflection on names, this is not possible yet. Thus, in the meantime we use structs to embed metadata relative to the ports:</p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return "Addition"; }

  struct
  {
    struct { 
      static consteval auto name() { return "a"; } 
      float value; 
    } a;
    struct { 
      static consteval auto name() { return "b"; } 
      float value; 
    } b;
  } inputs;

  struct
  {
    struct { 
      static consteval auto name() { return "out"; } 
      float value; 
    } out;
  } outputs;

  void operator()() { outputs.out.value = inputs.a.value + inputs.b.value; }
};
</code></pre>
<p>Now our Python example is cleaner to use:</p>
<pre><code class="language-py">&gt;&gt;&gt; import pymy_processor
&gt;&gt;&gt; proc = pymy_processor.Addition()
&gt;&gt;&gt; proc.process()
&gt;&gt;&gt; p.a = 123
&gt;&gt;&gt; p.b = 456
&gt;&gt;&gt; p.process()
&gt;&gt;&gt; p.out
579.0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="refactoring"><a class="header" href="#refactoring">Refactoring</a></h1>
<p>One can see how writing:</p>
<pre><code class="language-cpp">struct { 
  static consteval auto name() { return "foobar"; } 
  float value; 
} foobar;
</code></pre>
<p>for 200 controls would get boring quick. In addition, the implementation of our processing function is not as clean as we'd want: in an ideal world, it would be just:</p>
<pre><code class="language-cpp">void operator()() { outputs.out = inputs.a + inputs.b; }
</code></pre>
<p>Thankfully, we can introduce our own custom abstractions without breaking anything: the only thing that matters is that they follow the "shape" of what a parameter is.</p>
<p>This shape is defined (as a first approximation) as follows:</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
concept parameter = requires (T t) { t.value = {}; };
</code></pre>
<p>In C++ parlance, this means that a type can be recognized as a parameter if</p>
<ul>
<li>It has a member called <code>value</code>.</li>
<li>This member is assignable with some default value.</li>
</ul>
<p>For instance:</p>
<pre><code class="language-cpp">struct bad_1 {
  const int value;
}; 

struct bad_2 {
  void value();
}; 

class bad_3 {
  int value;
}; 
</code></pre>
<p>are all invalid parameters.</p>
<p>This can be ensured easily by <a href="https://gcc.godbolt.org/z/c9Ko4ssM8">asking the compiler</a>:</p>
<pre><code class="language-cpp">static_assert(!parameter&lt;bad_1&gt;);
static_assert(!parameter&lt;bad_2&gt;);
static_assert(!parameter&lt;bad_3&gt;);
</code></pre>
<blockquote>
<p><code>static_assert</code> is a C++ feature which allows to check a predicate at compile-time. If the predicate is false, the compiler will report an error.</p>
</blockquote>
<p>Avendish will simply not recognize them and they won't be accessible anywhere.</p>
<p>Here are examples of valid parameters:</p>
<pre><code class="language-cpp">struct good_1 {
  int value;
}; 

struct good_2 {
  std::string value;
}; 

template&lt;typename T&gt;
struct assignable {
  T&amp; operator=(T x) { 
    printf("I changed !");
    this-&gt;v = x;
    return this-&gt;v;
  }
  T v;
};

class good_3 {
  public:
    assignable&lt;double&gt; value;
}; 
</code></pre>
<p>This can be ensured again by <a href="https://gcc.godbolt.org/z/P7aET4q3z">asking the compiler</a>:</p>
<pre><code class="language-cpp">static_assert(parameter&lt;good_1&gt;);
static_assert(parameter&lt;good_2&gt;);
static_assert(parameter&lt;good_3&gt;);
</code></pre>
<p>Avendish provides an helper library, <code>halp</code> (Helper Abstractions for Literate Programming), which match this pattern. However, users are encouraged to develop their own abstractions that fit their preferred coding style :-)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ports-with-the-helper-library"><a class="header" href="#ports-with-the-helper-library">Ports with the helper library</a></h1>
<p>Here is how our processor looks with the current set of helpers:</p>
<pre><code class="language-cpp">#pragma once
#include &lt;halp/controls.hpp&gt;

struct MyProcessor
{
  // halp_meta(A, B) expands to static consteval auto A() { return B; }
  halp_meta(name, "Addition")

  // In a perfect world one would just define attributes on the struct instead...
  //
  //   [[name: "Addition"]] 
  //   struct MyProcessor { ... };
  //
  // or more realistically, `static constexpr auto name = "foo";` 
  // which would be an acceptable compromise.

  struct
  {
    // val_port is a simple type which contains 
    // - a member value of type float
    // - the name() metadata method
    // - helper operators to allow easy assignment and use of the value.
    halp::val_port&lt;"a", float&gt; a;
    halp::val_port&lt;"b", float&gt; b;
  } inputs;

  struct
  {
    halp::val_port&lt;"out", float&gt; out;
  } outputs;

  void operator()() { outputs.out = inputs.a + inputs.b; }
};
</code></pre>
<p>If one really does not like templates, the following macro could be defined instead to make custom ports:</p>
<pre><code class="language-cpp">#define my_value_port(Name, Type)                  \
  struct {                                         \
    static consteval auto name() { return #Name; } \
    Type value;                                    \
  } Name;

// Used like:
my_value_port(a, float)
my_value_port(b, std::string)
... etc ...
</code></pre>
<p>Likewise if one day the <a href="https://github.com/cplusplus/papers/issues/403">metaclasses</a> proposal comes to pass, it will be possible to convert:</p>
<pre><code class="language-cpp">meta_struct
{
  float a;
  float b;
} inputs;
</code></pre>
<p>into a struct of the right shape, automatically, at compile-time, and all the current bindings will keep working.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="port-metadatas"><a class="header" href="#port-metadatas">Port metadatas</a></h1>
<p>Our ports so far are very simple: floating-point values, without any more information attached than a name to show to the user.</p>
<p>Most of the time, we'll want to attach some semantic metadata to the ports: for instance, a range of acceptable values, the kind of UI widget that should be shown to the user, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-a-minmax-range"><a class="header" href="#defining-a-minmax-range">Defining a min/max range</a></h1>
<blockquote>
<p>Supported bindings: all</p>
</blockquote>
<p>Here is how one can define a port with such a range:</p>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return "foobar"; } 

  struct range {
    float min = -1.;
    float max = 1.;
    float init = 0.5;
  };

  float value{};
} foobar;
</code></pre>
<p>Here is another version which will be picked up too:</p>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return "foobar"; } 
  static consteval auto range() {
    struct { 
      float min = -1.;
      float max = 1.;
      float init = 0.5;
    } r;
    return r;
  };

  float value{};
} foobar;
</code></pre>
<p>More generally, in most cases, Avendish will try to make sense of the things the author declares, whether they are types, variables or functions. This is not implemented entirely consistently yet, but it is a goal of the library in order to enable various coding styles and as much freedom of expression as possible for the media processor developer.</p>
<h2 id="keeping-metadata-static"><a class="header" href="#keeping-metadata-static">Keeping metadata static</a></h2>
<p>Note that we should still be careful in our struct definitions to not declare normal member variables for common metadata, which would take valuable memory and mess with our cache lines. This reduces performance for no good reason: imagine instantiating 10000 "processor" objects, you do not want each processor to carry the overhead of storing the range as a member variable, such as this:</p>
<pre><code class="language-cpp">struct {
  const char* name = "foobar";

  struct {
    float min = -1.;
    float max = 1.;
    float init = 0.5;
  } range;

  float value{};
} foobar;

// In this case:
static_assert(sizeof(foobar) == 4 * sizeof(float) + sizeof(const char*));
// sizeof(foobar) == 24 on 64-bit systems

// While in the previous cases, the "name" and "range" information is stored in a static space in the binary ; its cost is paid only once:
static_assert(sizeof(foobar) == sizeof(float));
// sizeof(foobar) == 4
</code></pre>
<h2 id="testing-on-a-processor"><a class="header" href="#testing-on-a-processor">Testing on a processor</a></h2>
<p>If we modify our example processor this way:</p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return "Addition"; }

  struct
  {
    struct { 
      static consteval auto name() { return "a"; } 
      struct range {
        float min = -10.;
        float max = 10.;
        float init = 0.;
      };
      float value; 
    } a;
    struct { 
      static consteval auto name() { return "b"; } 
      struct range {
        float min = -1.;
        float max = 1.;
        float init = 0.;
      };
      float value; 
    } b;
  } inputs;

  struct
  {
    struct { 
      static consteval auto name() { return "out"; } 
      float value; 
    } out;
  } outputs;

  void operator()() { outputs.out.value = inputs.a.value + inputs.b.value; }
};
</code></pre>
<p>then some backends will start to be able to do interesting things, like showing relevant UI widgets, or clamping the inputs / outputs.</p>
<p>This is not possible in all back-ends, sadly. Consider for instance PureData: the way one adds a port is by passing a pointer to a floating-point value to Pd, which will write directly the inbound value at the memory address: there is no point at which we could plug-in to perform clamping of the value.</p>
<p>Two alternatives would be possible in this case:</p>
<ul>
<li>Change the back-end to instead expect all messages on the first inlet, as those can be captured. This would certainly yield lower performance as one now would have to pass a symbol indicating the parameter so that the object knows to which port the input should map.</li>
<li>Implement an abstraction layer which would duplicate the parameters with their clamped version, and perform the clamping on all parameters whenever the process function gets called. This would however be hurtful in terms of performance and memory use.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-ui-widgets"><a class="header" href="#defining-ui-widgets">Defining UI widgets</a></h1>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p>Avendish can recognize a few names that will indicate that a widget of a certain type must be created.</p>
<p>For instance:</p>
<pre><code class="language-cpp">struct {
  enum { knob };
  static consteval auto name() { return "foobar"; } 

  struct range {
    float min = -1.;
    float max = 1.;
    float init = 0.5;
  };

  float value{};
} foobar;
</code></pre>
<p>Simply adding the enum definition in the struct will allow the bindings to detect it at compile-time, and instantiate an appropriate UI control.</p>
<p>The following widget names are currently recognized:</p>
<pre><code>bang, impulse
button, pushbutton
toggle, checkbox,
hslider, vslider, slider
spinbox,
knob,
lineedit,
choices, enumeration
combobox, list
xy, xy_spinbox,
xyz, xyz_spinbox,
color, 
time_chooser,
hbargraph, vbargraph, bargraph,
range_slider, range_spinbox
</code></pre>
<p>This kind of widget definition is here to enable host DAWs to automatically generate appropriate UIs automatically.</p>
<p>A further chapter will present how to create entirely custom painted UIs and widgets.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-a-mapping-function"><a class="header" href="#defining-a-mapping-function">Defining a mapping function</a></h1>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p>It is common in audio to have a range which is best manipulated by the user in logarithmic space,
for instance for adjusting frequencies, as the human hear is more sensitive to a 100Hz variation around 100Hz, than around 15kHz.</p>
<p>We can define custom mapping functions as part of the control, which will define
how the UI controls shall behave:</p>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return "foobar"; }

  struct mapper {
    static float map(float x) { return std::pow(x, 10.); }
    static float unmap(float y) { return std::pow(y, 1./10.); }
  };

  struct range {
    float min = 20.;
    float max = 20000.;
    float init = 100.;
  };

  float value{};
} foobar;
</code></pre>
<p>The mapping function must be a bijection of <code>[0; 1]</code> unto itself.</p>
<p>That is, the <code>map</code> and <code>unmap</code> function you choose must satisfy:</p>
<ul>
<li><code>for all x in [0; 1] map(x) is in [0; 1]</code></li>
<li><code>for all x in [0; 1] unmap(x) is in [0; 1]</code></li>
<li><code>for all x in [0; 1] unmap(map(x)) == x</code></li>
<li><code>for all x in [0; 1] map(unmap(x)) == x</code></li>
</ul>
<p>For instance, <code>sin(x)</code> or <code>ln(x)</code> do not work, but the <code>x^N</code> / <code>x^(1/N)</code> couple works.</p>
<p>Note that for now, mappings are only supported for floating-point sliders and knobs, in ossia.</p>
<h2 id="with-helpers"><a class="header" href="#with-helpers">With helpers</a></h2>
<p>A few pre-made mappings are provided: the above could be rewritten as:</p>
<pre><code class="language-cpp">struct : halp::hslider_f32&lt;"foobar", halp::range{20., 20000., 100.}&gt; {
  using mapper = halp::pow_mapper&lt;10&gt;;
} foobar;
</code></pre>
<p>The complete list is provided in <code>#include &lt;halp/mappers.hpp&gt;</code>:</p>
<pre><code class="language-cpp">// #include: &lt;halp/mappers.hpp&gt;

#pragma once

#include &lt;cmath&gt;
#include &lt;halp/modules.hpp&gt;

#include &lt;ratio&gt;

HALP_MODULE_EXPORT
namespace halp
{

// FIXME: when clang supports double arguments we can use them here instead
template &lt;typename Ratio&gt;
struct log_mapper
{
  // Formula from http://benholmes.co.uk/posts/2017/11/logarithmic-potentiometer-laws
  static constexpr double mid = double(Ratio::num) / double(Ratio::den);
  static constexpr double b = (1. / mid - 1.) * (1. / mid - 1.);
  static constexpr double a = 1. / (b - 1.);
  static double map(double v) noexcept { return a * (std::pow(b, v) - 1.); }
  static double unmap(double v) noexcept { return std::log(v / a + 1.) / std::log(b); }
};

template &lt;int Power&gt;
struct pow_mapper
{
  static double map(double v) noexcept { return std::pow(v, (double)Power); }
  static double unmap(double v) noexcept { return std::pow(v, 1. / Power); }
};

template &lt;typename T&gt;
struct inverse_mapper
{
  static double map(double v) noexcept { return T::unmap(v); }
  static double unmap(double v) noexcept { return T::map(v); }
};

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smoothing-values"><a class="header" href="#smoothing-values">Smoothing values</a></h1>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p>It is common to require controls to be smoothed over time, in order to prevent clicks and pops in the sound.</p>
<p>Avendish allows this, by defining a simple <code>smoother</code> struct which specifies over how many milliseconds the control changes must be smoothed.</p>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return "foobar"; }

  struct smoother {
    float milliseconds = 10.;
  };

  struct range {
    float min = 20.;
    float max = 20000.;
    float init = 100.;
  };

  float value{};
} foobar;
</code></pre>
<p>It is also possible to get precise control over the smoothing ratio, depending on the control update rate (sample rate or buffer rate).</p>
<h1 id="helpers"><a class="header" href="#helpers">Helpers</a></h1>
<p>Helper types are provided:</p>
<pre><code class="language-cpp">// #include: &lt;halp/smoothers.hpp&gt;

#pragma once

#include &lt;cmath&gt;
#include &lt;halp/modules.hpp&gt;

HALP_MODULE_EXPORT
namespace halp
{

// A basic smooth specification
template &lt;int T&gt;
struct milliseconds_smooth
{
  static constexpr float milliseconds{T};

  // Alternative:
  // static constexpr std::chrono::milliseconds duration{T};
};

// Same thing but explicit control over the smoothing
// ratio
template &lt;int T&gt;
struct exp_smooth
{
  static const constexpr double pi = 3.141592653589793238462643383279502884;
  static constexpr auto ratio(double sample_rate) noexcept
  {
    return std::exp(-2. * pi / (T * 1e-3 * sample_rate));
  }
};

}
</code></pre>
<h1 id="usage-example"><a class="header" href="#usage-example">Usage example</a></h1>
<p>These examples smooth the gain control parameter, either over a buffer in the first case, or for each sample in the second case.</p>
<pre><code class="language-cpp">#pragma once

/* SPDX-License-Identifier: GPL-3.0-or-later */

#include &lt;halp/audio.hpp&gt;
#include &lt;halp/controls.hpp&gt;
#include &lt;halp/meta.hpp&gt;
#include &lt;halp/smoothers.hpp&gt;

#include &lt;vector&gt;

namespace examples::helpers
{
/**
 * Smooth gain
 */
class SmoothGainPoly
{
public:
  halp_meta(name, "Smooth Gain")
  halp_meta(c_name, "avnd_helpers_smooth_gain")
  halp_meta(uuid, "032e1734-f84a-4eb2-9d14-01fc3dea4c14")

  using setup = halp::setup;
  using tick = halp::tick;

  struct
  {
    halp::dynamic_audio_bus&lt;"Input", double&gt; audio;
    struct : halp::hslider_f32&lt;"Gain", halp::range{.min = 0., .max = 1., .init = 0.5}&gt;
    {
      struct smoother
      {
        float milliseconds = 20.;
      };
    } gain;
  } inputs;

  struct
  {
    halp::dynamic_audio_bus&lt;"Output", double&gt; audio;
  } outputs;

  void prepare(halp::setup info) { }

  // Do our processing for N samples
  void operator()(halp::tick t)
  {
    // Process the input buffer
    for(int i = 0; i &lt; inputs.audio.channels; i++)
    {
      auto* in = inputs.audio[i];
      auto* out = outputs.audio[i];

      for(int j = 0; j &lt; t.frames; j++)
      {
        out[j] = inputs.gain * in[j];
      }
    }
  }
};

class SmoothGainPerSample
{
public:
  halp_meta(name, "Smooth Gain")
  halp_meta(c_name, "avnd_helpers_smooth_gain")
  halp_meta(uuid, "032e1734-f84a-4eb2-9d14-01fc3dea4c14")

  struct inputs
  {
    halp::audio_sample&lt;"Input", double&gt; audio;
    struct : halp::hslider_f32&lt;"Gain", halp::range{.min = 0., .max = 1., .init = 0.5}&gt;
    {
      using smooth = halp::milliseconds_smooth&lt;20&gt;;
    } gain;
  };

  struct outputs
  {
    halp::audio_sample&lt;"Output", double&gt; audio;
  };

  // Do our processing for N samples
  void operator()(const inputs&amp; inputs, outputs&amp; outputs)
  {
    outputs.audio.sample = inputs.audio.sample * inputs.gain;
  }
};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widget-helpers"><a class="header" href="#widget-helpers">Widget helpers</a></h1>
<blockquote>
<p>Supported bindings: depending on the underlying data type</p>
</blockquote>
<p>To simplify the common use case of defining a port such as "slider with a range", a set of common helper types is provided.</p>
<p>Here is our example, now as refined as it can be ; almost no character is superfluous or needlessly repeated except the names of controls:</p>
<pre><code class="language-cpp">#pragma once
#include &lt;halp/controls.hpp&gt;

struct MyProcessor
{
  halp_meta(name, "Addition")

  struct
  {
    halp::hslider_f32&lt;"a", halp::range{.min = -10, .max = 10, .init = 0}&gt; a;
    halp::knob_f32&lt;"b" , halp::range{.min = -1, .max = 1, .init = 0}&gt; b;
  } inputs;

  struct
  {
    halp::hbargraph_f32&lt;"out", halp::range{.min = -11, .max = 11, .init = 0}&gt; out;
  } outputs;

  void operator()() { outputs.out = inputs.a + inputs.b; }
};
</code></pre>
<p>This is how an environment such as <em>ossia score</em> renders it:</p>
<p><img src="writing_processors/images/addition-score.gif" alt="Addition" /></p>
<p>Note that even with our helper types, the following holds:</p>
<pre><code class="language-cpp">static_assert(sizeof(MyProcessor) == 3 * sizeof(float));
</code></pre>
<p>That is, an instance of our object weighs in memory exactly the size of its inputs and outputs, nothing else. In addition, the binding libraries try extremely hard to not allocate any memory dynamically, which leads to very concise memory representations of our media objects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="port-update-callback"><a class="header" href="#port-update-callback">Port update callback</a></h1>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p>It is possible to get a callback whenever the value of a (value) input port gets updated, to perform complex actions.
<code>update</code> will always be called before the current tick starts.</p>
<p>The port simply needs to have a <code>void update(T&amp;) { }</code> method implemented, where <code>T</code> will be the object containing the port:</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return "Addition"; }

  struct
  {
    struct { 
      static consteval auto name() { return "a"; } 
      void update(MyProcessor&amp; proc) { /* called when 'a.value' changes */ }

      float value; 
    } a;
    struct { 
      static consteval auto name() { return "b"; } 
      void update(MyProcessor&amp; proc) { /* called when 'b.value' changes */ }

      float value; 
    } b;
  } inputs;

  struct
  {
    struct { 
      static consteval auto name() { return "out"; } 
      float value; 
    } out;
  } outputs;

  void operator()() { outputs.out.value = inputs.a.value + inputs.b.value; }
};
</code></pre>
<h2 id="usage-with-helpers"><a class="header" href="#usage-with-helpers">Usage with helpers</a></h2>
<p>To add an update method to an helper, simply inherit from them:</p>
<pre><code class="language-cpp">#pragma once
#include &lt;halp/controls.hpp&gt;

struct MyProcessor
{
  halp_meta(name, "Addition")

  struct
  {
    struct : halp::val_port&lt;"a", float&gt; { 
      void update(MyProcessor&amp; proc) { /* called when 'a.value' changes */ }
    } a;

    halp::val_port&lt;"b", float&gt; b;
  } inputs;

  struct
  {
    halp::val_port&lt;"out", float&gt; out;
  } outputs;

  void operator()() { outputs.out = inputs.a + inputs.b; }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-audio-processors"><a class="header" href="#writing-audio-processors">Writing audio processors</a></h1>
<blockquote>
<p>Supported bindings: ossia, vst, vst3, clap, Max, Pd</p>
</blockquote>
<p>The processors we wrote until now only processed "control" values.</p>
<p>As a convention, those are values that change infrequently, relative to the audio rate: every few milliseconds, as opposed to every few dozen microseconds for individual audio samples.</p>
<h2 id="argument-based-processors"><a class="header" href="#argument-based-processors">Argument-based processors</a></h2>
<p>Let's see how one can write a simple audio filter in Avendish:</p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return "Distortion"; }

  float operator()(float input) 
  {
    return std::tanh(input); 
  }
};
</code></pre>
<p>That's it. That's the processor :-)</p>
<p>Maybe you are used to writing processors that operate with buffers of samples. Fear not, here is another valid Avendish audio processor, which should reassure most readers:</p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return "Distortion"; }
  static consteval auto input_channels() { return 2; }
  static consteval auto output_channels() { return 2; }

  void operator()(double** inputs, double** outputs, int frames)
  {
    for (int c = 0; c &lt; input_channels(); ++c)
    {
      for (int k = 0; k &lt; frames; k++)
      {
        outputs[c][k] = std::tanh(inputs[c][k]);
      }
    }
  }
};
</code></pre>
<p>The middle-ground of a processor that processes a single channel is also possible (and so is the possibility to use floats or doubles for the definition of the processor):</p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return "Distortion"; }

  void operator()(float* inputs, float* outputs, int frames)
  {
    for (int k = 0; k &lt; frames; k++)
    {
      outputs[k] = std::tanh(inputs[k]);
    }
  }
};
</code></pre>
<p>Those are all ways that enable quickly writing very simple effects (although a lot of ground is already covered).
For more advanced systems, with side-chains and such, it is preferable to use proper ports instead.</p>
<h2 id="port-based-processors"><a class="header" href="#port-based-processors">Port-based processors</a></h2>
<p>Here are three examples of valid audio ports:</p>
<ul>
<li>Sample-wise</li>
</ul>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return "In"; }
  float sample{};
};
</code></pre>
<ul>
<li>Channel-wise</li>
</ul>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return "Out"; }
  float* channel{};
};
</code></pre>
<ul>
<li>Bus-wise, with a fixed channel count. Here, bindings will ensure that there are always as many channels allocated.</li>
</ul>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return "Ins"; }
  static constexpr int channels() { return 2; }
  float** samples{}; // At some point this should be renamed bus...
};
</code></pre>
<ul>
<li>Bus-wise, with a modifiable channel count. Here, bindings will put exactly as many channels as the end-user of the software requested ; this count will be contained in <code>channels</code>.</li>
</ul>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return "Outs"; }
  int channels = 0;
  double** samples{}; // At some point this should be renamed bus...
};
</code></pre>
<blockquote>
<p>An astute reader may wonder why one could not fix a channel count by doing <code>const int channels = 2;</code> instead of <code>int channels() { return 2; };</code>. Sadly, this would make our types non-assignable, which makes things harder. It would also use bytes for each instance of the processor. A viable middle-ground could be <code>static constexpr int channels = 2;</code> but C++ does not allow static variables in unnamed types, thus this does not leave a lot of choice.</p>
</blockquote>
<h2 id="process-function-for-ports"><a class="header" href="#process-function-for-ports">Process function for ports</a></h2>
<p>For ports-based processor, the process function takes the number of frames as argument. Here is a complete, bare example of a gain processor.</p>
<pre><code class="language-cpp">struct Gain {
  static constexpr auto name() { return "Gain"; }
  struct {
    struct {
      static constexpr auto name() { return "Input"; }
      const double** samples;
      int channels;
    } audio;

    struct {
      static constexpr auto name() { return "Gain"; }
      struct range {
        const float min = 0.;
        const float max = 1.;
        const float init = 0.5;
      };

      float value;
    } gain;
  } inputs;

  struct {
    struct {
      static constexpr auto name() { return "Output"; }
      double** samples;
      int channels;
    } audio;
  } outputs;
  
  void operator()(int N) {
    auto&amp; in = inputs.audio.samples;
    auto&amp; out = outputs.audio.samples;

    for (int i = 0; i &lt; p1.channels; i++) 
      for (int j = 0; j &lt; N; j++) 
        out[i][j] = inputs.gain.value * in[i][j];
  }
};
</code></pre>
<h2 id="helpers-1"><a class="header" href="#helpers-1">Helpers</a></h2>
<p><code>halp</code> provides helper types for these common cases:</p>
<pre><code class="language-cpp">halp::audio_sample&lt;"A", double&gt; audio;
halp::audio_channel&lt;"B", double&gt; audio;
halp::fixed_audio_bus&lt;"C", double, 2&gt; audio;
halp::dynamic_audio_bus&lt;"D", double&gt; audio;
</code></pre>
<blockquote>
<p>Important: it is not possible to mix different types of audio ports in a single processor: audio sample and audio bus operate necessarily on different time-scales that are impossible to combine in a single function. Technically, it would be possible to combine audio channels and audio buses, but for the sake of simplicity this is currently forbidden.</p>
</blockquote>
<blockquote>
<p>Likewise, it is forbidden to mix float and double inputs for audio ports (as it simply does not make sense: no host in existence is able to provide audio in two different formats at the same time).</p>
</blockquote>
<h2 id="gain-processor-helpers-version"><a class="header" href="#gain-processor-helpers-version">Gain processor, helpers version</a></h2>
<p>The exact same example as above, just shorter to write :)</p>
<pre><code class="language-cpp">struct Gain {
  static constexpr auto name() { return "Gain"; }
  struct {
    halp::dynamic_audio_bus&lt;"Input", double&gt; audio;
    halp::hslider_f32&lt;"Gain", halp::range{0., 1., 0.5}&gt; gain;
  } inputs;

  struct {
    halp::dynamic_audio_bus&lt;"Output", double&gt; audio;
  } outputs;
  
  void operator()(int N) {
    auto&amp; in = inputs.audio;
    auto&amp; out = outputs.audio;
    const float gain = inputs.gain;

    for (int i = 0; i &lt; in.channels; i++) 
      for (int j = 0; j &lt; N; j++) 
        out[i][j] = gain * in[i][j];
  }
};
</code></pre>
<h2 id="further-work"><a class="header" href="#further-work">Further work</a></h2>
<p>We currently have the following matrix of possible forms of audio ports:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>1 channel</th><th>N channels</th></tr></thead><tbody>
<tr><td>1 frame</td><td><code>float sample;</code></td><td><code>???</code></td></tr>
<tr><td>N frames</td><td><code>float* channel;</code></td><td><code>float** samples;</code></td></tr>
</tbody></table>
</div>
<p>For the N channels / 1 frame case, one could imagine for instance:</p>
<pre><code class="language-cpp">struct {
  float bus[2]; // Fixed channels case
}
</code></pre>
<p>or</p>
<pre><code class="language-cpp">struct {
  float* bus; // Dynamic channels case
}
</code></pre>
<p>to indicate a per-sample, multi-channel bus, but this has not been implemented yet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monophonic-processors"><a class="header" href="#monophonic-processors">Monophonic processors</a></h1>
<blockquote>
<p>Supported bindings: ossia, vst, vst3, clap, Max</p>
</blockquote>
<p>There are three special cases:</p>
<ol>
<li>Processors with one sample input and one sample output.</li>
<li>Processors with one channel input and one channel output.</li>
<li>Processors with one dynamic bus input, one dynamic bus output, and no fixed channels being specified.</li>
</ol>
<p>In these three cases, the processor is recognized as polyphony-friendly. That means that in cases 1 and 2, the processor will be instantiated potentially multiple times automatically, if used in e.g. a stereo DAW.</p>
<p>In case 3, the channels of inputs and outputs will be set to the same count, which comes from the host.</p>
<h2 id="polyphonic-processors-should-use-types-for-their-io"><a class="header" href="#polyphonic-processors-should-use-types-for-their-io">Polyphonic processors should use types for their I/O</a></h2>
<p>Let's consider the following processor:</p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return "Distortion"; }
  struct {
    struct { float value; } gain;
  } inputs;

  double operator()(double input) 
  {
    accumulator = std::fmod(accumulator+1.f, 10.f);
    return std::tanh(inputs.gain.value * input + accumulator); 
  }
  
private:
  double accumulator{};
};
</code></pre>
<p>We have three different values involved:</p>
<ul>
<li><code>input</code> is the audio sample that is to be processed.</li>
<li><code>inputs.gain.value</code> is an external control which increases or decreases the distortion.</li>
<li><code>accumulator</code> is an internal variable used by the processing algorithm.</li>
</ul>
<p>Now consider this in the context of polyphony: the only thing that we can do is instantiate <code>MyProcessor</code> three times.</p>
<ul>
<li>We cannot call <code>operator()</code> of a single instance on multiple channels, as the internal state must stay independent of the channels.</li>
<li>But now the inputs are duplicated for all instances. If we want to implement a filter bank with thousands of duplicated processors in parallel, this would be a huge waste of memory if they all depend on the same <code>gain</code> value.</li>
</ul>
<p>Thus, it is recommended in this case to use the following form:</p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return "Distortion"; }
  struct inputs {
      struct { float value; } gain;
  };
  struct outputs { };

  double operator()(double input, const inputs&amp; ins, outputs&amp; outs) 
  {
    accumulator = std::fmod(accumulator+1.f, 10.f);
    return std::tanh(ins.gain.value * input + accumulator); 
  }

private:
  double accumulator{};
};
</code></pre>
<p>Here, Avendish will instantiate a single <code>inputs</code> array, which will be shared across all polyphony voices, which will likely use less memory and be more performant in case of large amount of parameters &amp; voices.</p>
<p>Here is what I would term the "canonic" of this version, with additionally our helpers to reduce typing, and the audio samples passed through ports instead of through arguments:</p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return "Distortion"; }
  struct inputs {
    halp::audio_sample&lt;"In", double&gt; audio;
    halp::hslider_f32&lt;"Gain", halp::range{.min = 0, .max = 100, .init = 1}&gt; gain;
  };
  struct outputs { 
    halp::audio_sample&lt;"Out", double&gt; audio;
  };

  void operator()(const inputs&amp; ins, outputs&amp; outs) 
  {
    accumulator = std::fmod(accumulator + 0.01f, 10.f);
    outs.audio = std::tanh(ins.gain * ins.audio + accumulator); 
  }

private:
  double accumulator{};
};
</code></pre>
<p>Passing inputs and outputs as types is also possible for all the other forms described previously - everything is possible, write your plug-ins as it suits you best :) and who knows, maybe with metaclasses one would also be able to generate the more efficient form directly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-setup"><a class="header" href="#audio-setup">Audio setup</a></h1>
<blockquote>
<p>Supported bindings: ossia, vst, vst3, clap, Max, Pd</p>
</blockquote>
<p>It is fairly common for audio systems to need to have some buffers allocated or perform pre-computations depending on the sample rate and buffer size of the system.</p>
<p>This can be done by adding the following method in the processor:</p>
<pre><code class="language-cpp">void prepare(/* some_type */ info) {
    ...
}
</code></pre>
<p><code>some_type</code> can be a custom type with the following allowed fields:</p>
<ul>
<li><code>rate</code>: will be filled with the sample rate.</li>
<li><code>frames</code>: will be filled with the maximum frame (buffer) size.</li>
<li><code>input_channels</code> / <code>output_channels</code>: for processors with unspecified numbers of channels, it will be notified here.</li>
<li>Alternatively, just specifying <code>channels</code> works too if inputs and outputs are expected to be the same.</li>
<li><code>instance</code>: allows to give processor instances an unique identifier which, if the host supports it, will be serialized / deserialized across restarts of the host and thus stay constant.</li>
</ul>
<p>Those variables must be assignable, and are all optional (remember the foreword: Avendish is <strong>UNCOMPROMISING</strong>).</p>
<p>Here are some valid examples:</p>
<ul>
<li>No member at all: this can be used to just notify the processor than processing is about to start.</li>
</ul>
<pre><code class="language-cpp">struct setup_a { };
void prepare(setup_a info) {
    ...
}
</code></pre>
<ul>
<li>Most common use case</li>
</ul>
<pre><code class="language-cpp">struct setup_b {
  float rate{};
  int frames{};
};
void prepare(setup_b info) {
    ...
}
</code></pre>
<ul>
<li>For variable channels in simple audio filters:</li>
</ul>
<pre><code class="language-cpp">struct setup_c {
  float rate{};
  int frames{};
  int channels{};
};
void prepare(setup_c info) {
    ...
}
</code></pre>
<h2 id="helper-library"><a class="header" href="#helper-library">Helper library</a></h2>
<p><code>halp</code> provides the <code>halp::setup</code> which covers the most usual use cases:</p>
<pre><code class="language-cpp">void prepare(halp::setup info) {
  info.rate; // etc...
}
</code></pre>
<h1 id="how-does-this-work-"><a class="header" href="#how-does-this-work-">How does this work ?</a></h1>
<p>If you are interested in the implementation, it is actually fairly simple.</p>
<ul>
<li>First we extract the function arguments of <code>prepare</code> if the function exists (see <code>avnd/common/function_reflection.hpp</code> for the method), to get the type <code>T</code> of the first argument.</li>
<li>Then we do the following if it exists:</li>
</ul>
<pre><code class="language-cpp">using type = /* type of T in prepare(T t) */;
if constexpr(requires (T t) { t.frames = 123; })
  t.frames = ... the buffer size reported by the DAW ...;
if constexpr(requires (T t) { t.rate = 44100; })
  t.rate = ... the sample-rate reported by the DAW ...;
</code></pre>
<p>This way, only the cost of the variables that are actually used by the algorithm is ever incurred, which is of course not super important but a good reference implementation for this way of doing for other parts of the system where it matters more.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-arguments"><a class="header" href="#audio-arguments">Audio arguments</a></h1>
<blockquote>
<p>Supported bindings: ossia, vst, vst3, clap, Max, Pd</p>
</blockquote>
<p>In addition of the global set-up step, one may require per-process-step arguments.
Most common needs are for instance the current tempo, etc.</p>
<p>The infrastructure put in place for this is very similar to the one previously mentioned for
the setup step.</p>
<p>The way it is done is simply by passing it as the last argument of the processing <code>operator()</code> function.</p>
<p>If there is such a type, it will contain at least the frames.</p>
<blockquote>
<p>Note: due to a lazy developer, currently this type has to be called <code>tick</code>.</p>
</blockquote>
<p>Example:</p>
<pre><code class="language-cpp">struct MyProcessor {
  ...

  struct tick {
    int frames;
    double tempo;
  };

  void operator()(tick tick) { ... }
  float operator()(float in, tick tick) { ... }
  void operator()(float* in, float* out, tick tick) { ... }
  void operator()(float** in, float** out, tick tick) { ... }

  // And also the versions that take input and output types as arguments
  void operator()(const inputs&amp; in, outputs&amp; out, tick tick) { ... }
  float operator()(float in, const inputs&amp; in, outputs&amp; out, tick tick) { ... }
  void operator()(float* in, float* out, const inputs&amp; in, outputs&amp; out, tick tick) { ... }
  void operator()(float** in, float** out, const inputs&amp; in, outputs&amp; out, tick tick) { ... }

  // And also the double-taking versions, not duplicated here :-)
};
</code></pre>
<p>The currently supported members are:</p>
<ul>
<li><code>frames</code>: the buffer size</li>
</ul>
<p>The plan is to introduce:</p>
<ul>
<li><code>tempo</code> and all things relative to musicality, e.g. current bar, etc.
<ul>
<li>But first we have to define it in a proper way, which is compatible with VST, CLAP, etc.</li>
</ul>
</li>
<li><code>time_since_start</code></li>
<li>and other similar timing-related things which will all be able to be opt-in.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-fft"><a class="header" href="#audio-fft">Audio FFT</a></h1>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p>It is pretty common for audio analysis tasks to need access to the audio spectrum.</p>
<p>However, this causes a dramatic situation at the ecosystem level: every plug-in ships with its own FFT
implementation, which at best duplicates code for no good reason, and at worse may cause complex
issues for FFT libraries which rely on global state shared across the process, such as FFTW.</p>
<p>With the declarative approach of Avendish, however, we can make it so that the plug-in does not
directly depend on an FFT implementation: it just requests that a port gets its spectrum computed, and it happens
automatically outside of the plug-in's code. This allows hosts such as <a href="https://ossia.io">ossia score</a> to provide
their own FFT implementation which will be shared across all Avendish plug-ins, which is strictly better for performance
and memory usage.</p>
<h2 id="making-an-fft-port"><a class="header" href="#making-an-fft-port">Making an FFT port</a></h2>
<p>This can be done by extending an audio input port (channel or bus) with a <code>spectrum</code> member.</p>
<p>For instance, given:</p>
<pre><code class="language-cpp">struct {
  float** samples{};
  int channels{};
} my_audio_input;
</code></pre>
<p>One can add the following <code>spectrum</code> struct:</p>
<pre><code class="language-cpp">struct {
  float** samples{};

  struct {
    float** amplitude{};
    float** phase{};
  } spectrum;

  int channels{};
} my_audio_input;
</code></pre>
<p>to get a deinterleaved view of the amplitude &amp; phase:</p>
<pre><code class="language-cpp">spectrum.amplitude[0][4]; // The amplitude of the bin at index 4 for channel 0
spectrum.phase[1][2]; // The phase of the bin at index 2 for channel 1
</code></pre>
<p>It is also possible to use complex numbers instead:</p>
<pre><code class="language-cpp">struct {
  double** samples{};

  struct {
    std::complex&lt;double&gt;** bins;
  } spectrum;

  int channels{};
} my_audio_input;
</code></pre>
<pre><code class="language-cpp">spectrum.bins[0][4]; // The complex value of the bin at index 4 for channel 0
</code></pre>
<p>Using complex numbers allows to use the C++ standard math library functions for complex numbers: <code>std::norm</code>, <code>std::proj</code>...</p>
<p>Note that the length of the spectrum arrays is always <code>N / 2 + 1</code>, N being the current frame size. Note also that the FFT is normalized - the input is divided by the amount of samples.</p>
<blockquote>
<p>WIP: an important upcoming feature is the ability to make configurable buffered processors, so that
one can choose for instance to observe the spectrum over 1024 frames. Right now this has to be handled internally by the plug-in.</p>
</blockquote>
<h3 id="windowing"><a class="header" href="#windowing">Windowing</a></h3>
<p>A window function can be applied by defining an</p>
<pre><code class="language-cpp">enum window { &lt;name of the window&gt; };
</code></pre>
<p>Supported names currently are <code>hanning</code>, <code>hamming</code>. If there is none, there will be no windowing (technically, a rectangular window). The helper types described below use an Hanning window.</p>
<blockquote>
<p>WIP: process with the correct overlap for the window size, e.g. 0.5 for Hanning, 0.67 for Hamming etc. once buffering is implemented.</p>
</blockquote>
<h2 id="helper-types"><a class="header" href="#helper-types">Helper types</a></h2>
<p>These three types are provided. They give separated amplitude / phase arrays.</p>
<pre><code class="language-cpp">halp::dynamic_audio_spectrum_bus&lt;"A", double&gt; a_bus_port;
halp::fixed_audio_spectrum_bus&lt;"B", double, 2&gt; a_stereo_port;
halp::audio_spectrum_channel&lt;"C", double&gt; a_channel_port;
</code></pre>
<h2 id="accessing-a-fft-object-globally"><a class="header" href="#accessing-a-fft-object-globally">Accessing a FFT object globally</a></h2>
<p>See <a href="writing_processors/../advanced/fft.html">the section about feature injection</a> to see how a plug-in can be injected with an FFT object which allows to control precisely how the FFT is done.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<pre><code class="language-cpp">#pragma once
#include &lt;cmath&gt;
#include &lt;halp/audio.hpp&gt;
#include &lt;halp/controls.hpp&gt;
#include &lt;halp/fft.hpp&gt;
#include &lt;halp/meta.hpp&gt;

namespace examples::helpers
{

/**
 * For the usual case where we just want the spectrum of an input buffer,
 * no need to template: we can ask it to be precomputed beforehand by the host.
 */
struct PeakBandFFTPort
{
  halp_meta(name, "Peak band (FFT port)")
  halp_meta(c_name, "avnd_peak_band_fft_port")
  halp_meta(uuid, "143f5cb8-d0b1-44de-a1a4-ccd5315192fa")

  // TODO implement user-controllable buffering to allow various fft sizes...
  int buffer_size = 1024;

  struct
  {
    // Here the host will fill audio.spectrum with a windowed FFT.
    // Option A (an helper type is provided)
    halp::audio_spectrum_channel&lt;"In", double&gt; audio;

    // Option B with the raw spectrum ; no window is defined.
    struct
    {
      halp_meta(name, "In 2");

      double* channel{};
      // complex numbers... using value_type = double[2] is also ok
      struct
      {
        std::complex&lt;double&gt;* bin;
      } spectrum{};
    } audio_2;
  } inputs;

  struct
  {
    halp::val_port&lt;"Peak", double&gt; peak;
    halp::val_port&lt;"Band", int&gt; band;

    halp::val_port&lt;"Peak 2", double&gt; peak_2;
    halp::val_port&lt;"Band 2", int&gt; band_2;
  } outputs;

  void operator()(int frames)
  {
    // Process with option A
    {
      outputs.peak = 0.;

      // Compute the band with the highest amplitude
      for(int k = 0; k &lt; frames / 2; k++)
      {
        const double ampl = inputs.audio.spectrum.amplitude[k];
        const double phas = inputs.audio.spectrum.phase[k];
        const double mag_squared = ampl * ampl + phas * phas;

        if(mag_squared &gt; outputs.peak)
        {
          outputs.peak = mag_squared;
          outputs.band = k;
        }
      }

      outputs.peak = std::sqrt(outputs.peak);
    }

    // Process with option B
    {
      outputs.peak_2 = 0.;

      // Compute the band with the highest amplitude
      for(int k = 0; k &lt; frames / 2; k++)
      {
        const double mag_squared = std::norm(inputs.audio_2.spectrum.bin[k]);

        if(mag_squared &gt; outputs.peak_2)
        {
          outputs.peak_2 = mag_squared;
          outputs.band_2 = k;
        }
      }

      outputs.peak_2 = std::sqrt(outputs.peak_2);
    }
  }
};

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="messages"><a class="header" href="#messages">Messages</a></h1>
<blockquote>
<p>Supported bindings: ossia, Max, Pd, Python</p>
</blockquote>
<p>So far, we already have something which allows to express a great deal of audio plug-ins, as well as many objects that do not operate in a manner synchronized to a constant sound input, but also in a more asynchronous way, and with things more complicated than single <code>float</code>, <code>int</code> or <code>string</code> values.</p>
<p>A snippet of code is worth ten thousand words: here is how one defines a message input.</p>
<pre><code class="language-cpp">struct MyProcessor {
  struct messages {
    struct {
      static consteval auto name() { return "dump"; }
      void operator()(MyProcessor&amp; p, double arg1, std::string_view arg2) {
        std::cout &lt;&lt; arg1 &lt;&lt; ";" &lt;&lt; arg2 &lt;&lt; "\n";
      }
    } my_message;
  };
};
</code></pre>
<p>Note that the <code>messages</code> are stored in a structure named <code>messages</code>. It could also be the name of the value, but this would likely use at least a few bytes per instance which would be wasted as messages are not supposed to have states themselves.</p>
<p>Messages are of course only meaningful in environments which support them.
One argument messages are equivalent to parameters.
If there is more than one argument, not all host systems may be able to handle them ; for instance, it does not make much sense for VST3 plug-ins. On the other hand, programming language bindings or systems such as Max and PureData have no problem with them.</p>
<h2 id="passing-existing-functions"><a class="header" href="#passing-existing-functions">Passing existing functions</a></h2>
<p>The following syntaxes are also possible:</p>
<pre><code class="language-cpp">void free_function() { printf("Free function\n"); }

struct MyProcessor {
  void my_member(int x);

  struct messages {
    // Using a pointer-to-member function
    struct {
      static consteval auto name() { return "member"; }
      static consteval auto func() { return &amp;MyProcessor::my_member; }
    } member;

    // Using a lambda-function
    struct
    {
      static consteval auto name() { return "lambda_function"; }
      static consteval auto func() {
        return [] { printf("lambda\n"); };
      }
    } lambda;

    // Using a free function
    struct
    {
      static consteval auto name() { return "function"; }
      static consteval auto func() { return free_function; }
    } freefunc;
  };
};
</code></pre>
<p>In every case, if one wants access to the processor object, it has to be the first argument of the function (except the non-static-member-function case where it is not necessary as the function already has access to the <code>this</code> pointer by definition).</p>
<h2 id="type-checking"><a class="header" href="#type-checking">Type-checking</a></h2>
<p>Messages are type-checked: in the first example above, for instance, PureData will return an error for the message <code>[dump foo bar&gt;</code>. For the message <code>[dump 0.1 bar&gt;</code> things will however work out just fine :-)</p>
<h2 id="arbitrary-inputs"><a class="header" href="#arbitrary-inputs">Arbitrary inputs</a></h2>
<p>It may be necessary to have messages that accept an arbitrary number of inputs.
Here is how:</p>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return "args"; }
  void operator()(MyProcessor&amp; p, std::ranges::input_range auto range) {
    for(const std::variant&amp; argument : range) {
      // Print the argument whatever the content
      // (a library such as fmt can do that directly)
      std::visit([](auto&amp; e) { std::cout &lt;&lt; e &lt;&lt; "\n"; }, argument);

      // Try to do something useful with it - here the types depend on what the binding give us. So far only Max and Pd support that so the only possible types are floats, doubles and std::string_view
      if(std::get_if&lt;double&gt;(argument)) { ... }
      else if(std::get_if&lt;std::string_view&gt;(argument)) { ... }
      // ... etc
    }
  }
} my_variadic_message;
</code></pre>
<h1 id="overloading"><a class="header" href="#overloading">Overloading</a></h1>
<p>Overloading is not supported yet, but there are plans for it.</p>
<h1 id="how-does-the-above-code-work-"><a class="header" href="#how-does-the-above-code-work-">How does the above code work ?</a></h1>
<p>I think that this case is pretty nice and a good example of how C++ can greatly improve type safety over C APIs: a common problem for instance with Max or Pd is accessing the incorrect member of an union when iterating the arguments to a message.</p>
<p>Avendish has the following method, which transforms a Max or Pd argument list, into an iterable coroutine-based range of <code>std::variant</code>.</p>
<pre><code class="language-cpp">using atom_iterator = avnd::generator&lt;std::variant&lt;double, std::string_view&gt;&gt;;
inline atom_iterator make_atom_iterator(int argc, t_atom* argv)
{
  for (int i = 0; i &lt; argc; ++i) {
    switch (argv[i].a_type) {
      case A_FLOAT: {
        co_yield argv[i].a_w.w_float;
        break;
      }
      case A_SYM: {
        co_yield std::string_view{argv[i].a_w.w_sym-&gt;s_name};
        break;
      }
      default:
        break;
    }
  }
}
</code></pre>
<p>Here, <code>atom_iterator</code> is what gets passed to <code>my_variadic_message</code>. It allows to deport the iteration of the loop over the arguments into the calling code, but handles the matching from type to union member in a generic way and transforms them into safer <code>std::variant</code> instances on-the-fly, which removes an entire class of possible errors while not costing much : in my experiments for instance, the compiler is able to elide entirely any form of dynamic memory allocation which would normally be required there.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="callbacks"><a class="header" href="#callbacks">Callbacks</a></h1>
<blockquote>
<p>Supported bindings: ossia, Max, Pd, Python</p>
</blockquote>
<p>Just like messages allow to define functions that will be called from an outside request, it is also possible to define callbacks: functions that our processor will call, and which will be sent to the outside world.</p>
<p>Just like for messages, this does not really make sense for instance for audio processors ; however it is pretty much necessary to make useful Max or Pd objects.</p>
<p>Callbacks are defined as part of the <code>outputs</code> struct.</p>
<h2 id="defining-a-callback-with-stdfunction"><a class="header" href="#defining-a-callback-with-stdfunction">Defining a callback with std::function</a></h2>
<p>This is a first possibility, which is pretty simple:</p>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return "bong"; }
  std::function&lt;void(float)&gt; call;
}; 
</code></pre>
<p>The bindings will make sure that a function is present in <code>call</code>, so that our code can call it:</p>
<pre><code class="language-cpp">struct MyProcessor {
  static consteval auto name() { return "Distortion"; }

  struct {
    struct {
      static consteval auto name() { return "overload"; }
      std::function&lt;void(float)&gt; call;
    } overload; 
  } outputs;

  float operator()(float input) 
  {
    if(input &gt; 1.0)
      outputs.overload.call(input);

    return std::tanh(input); 
  }
};
</code></pre>
<p>However, we also want to be able to live without std:: types ; in particular, std::function is a quite complex beast which does type-erasure, potential dynamic memory allocations, and may not be available on all platforms.</p>
<p>Thus, it is also possible to define callbacks with a simple pair of function-pointer &amp; context:</p>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return "overload"; }
  struct {       
    void (*function)(void*, float);
    void* context;
  } call;
} overload;
</code></pre>
<p>The bindings will fill the function and function pointer, so that one can call them:</p>
<pre><code class="language-cpp">float operator()(float input) 
{
  if(input &gt; 1.0)
  {
    auto&amp; call = outputs.overload.call;
    call.function(call.context, input);
  }
  return std::tanh(input); 
}
</code></pre>
<p>Of course, this is fairly verbose: thankfully, helpers are provided to make this as simple as <code>std::function</code> but without the overhead (until <code>std::function_view</code> gets implemented):</p>
<pre><code class="language-cpp">struct {
  static consteval auto name() { return "overload"; }
  halp::basic_callback&lt;void(float)&gt; call;
} overload;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initialization"><a class="header" href="#initialization">Initialization</a></h1>
<blockquote>
<p>Supported bindings: Max, Pd</p>
</blockquote>
<p>Some media systems provide a way for objects to be passed initialization arguments.</p>
<p>Avendish supports this with a special "initialize" method. Ultimately, I'd like to be able to simply use C++ constructors for this, but haven't managed to yet.</p>
<p>Here's an example:</p>
<pre><code class="language-cpp">struct MyProcessor {
void initialize(float a, std::string_view b)
{
  std::cout &lt;&lt; a &lt;&lt; " ; " &lt;&lt; b &lt;&lt; std::endl;
}
...
};
</code></pre>
<p>Max and Pd will report an error if the object is not initialized correctly, e.g. like this:</p>
<pre><code>[my_processor 1.0 foo]  // OK
[my_processor foo 1.0]  // Not OK
[my_processor] // Not OK
[my_processor 0 0 0 1 2 3] // Not OK
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="midi-io"><a class="header" href="#midi-io">MIDI I/O</a></h1>
<blockquote>
<p>Supported bindings: ossia, vst, vst3, clap</p>
</blockquote>
<p>Some media systems may have a concept of MIDI input / output. Note that currently this is only implemented for DAW-ish bindings: ossia, VST3, CLAP... Max and Pd do not support it yet (but if there is a standard for passing MIDI messages between objects there I'd love to hear about it !).</p>
<p>There are a few ways to specify MIDI ports.</p>
<p>Here is how one specifies unsafe MIDI ports:</p>
<pre><code class="language-cpp">struct
{
  static consteval auto name() { return "MIDI"; }
  struct
  {
    uint8_t bytes[3]{};
    int timestamp{}; // relative to the beginning of the tick
  }* midi_messages{};
  std::size_t size{};
} midi_port;
</code></pre>
<p>Or, more clearly:</p>
<pre><code class="language-cpp">// the name does not matter
struct midi_message {
  uint8_t bytes[3]{};
  int timestamp{}; // relative to the beginning of the tick
};

struct
{
  static consteval auto name() { return "MIDI"; }
  midi_message* midi_messages{};
  std::size_t size{};
} midi_port;
</code></pre>
<p>Here, Avendish bindings will allocate a large enough buffer to store MIDI messages ; this is mainly to enable writing dynamic-allocation-free backends where such a buffer may be allocated statically.</p>
<p>It is also possible to do this if you don't expect to run your code on Arduinos:</p>
<pre><code class="language-cpp">struct
{
  // Using a non-fixed size type here will enable MIDI messages &gt; 3 bytes, if for instance your 
  // processor expects to handle SYSEX messages.
  struct msg {
    std::vector&lt;uint8_t&gt; bytes;
    int64_t timestamp{};
  };

  std::vector&lt;msg&gt; midi_messages;
} midi_port;
</code></pre>
<h2 id="helpers-2"><a class="header" href="#helpers-2">Helpers</a></h2>
<p>The library provides helper types which are a good compromise between these two solutions, as they are based on <code>boost::container::small_vector</code>: for small numbers of MIDI messages, there will be no memory allocation, but pathological cases (an host sending a thousand MIDI messages in a single tick) can still be handled without loosing messages.</p>
<p>The type is very simple:</p>
<pre><code class="language-cpp">halp::midi_bus&lt;"In"&gt; midi;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="midi-synth-example"><a class="header" href="#midi-synth-example">MIDI synth example</a></h1>
<p>This example is a very simple synthesizer. Note that for the sake of simplicity for the implementer, we use two additional libraries:</p>
<ul>
<li><a href="https://github.com/jcelerier/libremidi"><code>libremidi</code></a> provides an useful <code>enum</code> of common MIDI messages types.</li>
<li><a href="https://github.com/ossia/libossia"><code>libossia</code></a> provides frequency &lt;-&gt; MIDI note and gain &lt;-&gt; MIDI velocity conversion operations.</li>
</ul>
<pre><code class="language-cpp">#pragma once
#include &lt;halp/audio.hpp&gt;
#include &lt;halp/controls.hpp&gt;
#include &lt;halp/meta.hpp&gt;
#include &lt;halp/midi.hpp&gt;
#include &lt;halp/sample_accurate_controls.hpp&gt;
#include &lt;libremidi/message.hpp&gt;
#include &lt;ossia/network/dataspace/gain.hpp&gt;
#include &lt;ossia/network/dataspace/time.hpp&gt;
#include &lt;ossia/network/dataspace/value_with_unit.hpp&gt;

namespace examples
{
/**
 * This example exhibits a simple, monophonic synthesizer.
 * It relies on some libossia niceties.
 */
struct Synth
{
  halp_meta(name, "My example synth");
  halp_meta(c_name, "synth_123");
  halp_meta(category, "Demo");
  halp_meta(author, "Jean-Michaël Celerier");
  halp_meta(description, "A demo synth");
  halp_meta(uuid, "93eb0f78-3d97-4273-8a11-3df5714d66dc");

  struct
  {
    /** MIDI input: simply a list of timestamped messages.
     * Timestamp are in samples, 0 is the first sample.
     */
    halp::midi_bus&lt;"In"&gt; midi;
  } inputs;

  struct
  {
    halp::fixed_audio_bus&lt;"Out", double, 2&gt; audio;
  } outputs;

  struct conf
  {
    int sample_rate{44100};
  } configuration;

  void prepare(conf c) { configuration = c; }

  int in_flight = 0;
  ossia::frequency last_note{};
  ossia::linear last_volume{};
  double phase = 0.;

  /** Simple monophonic synthesizer **/
  void operator()(int frames)
  {
    // 1. Process the MIDI messages. We'll just play the latest note-on
    // in a not very sample-accurate way..

    for(auto&amp; m : inputs.midi.midi_messages)
    {
      // Let's ignore channels
      switch((libremidi::message_type)(m.bytes[0] &amp; 0xF0))
      {
        case libremidi::message_type::NOTE_ON:
          in_flight++;

          // Let's leverage the ossia unit conversion framework (adapted from Jamoma):
          // bytes is interpreted as a midi pitch and then converted to frequency.
          last_note = ossia::midi_pitch{m.bytes[1]};

          // Store the velocity in linear gain
          last_volume = ossia::midigain{m.bytes[2]};
          break;

        case libremidi::message_type::NOTE_OFF:
          in_flight--;
          break;
        default:
          break;
      }
    }

    // 2. Quit if we don't have any more note to play
    if(in_flight &lt;= 0)
      return;

    // 3. Output some bleeps
    double increment
        = ossia::two_pi * last_note.dataspace_value / double(configuration.sample_rate);
    auto&amp; out = outputs.audio.samples;

    for(int64_t j = 0; j &lt; frames; j++)
    {
      out[0][j] = last_volume.dataspace_value * std::sin(phase);
      out[1][j] = out[0][j];

      phase += increment;
    }
  }
};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image-ports"><a class="header" href="#image-ports">Image ports</a></h1>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p>Some media systems have the ability to process images. Avendish is not restricted here :-)</p>
<p>Note that this part of the system is still pretty much in flux, in particular with regards of how allocations are supposed to be handled.
Any feedback on this is welcome.</p>
<p>First, here is how we define a viable texture type:</p>
<pre><code class="language-cpp">struct my_texture
{
  enum format { RGBA }; // The only recognized one so far
  unsigned char* bytes;
  int width;
  int height;
  bool changed;
};
</code></pre>
<p>Then, a texture port:</p>
<pre><code class="language-cpp">struct {
  rgba_texture texture;
} input;
</code></pre>
<p>Note that currently, it is <em>the responsibility of the plug-in author</em> to allocate the texture and set the <code>changed</code> bool for output ports. Input textures come from outside.</p>
<p>Due to the large cost of uploading a texture, <code>changed</code> is used to indicate both to the plug-in author that input textures have been touched,and for the plug-in author to indicate to the external environment that the output has changed and must be re-uploaded to the GPU.</p>
<h2 id="gpu-processing"><a class="header" href="#gpu-processing">GPU processing</a></h2>
<p>Check the <a href="writing_processors/../gpu/draw.html">Writing GPU Processors</a> chapter of this book!</p>
<h2 id="helpers-3"><a class="header" href="#helpers-3">Helpers</a></h2>
<p>A few types are provided:</p>
<ul>
<li><code>halp::rgba_texture</code></li>
<li><code>halp::texture_input&lt;"Name"&gt;</code> provides methods to get an RGBA pixel:</li>
</ul>
<pre><code class="language-cpp">auto [r,g,b,a] = tex.get(10, 20);
</code></pre>
<ul>
<li><code>halp::texture_output&lt;"Name"&gt;</code> provides methods to set a RGBA pixel:</li>
</ul>
<pre><code class="language-cpp">tex.set(10, 20, {.r = 10, .g = 100, .b = 34, .a = 255});
tex.set(10, 20, 10, 100, 34, 255);
</code></pre>
<p>as well as useful method to initialize and mark the texture ready for upload:</p>
<pre><code class="language-cpp">// Call this in the constructor or before processing starts
tex.create(100, 100);

// Call this after making changes to the texture
tex.upload();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image-processor-example"><a class="header" href="#image-processor-example">Image processor example</a></h1>
<p>This example is a very simple image filter. It takes an input image and downscales &amp; degrades it.</p>
<pre><code class="language-cpp">#pragma once
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;halp/audio.hpp&gt;
#include &lt;halp/controls.hpp&gt;
#include &lt;halp/meta.hpp&gt;
#include &lt;halp/sample_accurate_controls.hpp&gt;
#include &lt;halp/texture.hpp&gt;

namespace examples
{
struct TextureFilterExample
{
  halp_meta(name, "My example texture filter");
  halp_meta(c_name, "texture_filt");
  halp_meta(category, "Demo");
  halp_meta(author, "Jean-Michaël Celerier");
  halp_meta(description, "Example texture filter");
  halp_meta(uuid, "3183d03e-9228-4d50-98e0-e7601dd16a2e");

  struct
  {
    halp::texture_input&lt;"In"&gt; image;
    halp::knob_f32&lt;"Gain", halp::range{0., 255., 0.}&gt; gain;
    halp::knob_i32&lt;"Downscale", halp::range{1, 32, 8}&gt; downscale;
  } inputs;

  struct
  {
    halp::texture_output&lt;"Out"&gt; image;
  } outputs;

  // Some initialization can be done in the constructor.
  TextureFilterExample() noexcept
  {
    // Allocate some initial data
    outputs.image.create(1, 1);
  }

  void operator()()
  {
    auto&amp; in_tex = inputs.image.texture;
    auto&amp; out_tex = outputs.image.texture;

    // Since GPU readbacks are asynchronous: reading textures may take some time and
    // thus the data may not be available from the beginning.
    if(in_tex.bytes == nullptr)
      return;

    // Texture hasn't changed since last time, no need to recompute anything
    if(!in_tex.changed)
      return;
    in_tex.changed = false;

    const double downscale_factor = inputs.downscale;

    const int small_w = in_tex.width / downscale_factor;
    const int small_h = in_tex.height / downscale_factor;
    // We (dirtily) downscale by a factor of downscale_factor
    if(out_tex.width != small_w || out_tex.height != small_h)
      outputs.image.create(small_w, small_h);

    for(int y = 0; y &lt; small_h; y++)
    {
      for(int x = 0; x &lt; small_w; x++)
      {
        // Get a pixel
        auto [r, g, b, a] = inputs.image.get(
            std::floor(x * downscale_factor), std::floor(y * downscale_factor));

        // (Dirtily) Take the luminance and compute its contrast
        double contrasted = std::pow((r + g + b) / (3. * 255.), 4.);

        // (Dirtily) Posterize
        uint8_t col
            = std::clamp(uint8_t(contrasted * 8) * (255 / 8.) * inputs.gain, 0., 255.);

        // Update the output texture
        outputs.image.set(x, y, col, col, col, 255);
      }
    }

    // Call this when the texture changed
    outputs.image.upload();
  }
};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metadatas"><a class="header" href="#metadatas">Metadatas</a></h1>
<blockquote>
<p>Supported bindings: all</p>
</blockquote>
<p>So far the main metadata we saw for our processor is its name:</p>
<pre><code class="language-cpp">static consteval auto name() { return "Foo"; }
</code></pre>
<p>Or with the helper macro:</p>
<pre><code class="language-cpp">halp_meta(name, "Foo")
</code></pre>
<p>There are a few more useful metadatas that can be used and which will be used depending on whether the bindings support exposing them.
Here is a list in order of importance; it is recommended that strings are used for all of these and that they are filled as much as possible.</p>
<ul>
<li><code>name</code>: the pretty name of the object.</li>
<li><code>c_name</code>: a C-identifier-compatible name for the object. This is necessary for instance for systems such as Python, PureData or Max which do not support spaces or special characters in names.</li>
<li><code>uuid</code>: a string such as <code>8a4be4ec-c332-453a-b029-305444ee97a0</code>, generated for instance with the <code>uuidgen</code> command on Linux, Mac and Windows, or with <a href="https://www.uuidgenerator.net/">uuidgenerator.net</a> otherwise. This provides a computer-identifiable unique identifier for your plug-in, to ensure that hosts don't have collisions between plug-ins of the same name and different vendors when reloading them (sadly, on some older APIs this is unavoidable).</li>
<li><code>description</code>: a textual description of the processor.</li>
<li><code>vendor</code>: who distributes the plug-in.</li>
<li><code>product</code>: product name if the plug-in is part of a larger product.</li>
<li><code>version</code>: a version string, ideally convertible to an integer as some older APIs expect integer versions.</li>
<li><code>category</code>: a category for the plug-in. "Audio", "Synth", "Distortion", "Chorus"... there's no standard, but one can check for instance the names used <a href="https://lv2plug.in/ns/lv2core">in LV2</a> or the list mentioned by <a href="https://distrho.github.io/DPF/group__PluginMacros.html">DISTRHO</a>.</li>
<li><code>copyright</code>: <code>(c) the plug-in authors 2022-xxxx</code></li>
<li><code>license</code>: an <a href="https://spdx.org/licenses/">SPDX identifier</a> for the license or a link towards a license document</li>
<li><code>url</code>: URL for the plug-in if any.</li>
<li><code>email</code>: A contact e-mail if any.</li>
<li><code>manual_url</code>: an url for a user manual if any.</li>
<li><code>support_url</code>: an url for user support, a forum, chat etc. if any.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supported-port-types"><a class="header" href="#supported-port-types">Supported port types</a></h1>
<p>The supported port types depend on the back-end. There is, however, some flexibility.</p>
<h2 id="simple-ports"><a class="header" href="#simple-ports">Simple ports</a></h2>
<h3 id="float"><a class="header" href="#float">Float</a></h3>
<blockquote>
<p>Supported bindings: all</p>
</blockquote>
<pre><code class="language-cpp">struct {
  float value;
} my_port;
</code></pre>
<h3 id="double"><a class="header" href="#double">Double</a></h3>
<blockquote>
<p>Supported bindings: all except Max / Pd message processors (they will work in Max / Pd audio processors) as their API expect a pointer to an existing <code>float</code> value.</p>
</blockquote>
<pre><code class="language-cpp">struct {
  double value;
} my_port;
</code></pre>
<h3 id="int"><a class="header" href="#int">Int</a></h3>
<blockquote>
<p>Supported bindings: Same than double.</p>
</blockquote>
<pre><code class="language-cpp">struct {
  int value;
} my_port;
</code></pre>
<h3 id="bool"><a class="header" href="#bool">Bool</a></h3>
<blockquote>
<p>Supported bindings: Same than double.</p>
</blockquote>
<pre><code class="language-cpp">struct {
  bool value;
} my_port;
</code></pre>
<blockquote>
<p>Note that depending on the widget you use, UIs may create a <code>toggle</code>,
a maintained <code>button</code> or a momentary <code>bang</code>.</p>
</blockquote>
<h3 id="string"><a class="header" href="#string">String</a></h3>
<blockquote>
<p>Supported bindings: ossia, Max, Pd, Python</p>
</blockquote>
<pre><code class="language-cpp">struct {
  std::string value;
} my_port;
</code></pre>
<h2 id="enumerations"><a class="header" href="#enumerations">Enumerations</a></h2>
<blockquote>
<p>Supported bindings: all</p>
</blockquote>
<p>Enumerations are interesting.
There are multiple ways to implement them.</p>
<h3 id="mapping-a-string-to-a-value"><a class="header" href="#mapping-a-string-to-a-value">Mapping a string to a value</a></h3>
<p>Consider the following port:</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
using my_pair = std::pair&lt;std::string_view, T&gt;;
struct {
  halp_meta(name, "Enum 1");
  enum widget { combobox };

  struct range {
    my_pair&lt;float&gt; values[3]{{"Foo", -10.f}, {"Bar", 5.f}, {"Baz", 10.f}};
    int init{1}; // == Bar
  };

  float value{}; // Will be initialized to 5.f
} combobox;
</code></pre>
<p>Here, using a range definition of the form:</p>
<pre><code class="language-cpp">struct range {
  &lt;string -&gt; value map&gt; values[N] = {
    { key_1, value_1}, { key_2, value_2 }, ...
  };

  &lt;integer&gt; init = /* initial index */;
};
</code></pre>
<p>allows to initialize a combobox in the UI, with a predetermined set of values.
The value type is the actual one which will be used for the port - Avendish will translate
as needed.</p>
<h3 id="enumerating-with-only-string"><a class="header" href="#enumerating-with-only-string">Enumerating with only string</a></h3>
<p>Consider the following port:</p>
<pre><code class="language-cpp">struct {
  halp_meta(name, "Enum 2");
  enum widget { enumeration };

  struct range {
    std::string_view values[4]{"Roses", "Red", "Violets", "Blue"};
    int init{1}; // Red
  };

  std::string_view value;
};
</code></pre>
<p>Here, we can use <code>std::string_view</code>: the assigned value will always be
one from the range::values array ; these strings live in static memory
so there is no need to duplicate them in an <code>std::string</code>.</p>
<p>It is also possible to use an <code>int</code> for the port value:</p>
<pre><code class="language-cpp">struct {
  halp_meta(name, "Enum 3");
  enum widget { enumeration };

  struct range {
    std::string_view values[4]{"Roses", "Red", "Violets", "Blue"};
    int init{1}; // Red
  };

  int value{};
};
</code></pre>
<p>Here, the int will just be the index of the selected thing.</p>
<h3 id="enumerating-with-proper-enums--"><a class="header" href="#enumerating-with-proper-enums--">Enumerating with proper enums :-)</a></h3>
<p>Finally, we can also use actual enums.</p>
<pre><code class="language-cpp">enum my_enum { A, B, C };
struct {
  halp_meta(name, "Enum 3");
  enum widget { enumeration };

  struct range
  {
    std::string_view values[3]{"A", "B", "C"};
    my_enum init = my_enum::B;
  };

  my_enum value{};
}
</code></pre>
<blockquote>
<p>The enum must be contiguous, representable in an int32 and start at 0:
<code>enum { A = 3, B, C };</code> will not work.
<code>enum { A, B, C, AA = 10 };</code> will not work.
<code>enum { A, B, C, ... 4 billion values later ..., XXXX };</code> will not work.
<code>enum { A, B, C };</code> will work.</p>
</blockquote>
<p>An helper is provided, which is sadly a macro as we cannot do proper enum reflection yet:</p>
<pre><code class="language-cpp">halp__enum("Simple Enum", Peg, Square, Peg, Round, Hole) my_port;
</code></pre>
<p>declares a port named "Simple Enum". The default value will be "Peg", the 4 enumerators are Square, Peg, Round, Hole.</p>
<h2 id="containers"><a class="header" href="#containers">Containers</a></h2>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p>Containers are supported (in environments where this is meaningful) provided that they provide an API that matches:</p>
<h3 id="stdvector"><a class="header" href="#stdvector"><code>std::vector</code></a></h3>
<pre><code class="language-cpp">template &lt;typename T&gt;
concept vector_ish = requires(T t)
{
  t.push_back({});
  t.size();
  t.reserve(1);
  t.resize(1);
  t.clear();
  t[1];
};
</code></pre>
<p>For instance, <code>boost::static_vector</code>, <code>boost::small_vector</code> or <code>absl::InlinedVector</code> all satisfy this and can be used as a value type.</p>
<pre><code class="language-cpp">struct {
  std::vector&lt;float&gt; value;
} my_port;
</code></pre>
<h3 id="stdset"><a class="header" href="#stdset"><code>std::set</code></a></h3>
<p>For instance, <code>std::set</code>, <code>std::unordered_set</code> or <code>boost::container::flat_set</code> can be used as a value type.</p>
<pre><code class="language-cpp">struct {
  boost::container::flat_set&lt;float&gt; value;
} my_port;
</code></pre>
<h3 id="stdmap"><a class="header" href="#stdmap"><code>std::map</code></a></h3>
<p>For instance, <code>std::map</code>, <code>std::unordered_map</code> or <code>boost::container::flat_map</code> can be used as a value type.</p>
<pre><code class="language-cpp">struct {
  boost::container::flat_map&lt;float&gt; value;
} my_port;
</code></pre>
<h3 id="c-arrays"><a class="header" href="#c-arrays">C arrays</a></h3>
<p>C arrays aren't supported due to limitations in the reflection capabilities of C++:</p>
<pre><code class="language-cpp">struct {
  int value[2]; // Won't work
} my_port;
</code></pre>
<p>or</p>
<pre><code class="language-cpp">struct {
  struct { int v[2]; } value; // Won't work
} my_port;
</code></pre>
<p>Use <code>std::array</code> instead.</p>
<h2 id="variants"><a class="header" href="#variants">Variants</a></h2>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p>Types which look like <code>std::variant</code> (for instance <code>boost::variant2::variant</code> or <code>mpark::variant</code>) are supported.</p>
<pre><code class="language-cpp">struct {
  std::variant&lt;int, bool, std::string&gt; value;
} my_port;
</code></pre>
<h2 id="optionals"><a class="header" href="#optionals">Optionals</a></h2>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p>Types which look like <code>std::optional</code> (for instance <code>boost::optional</code> or <code>tl::optional</code>) are supported.</p>
<pre><code class="language-cpp">struct {
  std::optional&lt;int&gt; value;
} my_port;
</code></pre>
<p>This is used to give message semantics to the port: optionals are reset before execution of the current
tick, both for inputs and outputs. If an input is set, it means that a message was received for this tick.
If the processor sets the output, a message will be sent outwards.</p>
<p>This is mostly equivalent to messages and callbacks, but with a value-based instead of function-based API
(and thus a small additional storage cost).</p>
<h2 id="advanced-types"><a class="header" href="#advanced-types">Advanced types</a></h2>
<h3 id="2d--3d-position-xy--xyz"><a class="header" href="#2d--3d-position-xy--xyz">2D / 3D position: xy / xyz</a></h3>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p>Here a special shape of struct is recognized:</p>
<pre><code class="language-cpp">struct {
  struct { float x, y; } value;
} my_port;
</code></pre>
<h3 id="color"><a class="header" href="#color">Color</a></h3>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p>Here a special shape of struct is recognized:</p>
<pre><code class="language-cpp">struct {
  struct { float r, g, b, a; } value;
} my_port;
</code></pre>
<h3 id="generalized-aggregate-types"><a class="header" href="#generalized-aggregate-types">Generalized aggregate types</a></h3>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p>Aggregates are <em>somewhat</em> supported: that is, one can define</p>
<pre><code class="language-cpp">struct Foo {
  int a, b;
  struct {
    std::vector&lt;float&gt; c; 
    std::string d;
  } x; 
  std::array&lt;bool, 4&gt; e;
  std::map&lt;std::string, int&gt; f; 
};
</code></pre>
<p>and use this as a value type in a port.
This is so far only supported in ossia, and will not preserve names, but be translated as:</p>
<pre><code class="language-cpp">(list) [
  (int)a
, (int)b
, (list) [ 
    (list)[ c0, c1, c2, ... ]
  , (string)"d"
  ]
, (list)[true, false, false, true]
, (map){"foo": 123, "bar": 456}
]
</code></pre>
<p>It is possible to specify field names in an aggregate manually, in order to have the sub-object be detected as a map and not a list:</p>
<pre><code class="language-cpp">struct rect { float x{}, y{}, w{}, h{}; };

struct detected_object
{
  std::string name;
  rect geometry;
  float probability{};

  halp_field_names(name, geometry, probability);
  // This macro expands to: 
  // static constexpr auto field_names()
  // { return std::array&lt;std::string_view, 3&gt;{"name", "geometry", "probability"}; }
};
</code></pre>
<p>This maps to:</p>
<pre><code class="language-cpp">(map) {
   name: "foo"
 , geometry: (list) [3, 4, 120, 356]
 , probability: 0.95
}
</code></pre>
<h1 id="helper-type"><a class="header" href="#helper-type">Helper type</a></h1>
<p>To create a port ithout having to declare a struct, you can directly use:</p>
<p><code>halp::val_port&lt;"My port", std::string&gt; my_port;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-2"><a class="header" href="#example-2">Example</a></h1>
<p>This example shows the various helper types that provide simple definitions matching the supported port types saw before.</p>
<pre><code class="language-cpp">#pragma once
#include &lt;avnd/concepts/audio_port.hpp&gt;
#include &lt;avnd/concepts/parameter.hpp&gt;
#include &lt;avnd/common/for_nth.hpp&gt;
#include &lt;boost/pfr.hpp&gt;
#include &lt;cmath&gt;
#include &lt;halp/audio.hpp&gt;
#include &lt;halp/controls.hpp&gt;
#include &lt;halp/controls_fmt.hpp&gt;
#include &lt;ossia/network/value/format_value.hpp&gt;

#include &lt;halp/meta.hpp&gt;
#include &lt;halp/sample_accurate_controls.hpp&gt;

#if __has_include(&lt;magic_enum.hpp&gt;)
#include &lt;magic_enum.hpp&gt;
#endif
namespace examples
{

struct ControlGallery
{
  halp_meta(name, "Control gallery");
  halp_meta(c_name, "control_gallery");
  halp_meta(category, "Demo");
  halp_meta(author, "&lt;AUTHOR&gt;");
  halp_meta(description, "&lt;DESCRIPTION&gt;");
  halp_meta(uuid, "a9b0e2c6-61e9-45df-a75d-27abf7fb43d7");

  struct
  {
    //! Buttons are level-triggers: true as long as the button is pressed
    halp::accurate&lt;halp::maintained_button&lt;"Press me ! (Button)"&gt;&gt; button;

    //! In contrast, impulses are edge-triggers: there is only a value at the moment of the click.
    halp::accurate&lt;halp::impulse_button&lt;"Press me ! (Impulse)"&gt;&gt; impulse_button;

    //! Common widgets
    halp::accurate&lt;halp::hslider_f32&lt;"Float slider", halp::range{0., 1., 0.5}&gt;&gt;
        float_slider;
    halp::accurate&lt;halp::knob_f32&lt;"Float knob", halp::range{0., 1., 0.5}&gt;&gt; float_knob;
    //// // FIXME
    //// struct {
    ////   // FIXME meta_control(Control::LogFloatSlider, "Float slider (log)", 0., 1., 0.5);
    ////   ossia::timed_vec&lt;float&gt; values{};
    //// } log_float_slider;
    ////

#if defined(__clang__) || defined(_MSC_VER)
    // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=104720
    halp::accurate&lt;halp::hslider_i32&lt;"Int slider", halp::range{0., 1000., 10.}&gt;&gt;
        int_slider;
    halp::accurate&lt;halp::spinbox_i32&lt;"Int spinbox", halp::range{0, 1000, 10}&gt;&gt;
        int_spinbox;
#endif

    //! Will look like a checkbox
    halp::accurate&lt;halp::toggle&lt;"Toggle", halp::toggle_setup{.init = true}&gt;&gt; toggle;

    //! Same, but allows to choose what is displayed.
    // FIXME halp::accurate&lt;halp::chooser_toggle&lt;"Toggle", {"Falsey", "Truey"}, false&gt;&gt; chooser_toggle;

    //! Allows to edit some text.
    halp::accurate&lt;halp::lineedit&lt;"Line edit", "Henlo"&gt;&gt; lineedit;

    //! First member of the pair is the text, second is the value.
    //! Defining comboboxes and enumerations is a tiny bit more complicated
    struct : halp::sample_accurate_values&lt;halp::combo_pair&lt;float&gt;&gt;
    {
      halp_meta(name, "Combo box");
      enum widget
      {
        combobox
      };

      struct range
      {
        halp::combo_pair&lt;float&gt; values[3]{{"Foo", -10.f}, {"Bar", 5.f}, {"Baz", 10.f}};
        int init{1}; // Bar
      };

      float value{};
    } combobox;

    //! Here value will be the string
    struct : halp::sample_accurate_values&lt;std::string_view&gt;
    {
      halp_meta(name, "Enum 2");
      enum widget
      {
        enumeration
      };

      struct range
      {
        std::string_view values[4]{"Roses", "Red", "Violets", "Blue"};
        int init{1}; // Red
      };

      // FIXME: string_view: allow outside bounds
      std::string_view value;
    } enumeration_a;

    //! Here value will be the index of the string... but even better than that
    //! is below:
    struct : halp::sample_accurate_values&lt;int&gt;
    {
      halp_meta(name, "Enum 3");
      enum widget
      {
        enumeration
      };

      struct range
      {
        std::string_view values[4]{"Roses 2", "Red 2", "Violets 2", "Blue 2"};
        int init{1}; // Red
      };

      int value{};
    } enumeration_b;

    /// // FIXME
    /// //! Same as Enum but won't reject strings that are not part of the list.
    /// struct {
    ///   static const constexpr std::array&lt;const char*, 3&gt; choices() {
    ///     return {"Square", "Sine", "Triangle"};
    ///   };
    ///   // FIXME meta_control(Control::UnvalidatedEnum, "Unchecked enum", 1, choices());
    ///   ossia::timed_vec&lt;std::string&gt; values{};
    /// } unvalidated_enumeration;

    //! It's also possible to use this which will define an enum type and
    //! map to it automatically.
    //! e.g. in source one can then do:
    //!
    //!   auto&amp; param = inputs.simpler_enumeration;
    //!   using enum_type = decltype(param)::enum_type;
    //!   switch(param.value) {
    //!      case enum_type::Square:
    //!        ...
    //!   }
    //!
    //! OSC messages can use either the int index or the string.
    struct enum_t
    {
      halp__enum("Simple Enum", Peg, Square, Peg, Round, Hole)
    };
    halp::accurate&lt;enum_t&gt; simpler_enumeration;

    struct combobox_t
    {
      halp__enum_combobox("Color", Blue, Red, Green, Teal, Blue, Black, Orange)
    };
    halp::accurate&lt;combobox_t&gt; simpler_enumeration_in_a_combobox;

    //! Crosshair XY chooser
    halp::accurate&lt;halp::xy_pad_f32&lt;"XY", halp::range{-5.f, 5.f, 0.f}&gt;&gt; position;

    //! Color chooser. Colors are in 8-bit RGBA by default.
    halp::accurate&lt;halp::color_chooser&lt;"Color"&gt;&gt; color;

  } inputs;

  void operator()()
  {
    const bool has_impulse = !inputs.impulse_button.values.empty();
    const bool has_button = std::any_of(
        inputs.button.values.begin(), inputs.button.values.end(),
        [](const auto&amp; p) { return p.second == true; });

    if(!has_impulse &amp;&amp; !has_button)
      return;

    avnd::for_each_field_ref(inputs, []&lt;typename Control&gt;(const Control&amp; input) {
      {
        auto val = input.values.begin()-&gt;second;
        if constexpr(std::is_enum_v&lt;decltype(val)&gt;) {
#if __has_include(&lt;magic_enum.hpp&gt;)
          fmt::print("changed: {} {}", Control::name(), magic_enum::enum_name(val));
#else
          fmt::print("changed: {} {}", Control::name(), static_cast&lt;std::underlying_type_t&lt;decltype(val)&gt;&gt;(val));
#endif
        } else {
          fmt::print("changed: {} {}", Control::name(), val);
        }
      }
    });
  }
};

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-ports"><a class="header" href="#file-ports">File ports</a></h1>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p>File ports are currently only supported with the ossia binding.</p>
<p>They allow to specify that we want the content of a file.
The host will take care of loading, mmaping, converting, etc... the file in the relevant format - as far as possible outside of DSP / processing threads.</p>
<p>Every file port should at least conform to the very basic following concept:</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
concept file = requires(T t) {
  t.filename;
};

template &lt;typename T&gt;
concept file_port = requires(T t) {
  { t.file } -&gt; file;
};
</code></pre>
<p>Here is for instance a valid basic file port ; hosts will open a relevant file chooser:</p>
<pre><code class="language-cpp">struct my_file_port {
  struct {
    std::string filename;
  } file;
};
</code></pre>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<h3 id="file-watch"><a class="header" href="#file-watch">File watch</a></h3>
<p>By adding a <code>file_watch</code> <a href="advanced/../development/flags.html">flag</a> to the class, the host environment will reload the file's data whenever a change is detected on disk.
Note that this has an obvious performance cost as the host must check regularly for changes: do not overdo it!</p>
<h3 id="file-filters"><a class="header" href="#file-filters">File filters</a></h3>
<p>File ports should prompt the host to open a file chooser.
One is generally only interested in a specific file type.
This can be specified in the following ways:</p>
<h4 id="general-file-filters"><a class="header" href="#general-file-filters">General file filters</a></h4>
<p>Here, the filter is a string of either of the following formats:</p>
<pre><code>"*.jpg *.jpeg"
"JPEG Images (*.jpg *.jpeg)"
</code></pre>
<pre><code class="language-cpp">struct my_file_port : ... {
  // Currently implemented:
  // Any audio file that can be loaded by the host
  static consteval auto filters() { return "CSV files (*.csv)"; }
};
</code></pre>
<h4 id="domain-specific-file-filters"><a class="header" href="#domain-specific-file-filters">Domain-specific file filters</a></h4>
<p>This is for the case where you want a general kind of media and don't care specifically about the extension:
for instance, for audio files you could have .wav, .aiff, .mp3, etc etc ; it is pointless to try to specify a whole list.
Instead, the host knows which audio file formats it is able to load and should just be able to show its own audio-specific file chooser.</p>
<pre><code class="language-cpp">struct my_file_port : ... {
  // Currently implemented:
  // Any audio file that can be loaded by the host
  static consteval auto filters() { enum { audio }; return audio; }

  // Any midi file that can be loaded by the host
  static consteval auto filters() { enum { midi }; return midi; }

  // In the future:
  static consteval auto filters() { enum { image }; return image; }
  static consteval auto filters() { enum { video }; return video; }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="soundfile-ports"><a class="header" href="#soundfile-ports">Soundfile ports</a></h1>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p>Soundfile ports are currently only supported with the ossia binding.</p>
<p>They allow to define an input which will be the content of a sound file, along with its metadata: number of channels, number of frames.</p>
<h2 id="port-definition"><a class="header" href="#port-definition">Port definition</a></h2>
<p>A soundfile input port looks like this:</p>
<pre><code class="language-cpp">struct
{
  static consteval auto name() { return "My soundfile"}
  struct {
    const float** data{}; // The audio channels
    int64_t frames{}; // How many samples are there in a channel
    int32_t channels{}; // How many channels are there
    std::string_view filename; // Currently loaded soundfile
  } soundfile;
} snd;
</code></pre>
<p>A helper type is provided:</p>
<pre><code class="language-cpp">struct {
  halp::soundfile_port&lt;"My soundfile"&gt; snd;
} inputs;

void operator()(int frames) {
  // Check if a soundfile is loaded:
  if(!inputs.snd)
    return;

  // Access things through helpers
  const int channels = inputs.snd.channels();
  const int frames = inputs.snd.frames();
  std::span&lt;const float&gt; chan = inputs.snd.channel(0);

  // Or manually...
  for(int i = 0; i &lt; channels; i++)
    for(int j = 0; j &lt; frames; j++)
      inputs.snd[i][j];
}
</code></pre>
<p>It allows choosing the sample format in which the samples are loaded:</p>
<pre><code class="language-cpp">halp::soundfile_port&lt;"My soundfile", float&gt; snd_float;
halp::soundfile_port&lt;"My soundfile", double&gt; snd_double;
</code></pre>
<h2 id="callback"><a class="header" href="#callback">Callback</a></h2>
<p>Like other ports, it is possible to get an update callback, by implementing an <code>update</code> method ;
the simplest way is to make an empty struct which inherits from <code>halp::soundfile</code></p>
<pre><code class="language-cpp">struct : halp::soundfile_port&lt;"My soundfile"&gt; {
  void update(MyObject&amp; obj) {
    // This code is called whenever the soundfile has been changed by the user
  }
} port_name;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="midifle-ports"><a class="header" href="#midifle-ports">Midifle ports</a></h1>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p>Midifile ports are currently only supported with the ossia binding.</p>
<p>They allow to define an input which will be the content of a MIDI file.</p>
<h2 id="port-definition-1"><a class="header" href="#port-definition-1">Port definition</a></h2>
<p>A midifile input port assumes the existence of a MIDI event structure.</p>
<p>The whole thing can look like this:</p>
<pre><code class="language-cpp">struct midi_event
{
  // The MIDI messages
  std::vector&lt;unsigned char&gt; bytes;

  // Can also be this, but meta events won't be available 
  // since they are &gt; 3 bytes.
  unsigned char bytes[3];
  
  // optional, delta time in ticks
  int tick_delta;

  // optional, time since the beginning in ticks
  int tick_absolute; 
};

struct
{
  static consteval auto name() { return "My midifile"}
  struct {
    // Can be any vector-ish container, but must support push_back
    std::vector&lt;std::vector&lt;midi_event&gt;&gt; tracks; 

    // If present, the length in ticks 
    int64_t length{};

    // If present, the length in ticks     
    int64_t ticks_per_beat{};

    // If present, the length in ticks     
    float starting_tempo{};
    std::string_view filename; // Currently loaded midifile
  } midifile;
} snd;
</code></pre>
<p>A few helper types are provided:</p>
<pre><code class="language-cpp">struct midi_track_event
{
  boost::container::small_vector&lt;uint8_t, 15&gt; bytes;
  int tick_delta = 0;
};

struct simple_midi_track_event
{
  uint8_t bytes[3];
  int64_t tick_absolute;
};

struct {
  // Default event type is simple_midi_track_event for performance and compile times, 
  // but it can be changed through the template arguments
  halp::midifile_port&lt;"My midifile", midi_track_event&gt; snd;
} inputs;
</code></pre>
<h2 id="callback-1"><a class="header" href="#callback-1">Callback</a></h2>
<p>Like other ports, it is possible to get an update callback, by implementing an <code>update</code> method ;
the simplest way is to make an empty struct which inherits from <code>halp::midifile_port</code></p>
<pre><code class="language-cpp">struct : halp::midifile_port&lt;"My midifile"&gt; {
  void update(MyObject&amp; obj) {
    // This code is called whenever the midifile has been changed by the user
  }
} port_name;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raw-file-ports"><a class="header" href="#raw-file-ports">Raw file ports</a></h1>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p>File ports are currently only supported with the ossia binding.</p>
<p>They allow to define an input which will be the content of a file on the hard drive.
The file is memory-mapped.</p>
<h2 id="port-definition-2"><a class="header" href="#port-definition-2">Port definition</a></h2>
<p>A file input port can be defined like this:</p>
<pre><code class="language-cpp">struct
{
  static consteval auto name() { return "My file"}
  struct {
    // The file data. 
    // Only requirement for the type is that it can be assigned {data, size}.
    std::string_view bytes; 

    std::string_view filename; // Currently loaded file

    // Optional: if defined, the file will be memory-mapped instead of being copied in RAM, 
    // which can be relevant for very large assets.
    // Be aware of the page fault implications before accessing the data in the audio code !
    enum { mmap }; 

    // Optional: if defined, the file will be read in text mode, e.g. \r\n (Windows line endings) 
    // get translated to \n on Linux &amp; MacOS. Incompatible with mmap, for obvious reasons.
    // Default is reading in binary mode.
    enum { text }; 
  } file;
} snd;
</code></pre>
<p>A helper type is provided:</p>
<pre><code class="language-cpp">struct {
  halp::file_port&lt;"My file"&gt; snd;
} inputs;
</code></pre>
<h2 id="callback-2"><a class="header" href="#callback-2">Callback</a></h2>
<p>Like other ports, it is possible to get an update callback, by implementing an <code>update</code> method ;
the simplest way is to make an empty struct which inherits from <code>halp::file_port</code></p>
<pre><code class="language-cpp">// text_file_view (the default) has the text flag, and mmap_file_view has the mmap flag.
struct : halp::file_port&lt;"My file", mmap_file_view&gt; {
  void update(MyObject&amp; obj) {
    // This code is called whenever the file has been changed by the user
  }
} port_name;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-editors"><a class="header" href="#code-editors">Code editors</a></h1>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p>For live-coding and similar purposes, it is common to embed a domain-specific programming language
into a host environment: Faust, math expression languages, Javascript, Lisp, etc...</p>
<p>If one adds the <code>language</code> metadata to a string port, then the port will be recognized
as a programming language code input: hosts are encouraged to show some relevant text editor for code
instead of a simple line edit.</p>
<h2 id="example-3"><a class="header" href="#example-3">Example</a></h2>
<pre><code class="language-cpp">struct : halp::lineedit&lt;"Program", ""&gt;
{
  halp_meta(language, "INTERCAL")
} program;
</code></pre>
<p>should show up as a code editor with support for <a href="https://en.wikipedia.org/wiki/INTERCAL">INTERCAL</a> programs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-user-interfaces"><a class="header" href="#creating-user-interfaces">Creating user interfaces</a></h1>
<p>We have seen so far that we can specify widgets for our controls. Multiple back-ends may render these widgets in various ways.
This is already a good start for making user interfaces, but most media systems generally have more specific user interface needs.</p>
<p>Avendish allows three levels of UI definition:</p>
<ol>
<li>Automatic: nothing to do, all the widgets corresponding to inputs and outputs of the processor will be generated automatically in a list. This is not pretty but sufficient for many simple cases. For instance, here is how some Avendish plug-ins render in <em>ossia score</em>.</li>
</ol>
<blockquote>
<p>Supported bindings: all, not really a feature of Avendish per-se but of the hosts</p>
</blockquote>
<p><img src="advanced/images/ui-basic.png" alt="Basic UI" /></p>
<ol start="2">
<li>Giving layout hints. A declarative syntax allows to layout said items and text in usual containers, auomatically and with arbitrary nesting: hbox, vbox, tabs, split view... Here is, again, an example in <em>ossia score</em>.</li>
</ol>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p><img src="advanced/images/ui-layout.png" alt="Basic UI" /></p>
<ol start="3">
<li>Creating entirely custom items with a Canvas-based API. It is also possible to load images, make custom animations and handle mouse events.</li>
</ol>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p><img src="advanced/images/ui-image.gif" alt="Basic UI" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layout-based-uis"><a class="header" href="#layout-based-uis">Layout-based UIs</a></h1>
<blockquote>
<p>Supported bindings: ossia, others are work-in-progress</p>
</blockquote>
<p>To define a custom UI, one has to add a <code>struct ui</code> in the processor definition.</p>
<pre><code class="language-cpp">struct MyProcessor {
  struct ui {
   
  };
};
</code></pre>
<p>By default, this will do nothing: we have to fill it. <code>ui</code> will be the top-level widget.
Child widgets can be added simply by defining struct members.
Containers are defined by adding a <code>layout()</code> function which returns an enum value, which may
currently be any of the following names:</p>
<pre><code>hbox,
vbox,
container,
group,
split,
tabs,
grid,
spacing,
control,
custom
</code></pre>
<p>For instance:</p>
<pre><code class="language-cpp">struct ui
{
  static constexpr auto layout() { enum { hbox } d{}; return d; }
  struct {
    static constexpr auto layout() { enum { vbox } d{}; return d; }
    const char* text = "text";
    decltype(&amp;ins::int_ctl) int_widget = &amp;ins::int_ctl;
  } widgets;

  struct {
    static constexpr auto layout() { enum { spacing } d{}; return d; }
    static constexpr auto width() { return 20; }
    static constexpr auto height() { return 20; }
  } a_spacing;

  const char* text = "text2";
};
</code></pre>
<p>This defines, conceptually, the following layout:</p>
<pre><code class="language-ascii">|-----------------------------|
|  |  text  |                 |
|  |        |                 |
|  | =widg= |  &lt;20px&gt;  text2  |
|  |        |                 |
|  |        |                 |
|-----------------------------|
</code></pre>
<h2 id="layouts"><a class="header" href="#layouts">Layouts</a></h2>
<h3 id="hbox-vbox"><a class="header" href="#hbox-vbox">HBox, VBox</a></h3>
<p>These will layout things either horizontally or vertically.</p>
<h3 id="split"><a class="header" href="#split">Split</a></h3>
<p>Each children will be separated by a split line (thus generally one would use it to separate layouts).</p>
<h3 id="grid"><a class="header" href="#grid">Grid</a></h3>
<p>This will layout children items in a grid.</p>
<p>Either of <code>rows()</code> and <code>columns()</code> properties can be defined, but not both:</p>
<pre><code>static constexpr auto rows() { return 3; }
static constexpr auto columns() { return 3; }
</code></pre>
<p>If <code>columns()</code> is defined, children widget will be laid out in the first row until the column count is reached, then in the second row, etc. until there are no more children items, and conversely if <code>rows()</code> is defined.</p>
<p>That is, given:</p>
<pre><code class="language-cpp">struct {
  static constexpr auto layout() { enum { grid } d{}; return d; }
  static constexpr auto columns() { return 3; }
  const char* text1 = "A";
  const char* text2 = "B";
  const char* text3 = "C";
  const char* text4 = "D";
  const char* text5 = "E";
} a_grid;
</code></pre>
<p>The layout will be:</p>
<pre><code class="language-ascii">|---------|
| A  B  C | 
| D  E    |
|---------|
</code></pre>
<p>Instead, if <code>rows()</code> is defined to 3:</p>
<pre><code class="language-ascii">|------|
| A  D | 
| B  E | 
| C    |
|------|
</code></pre>
<h3 id="tabs"><a class="header" href="#tabs">Tabs</a></h3>
<p>Tabs will display children items in tabs.
Each children item should have a <code>name()</code> property which will be shown in the tab bar.</p>
<pre><code class="language-cpp">struct {
  static constexpr auto layout() { enum { tabs } d{}; return d; }
  struct {
    static constexpr auto layout() { enum { hbox } d{}; return d; }
    static constexpr auto name() { return "First tab"; }
    const char* text1 = "A";
    const char* text2 = "B";
  } a_hbox;
  struct {
    static constexpr auto layout() { enum { hbox } d{}; return d; }
    static constexpr auto name() { return "Second tab"; }
    const char* text3 = "C";
    const char* text4 = "D";
  } a_vbox;
} a_tabs;
</code></pre>
<h2 id="properties"><a class="header" href="#properties">Properties</a></h2>
<h3 id="background-color"><a class="header" href="#background-color">Background color</a></h3>
<p>Background colors can be chosen from a standardized set: for now, those are fairly abstract to allow things to work in a variety of environments.</p>
<pre><code>darker,
dark,
mid,
light,
lighter
</code></pre>
<p>Setting the color is done by adding this to a layout:</p>
<pre><code class="language-cpp">static constexpr auto background() { enum { dark } d{}; return d; }
</code></pre>
<h3 id="explicit-positioning"><a class="header" href="#explicit-positioning">Explicit positioning</a></h3>
<p>In "group" or "container" layouts, widgets will not be positioned automatically. <code>x</code> and <code>y</code> methods can be used for that.</p>
<pre><code class="language-cpp">static constexpr auto x() { return 20; }
static constexpr auto y() { return 20; }
</code></pre>
<h3 id="explicit-sizing"><a class="header" href="#explicit-sizing">Explicit sizing</a></h3>
<p>Containers can be given an explicit (device independent) pixel size with</p>
<pre><code class="language-cpp">static constexpr auto width() { return 100; }
static constexpr auto height() { return 50; }
</code></pre>
<p>Otherwise, things will be made to fit in a best-effort way.</p>
<h2 id="items"><a class="header" href="#items">Items</a></h2>
<h2 id="text-labels"><a class="header" href="#text-labels">Text labels</a></h2>
<p>The simplest item is the text label: simply adding a <code>const char*</code> member is sufficient.</p>
<h2 id="controls"><a class="header" href="#controls">Controls</a></h2>
<p>One can add a control (either input or output) simply by adding a member pointer to it:</p>
<pre><code class="language-cpp">struct MyProcessor {
  struct ins {
    halp::hslider_f32&lt;"Foo"&gt; foo;
  } inputs;

  struct ui
  {
    static constexpr auto layout() { enum { hbox } d{}; return d; }
    const char* text = "text";
    decltype(&amp;ins::foo) int_widget = &amp;ins::foo;
  };
};
</code></pre>
<p>The syntax without helpers currently needs some repeating as C++ does not yet allow <code>auto</code> as member fields, otherwise it'd just be:</p>
<pre><code class="language-cpp">auto int_widget = &amp;ins::foo;
</code></pre>
<h1 id="helpers-4"><a class="header" href="#helpers-4">Helpers</a></h1>
<p>Helpers simplify common tasks ; here, C++20 designated-initializers allow us to have a very pretty API and reduce repetitions:</p>
<h2 id="widget-helpers-1"><a class="header" href="#widget-helpers-1">Widget helpers</a></h2>
<pre><code class="language-cpp">halp::label l1{
    .text = "some long foo"
  , .x = 100
  , .y = 25
};

halp::item&lt;&amp;ins::foo&gt; widget{
    .x = 75
  , .y = 50
};
</code></pre>
<h2 id="properties-helpers"><a class="header" href="#properties-helpers">Properties helpers</a></h2>
<pre><code class="language-cpp">struct ui {
 // If your compiler is recent enough you can do this, 
 // otherwise layout and background enums have to be qualified:
 using enum halp::colors;
 using enum halp::layouts;
 
 halp_meta(name, "Main")
 halp_meta(layout, hbox)
 halp_meta(background, mid)

 struct {
   halp_meta(name, "Widget")
   halp_meta(layout, vbox)
   halp_meta(background, dark)
   halp::item&lt;&amp;ins::int_ctl&gt; widget;
   halp::item&lt;&amp;outs::measure&gt; widget2;
 } widgets;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-items"><a class="header" href="#custom-items">Custom items</a></h1>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p>One can also define and use custom items. This is however very experimental and only support in the ossia bindings so far :-)</p>
<h2 id="non-interactive-items"><a class="header" href="#non-interactive-items">Non-interactive items</a></h2>
<p>Here is a non-interactive item:</p>
<pre><code class="language-cpp">struct custom_anim
{
  // Static item metadatas: mandatory
  static constexpr double width() { return 200.; }
  static constexpr double height() { return 200.; }
  static constexpr double layout() { enum { custom } d{}; return d; }

  // In practice with the helpers, we use a type with the mandatory parts
  // already defined and just focus on our item's specificities ; this is 
  // enabled by this typedef.
  using item_type = custom_anim;

  // Item properties: those are mandatory
  double x = 0.0;
  double y = 0.0;
  double scale = 1.0;

  // Our paint method. avnd::painter is a concept which maps to the most usual 
  // canvas-like APIs. It is not necessary to indicate it - it just will give better
  // error messages in case of mistake, and code completion (yes) in IDEs such as QtCreator
  void paint(avnd::painter auto ctx)
  {
    constexpr double cx = 30., cy = 30.;
    constexpr double side = 40.;
  
    ctx.set_stroke_color({.r = 92, .g = 53, .b = 102, .a = 255});
    ctx.set_fill_color({173, 127, 168, 255});

    ctx.translate(100, 100);
    ctx.rotate(rot += 0.1);
  
    for(int i = 0; i &lt; 10; i++)
    {
      ctx.translate(10, 10);
      ctx.rotate(5.+ 0.1 * rot);
      ctx.scale(0.8, 0.8);
      ctx.begin_path();
  
      ctx.draw_rect(-side / 2., -side / 2., side, side);
      ctx.fill();
      ctx.stroke();
    }
  
    ctx.update();
  }

  double rot{};
};
</code></pre>
<p>This produces the small squares animation here:</p>
<p><img src="advanced/images/ui-image.gif" alt="Basic UI" /></p>
<h2 id="interactive-items-for-controlling-single-ports"><a class="header" href="#interactive-items-for-controlling-single-ports">Interactive items for controlling single ports</a></h2>
<p>This is <em>even more</em> experimental :)</p>
<p>Here is what I believe to be the first entirely UI-library-independent UI slider defined in C++.</p>
<pre><code class="language-cpp">// This type allows to define a sequence of operations which will modify a value, 
// in order to allow handling undo-redo properly. 
// The std::function members are filled by the bindings.
template&lt;typename T&gt;
struct transaction
{
  std::function&lt;void()&gt; start;
  std::function&lt;void(const T&amp;)&gt; update;
  std::function&lt;void()&gt; commit;
  std::function&lt;void()&gt; rollback;
};

// look ma, no inheritance
struct custom_slider
{
  // Same as above
  static constexpr double width() { return 100.; }
  static constexpr double height() { return 20.; }

  // Needed for changing the ui. It's the type above - it's already defined as-is 
  // in the helpers library.
  halp::transaction&lt;double&gt; transaction;

  // Called when the value changes from the host software.
  void set_value(const auto&amp; control, double value)
  {
    this-&gt;value = avnd::map_control_to_01(control, value);
  }

  // When transaction.update() is called, this converts the value in the slider 
  // into one fit for the control definition passed as argument.
  static auto value_to_control(auto&amp; control, double value)
  {
    return avnd::map_control_from_01(control, value);
  }

  // Paint method: same as above
  void paint(avnd::painter auto ctx)
  {
    ctx.set_stroke_color({200, 200, 200, 255});
    ctx.set_stroke_width(2.);
    ctx.set_fill_color({120, 120, 120, 255});
    ctx.begin_path();
    ctx.draw_rect(0., 0., width(), height());
    ctx.fill();
    ctx.stroke();

    ctx.begin_path();
    ctx.set_fill_color({90, 90, 90, 255});
    ctx.draw_rect(2., 2., (width() - 4) * value, (height() - 4));
    ctx.fill();
  }

  // Return true to handle the event. x, y, are the positions of the item in local coordinates.
  bool mouse_press(double x, double y)
  {
    transaction.start();
    mouse_move(x, y);
    return true;
  }

  // Obvious :-)
  void mouse_move(double x, double y)
  {
    const double res = std::clamp(x / width(), 0., 1.);
    transaction.update(res);
  }

  // Same
  void mouse_release(double x, double y)
  {
    mouse_move(x, y);
    transaction.commit();
  }
  
  double value{};
};

// This wraps a custom widget in all the data which is mandatory to have so that we do not have to repeat it.
// This is also already provided in the helper library ; using it looks like: 
// 
// halp::custom_item&lt;custom_slider, &amp;inputs::my_control&gt;
template&lt;typename T, auto F&gt;
struct custom_item
{
  static constexpr double layout() { enum { custom } d{}; return d; }
  using item_type = T;

  double x = 0.0;
  double y = 0.0;
  double scale = 1.0;
  decltype(F) control = F;
};
</code></pre>
<h2 id="painter-api"><a class="header" href="#painter-api">Painter API</a></h2>
<p>Here is the complete supported API so far:</p>
<pre><code class="language-cpp">#pragma once

/* SPDX-License-Identifier: GPL-3.0-or-later OR BSL-1.0 OR CC0-1.0 OR CC-PDCC OR 0BSD */

namespace avnd
{
template &lt;typename T&gt;
concept painter = requires(T t) {
                    // Paths:
                    t.begin_path();
                    t.close_path();
                    t.stroke();
                    t.fill();

                    //        x , y
                    t.move_to(0., 0.);
                    t.line_to(0., 0.);

                    //       x , y , w , h , startAngle, arcLength
                    t.arc_to(0., 1., 2., 3., 11., 12.);

                    //         c1x, c1y, c2x, c2y, endx, endy
                    t.cubic_to(0., 1., 2., 3., 11., 12.);
                    //        x1, y1, x2, y2
                    t.quad_to(0., 1., 2., 3.);

                    // Transformations:
                    //          x , y
                    t.translate(0., 0.);
                    t.scale(0., 0.);
                    t.rotate(0.);
                    t.reset_transform();

                    // Colors:
                    //                  R    G    B    A
                    t.set_stroke_color({255, 255, 255, 127});
                    t.set_stroke_width(2.);
                    t.set_fill_color({255, 255, 255, 127});

                    // Text:
                    t.set_font("Comic Sans");
                    t.set_font_size(10.0); // In points

                    //          x , y , text
                    t.draw_text(0., 0., "Hello World");

                    // Drawing
                    //          x1, y1, x2 , y2
                    t.draw_line(0., 0., 10., 10.);

                    //          x , y , w  , h
                    t.draw_rect(0., 0., 10., 10.);

                    //                  x , y , w  , h  , r
                    t.draw_rounded_rect(0., 0., 10., 10., 5.);

                    //            x , y , filename
                    t.draw_pixmap(0., 0., "pixmap");

                    //             x , y , w  , h
                    t.draw_ellipse(0., 0., 10., 10.);

                    //            cx, cy, radius
                    t.draw_circle(0., 0., 20.);

                    //           x, y, w, h, bytes, img_w, img_h
                    t.draw_bytes(0., 0., 0., 0., (unsigned char*)nullptr, 0, 0);
                    t.draw_bytes(0., 0., 0., 0., (float*)nullptr, 0, 0);
                  };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ui-message-bus"><a class="header" href="#ui-message-bus">UI message bus</a></h1>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p>Some UIs may have more complicated logic that cannot just be represented through
widgets changing single controls: pressing a button may trigger the loading of a file,
the entire reconfiguration of the UI, etc.</p>
<p>Thus, the engine may have to be notified of such changes happening in the UI. The way this is
generally done is through thread-safe queues exchanging messages.</p>
<p>An experimental implementation of this has been done in <em>ossia score</em>.
Here is a skeleton for how to write such a plug-in:</p>
<pre><code class="language-cpp">using message_to_ui = ...;
using message_to_engine = ...;

struct MyProcessor {
  // Receive a message on the processing thread from the UI
  void process_message(message_to_engine msg)
  {
    // 3. The engine received the message from the UI.
    //    It can for instance send a confirmation that the message has been received:
    send_message(message_to_ui{ ... });
  }

  // Send a message from the processing thread to the ui
  std::function&lt;void(message_to_ui)&gt; send_message;

  struct ui {
    // Define the UI here as seen previously.

    struct bus {
      // 1. Set up connections from UI widgets to the message bus
      void init(ui&amp; ui)
      {
        ui.some.widget.on_some_event = [&amp;] {
          // 2. Some action occured on the UI: this callback is called.
          //    We send a message to the engine: 
          this-&gt;send_message(message_to_engine{...});
        };
      }

      // Receive a message on the UI thread from the processing thread
      static void process_message(ui&amp; self, processor_to_ui msg)
      {
        // 4. The UI has received the confirmation from the engine, 
        //    we made a safe round-trip between our threads :-)
      }

      // Send a message from the ui to the processing thread
      std::function&lt;void(ui_to_processor)&gt; send_message;
    }
  };
}
</code></pre>
<p>Note that <code>message_to_ui</code> and <code>message_to_engine</code> can be any simple type:</p>
<ul>
<li>Ints, floats, strings, etc.</li>
<li><code>std::vector</code></li>
<li><code>std::variant</code></li>
<li>Any combination and nesting of those in an aggregate struct.</li>
</ul>
<p>For example, the following type will automatically be serialized &amp; deserialized:</p>
<pre><code class="language-cpp">struct ui_to_processor {
  int foo;
  std::string bar;
  std::variant&lt;float, double&gt; x;
  std::vector&lt;float&gt; y;
  struct {
    int x, y;
  } baz;
};
</code></pre>
<p>So far this has only been tested on a single computer but this could be tried over a network too.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-bus-example"><a class="header" href="#message-bus-example">Message bus example</a></h1>
<pre><code class="language-cpp">﻿#pragma once

/* SPDX-License-Identifier: GPL-3.0-or-later */

#include &lt;avnd/concepts/painter.hpp&gt;
#include &lt;avnd/concepts/processor.hpp&gt;
#include &lt;avnd/wrappers/controls.hpp&gt;
#include &lt;cmath&gt;
#include &lt;halp/audio.hpp&gt;
#include &lt;halp/controls.hpp&gt;
#include &lt;halp/custom_widgets.hpp&gt;
#include &lt;halp/layout.hpp&gt;
#include &lt;halp/meta.hpp&gt;

#include &lt;cstdio&gt;
#include &lt;variant&gt;

namespace examples::helpers
{
struct custom_button
{
  static constexpr double width() { return 100.; }
  static constexpr double height() { return 100.; }

  void paint(avnd::painter auto ctx)
  {
    ctx.set_stroke_color({200, 200, 200, 255});
    ctx.set_stroke_width(2.);
    ctx.set_fill_color({100, 100, 100, 255});
    ctx.begin_path();
    ctx.draw_rounded_rect(0., 0., width(), height(), 5);
    ctx.fill();
    ctx.stroke();

    ctx.set_fill_color({0, 0, 0, 255});
    ctx.begin_path();
    ctx.draw_text(20., 20., fmt::format("{}", press_count));
    ctx.fill();
  }

  bool mouse_press(double x, double y)
  {
    on_pressed();
    return true;
  }

  void mouse_move(double x, double y) { }

  void mouse_release(double x, double y) { }

  int press_count{0};

  std::function&lt;void()&gt; on_pressed = [] {};
};

/**
 * This example shows how communication through a thread-safe message
 * bus between the UI and the engine can be achieved.
 *
 * The data flow in the example does a complete round-trip
 * from the UI to the engine and back to the UI again:
 *
 * - When the button is clicked in the UI, it calls custom_button::on_pressed
 * - In the ui::bus::init this generates a message from this, sent through
 *   ui::bus::send_message.
 * - Behind the scene, the bindings serialize the message and ask the host to kindly
 *   pass it to the engine thread.
 * - Engine thread receives the deserialized message in MessageBusUi::process_message
 * - Engine thread sends a feedback to the ui through MessageBusUi::send_message
 * - Bindings transfer it back to the ui thread, ui::bus::process_message(ui, the_message)
 *   gets called
 *
 * To implement multiple messages one can simply use std::variant as the argument type:
 *
 *   std::variant&lt;message1, message2, etc...&gt;
 *
 * Note that you don't have to implement serialization manually:
 * as long as the messages are aggregates, things happen magically :-)
 *
 */
struct MessageBusUi
{
  static consteval auto name() { return "MessageBusUi example"; }
  static consteval auto c_name() { return "avnd_mbus_ui"; }
  static consteval auto uuid() { return "4ed8e7fd-a1fa-40a7-bbbe-13ee50044248"; }

  struct
  {
  } inputs;
  struct
  {
  } outputs;

  void operator()(int N) { }

  // Here are some message types. Their type names do not matter, only that they are
  // aggregates. What matters is that they are used as arguments to process_message.

  // This one will be serialized / deserialized as it is not a trivial type
  struct ui_to_processor
  {
    int foo;
    std::string bar;
    std::variant&lt;float, double&gt; x;
    std::vector&lt;float&gt; y;
    struct
    {
      int x, y;
    } baz;
  };

  // This one will be memcpy'd as it is a trivial type
  struct processor_to_ui
  {
    float bar;
    struct
    {
      int x, y;
    } baz;
  };

  // 1. Receive a message on the processing thread from the UI
  void process_message(const ui_to_processor&amp; msg)
  {
    fprintf(stderr, "Got message in processing thread !\n");
    send_message(processor_to_ui{.bar = 1.0, .baz{3, 4}});
  }

  // 2. Send a message from the processing thread to the ui
  std::function&lt;void(processor_to_ui)&gt; send_message;

  // Define our UI
  struct ui
  {
    halp_meta(layout, halp::layouts::container)
    halp_meta(width, 100)
    halp_meta(height, 100)

    struct
    {
      halp_meta(layout, halp::layouts::container)
      halp::custom_actions_item&lt;custom_button&gt; button{
          .x = 10, .y = 10
          // We'd like to define our callback here,
          // sadly C++ scoping rules do not allow it as soon as there is nesting
      };
    } foo;

    // Define the communication between UI and processor.
    struct bus
    {
      // 3. Set up connections
      void init(ui&amp; ui)
      {
        ui.foo.button.on_pressed = [&amp;] {
          fprintf(stderr, "Sending message from UI thread !\n");
          this-&gt;send_message(
              ui_to_processor{.foo = 123, .bar = "hiii", .x = 0.5f, .y = {1, 3, 5}});
        };
      }

      // 4. Receive a message on the UI thread from the processing thread
      static void process_message(ui&amp; self, processor_to_ui msg)
      {
        fprintf(stderr, "Got message in ui thread ! %d %d\n", msg.baz.x, msg.baz.y);
        self.foo.button.press_count++;
      }

      // 5. Send a message from the ui to the processing thread
      std::function&lt;void(ui_to_processor)&gt; send_message;
    };
  };
};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="feature-injection"><a class="header" href="#feature-injection">Feature injection</a></h1>
<blockquote>
<p>Supported bindings: all</p>
</blockquote>
<p>Many processors may require some kind of common, cross-cutting algorithm or system for their proper operation.</p>
<p>Processors can optionally declare a template argument, which will contain the implementations of these "cross-cutting concerns" supported by the backend.</p>
<p>For now, there are two:</p>
<ul>
<li>A logging system</li>
<li>An 1D FFT</li>
</ul>
<pre><code class="language-cpp">template&lt;typename Conf&gt;
// Get a compile error if the bindings cannot provide the thing.
requires (halp::has_fft_1d&lt;Conf, double&gt; &amp;&amp; halp::has_logger&lt;Conf&gt;)
struct MyProcessor {
  using logger = typename Conf::logger_type;
  using fft_type = typename Conf::template fft_type&lt;double&gt;;
};
</code></pre>
<p>This means that for instance, a processor can log to the Pd or Max console through <code>post(...)</code>, to stdout on Python, etc. and that they are relieved of the need to go look for an FFT algorithm.</p>
<p>Hosts like <em>ossia score</em> will be able to plug-in their own FFT implementation optimized for the platform on which the plug-in is running (and binaries will stop having 45 duplicate FFT implementations...).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging-feature"><a class="header" href="#logging-feature">Logging feature</a></h1>
<blockquote>
<p>Supported bindings: all</p>
</blockquote>
<p>The API is modeled after <a href="https://github.com/gabime/spdlog">spdlog</a> and expects the <a href="https://github.com/fmtlib/fmt">fmt</a> syntax:</p>
<pre><code class="language-cpp">#pragma once

/* SPDX-License-Identifier: GPL-3.0-or-later */

#include &lt;halp/log.hpp&gt;
#include &lt;halp/messages.hpp&gt;
#include &lt;halp/meta.hpp&gt;

// Sadly this example makes GCC segfault:
// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=102990
namespace examples::helpers
{
/**
 * This examples shows how things can look with a small helper
 * library to abstract common use cases.
 */
template &lt;typename C&gt;
requires
    // Here we pass template arguments as a primitive form of dependency injection.
    // Out effect is saying: "I want to be passed configured with a type
    // holding a "logger_type" typedef
    // which will be something matching the logger concept.
    halp::has_logger&lt;C&gt;
struct Logger
{
  // halp_meta is simply a macro that expands to a consteval function.
  // Hopefully C++ would use a similar syntax for reflexion.
  halp_meta(name, "Helpers")
  halp_meta(c_name, "avnd_helpers_logger")
  halp_meta(uuid, "3a646521-48f4-429b-a2b1-d67beb0d65cf")

  // We store our logger in the class to make things simpler.
  // no_unique_address makes sure that it stays a zero-memory-cost abstraction
  // if possible.
  [[no_unique_address]] typename C::logger_type logger;

  // Helpers for referring to local functions.
  // Ideally metaclasses would make that obsolete.
  void example(float x)
  {
    logger.trace("example: {}", x);
    logger.info("example: {}", x);
    logger.debug("example: {}", x);
    logger.warn("example: {}", x);
    logger.error("example: {}", x);
    logger.critical("example: {}", x);
  }

  struct
  {
    halp::func_ref&lt;"member", &amp;Logger&lt;C&gt;::example&gt; my_message;
  } messages;
};
}
</code></pre>
<blockquote>
<p>Avendish currently will look for <code>fmtlib</code> for its logger implementation, until <code>std::format</code> gets implemented by compiler authors.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fft-feature"><a class="header" href="#fft-feature">FFT feature</a></h1>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p>FFT operates on complex numbers ; you can expect a <code>real()</code> and <code>complex()</code> members.
Here is a simple example, which looks for the band with the most amplitude.</p>
<pre><code class="language-cpp">#pragma once
#include &lt;cmath&gt;
#include &lt;halp/audio.hpp&gt;
#include &lt;halp/controls.hpp&gt;
#include &lt;halp/fft.hpp&gt;
#include &lt;halp/meta.hpp&gt;

namespace examples::helpers
{

/**
 * This examples shows how one can get an FFT implementation to be
 * dependency-injected at compile-time. Check the Logger example for more explanations.
 *
 * The idea is that the host software / plugin wrapper will provide its own FFT implementation.
 * This way, we don't end up with 450 different FFT implementations in a single binary,
 * and the algorithm is abstracted from the actual way to compute the FFT which does not
 * matter - it could be FFTW, MKL, etc... depending on the licensing requirements
 * of the project, or be left up to the host which will instantiate the plug-in.
 */

template &lt;halp::has_fft_1d&lt;double&gt; C&gt;
struct PeakBand
{
  halp_meta(name, "Peak band")
  halp_meta(c_name, "avnd_peak_band")
  halp_meta(uuid, "5610b62e-ef1f-4a34-abe0-e57816bc44c2")

  struct
  {
    halp::audio_channel&lt;"In", double&gt; audio;
  } inputs;

  struct
  {
    halp::val_port&lt;"Peak", double&gt; peak;
    halp::val_port&lt;"Band", int&gt; band;
  } outputs;

  // Instantiate the FFT provided by the configuration.
  // Syntax is a bit ugly as we are already in a template
  // causing the need for the "::template " thing ; in C++23
  // it should be possible to omit typename.
  using fft_type = typename C::template fft_type&lt;double&gt;;
  fft_type fft;

  void prepare(halp::setup info)
  {
    // Initialize potential internal FFT buffers
    fft.reset(info.frames);
  }

  void operator()(int frames)
  {
    outputs.peak = 0.;

    // Process the fft
    auto cplx = fft.execute(inputs.audio.channel, frames);

    // Compute the band with the highest amplitude
    for(int k = 0; k &lt; frames / 2; k++)
    {
      const double mag_squared = std::norm(cplx[k]);
      if(mag_squared &gt; outputs.peak)
      {
        outputs.peak = mag_squared;
        outputs.band = k;
      }
    }

    outputs.peak = std::sqrt(outputs.peak);
  }
};

}
</code></pre>
<blockquote>
<p>Avendish currently provides a very simple and unoptimized FFT for the sake of testing. Contributions of bindings to more efficient FFT libraries are very welcome :-)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="presets"><a class="header" href="#presets">Presets</a></h1>
<blockquote>
<p>Supported bindings: VST</p>
</blockquote>
<p>An experimental presets feature has been prototyped for the Vintage back-end.</p>
<p>Here is how one may define presets:</p>
<pre><code class="language-cpp">// Our inputs
struct
{
  halp::hslider_f32&lt;"Preamp"&gt; preamp;
  halp::hslider_f32&lt;"Volume"&gt; volume;
} inputs;

// We define the type of our programs, like in the other cases
// it ends up being introspected automatically.
struct program {
  std::string_view name;
  decltype(Presets::inputs) parameters;
};

// Definition of the presets:
// Note: it's an array instead of a function because
// it's apparently hard to deduce N in array&lt;..., N&gt;, unlike in C arrays.
static constexpr const program programs[]{
    {.name{"Low gain"}, .parameters{.preamp = {0.3}, .volume = {0.6}}},
    {.name{"Hi gain"},  .parameters{.preamp = {1.0}, .volume = {1.0}}},
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sample-accurate-processing"><a class="header" href="#sample-accurate-processing">Sample-accurate processing</a></h1>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p>So far, we saw that control ports / parameters would have a single <code>value</code> member, which as one can expects,
stays constant for at least the entire duration of a tick.</p>
<p>However, some hosts (such as <a href="https://ossia.io">ossia score</a>) are able to give precise timestamps to control values.</p>
<p>If an algorithm supports this level of precision, it can be expressed by extending value ports in the following way:</p>
<pre><code class="language-cpp">struct { 
  static consteval auto name() { return "Control"; } 

  /* a value_map type */ values;
  float value; 
} control;
</code></pre>
<ul>
<li><code>value</code> will always carry the "running" value at the beginning of the tick, like before.</li>
<li><code>values</code> is a type which should be API-wise more-or-less compatible with <code>std::map&lt;int, type_of_value&gt;</code>.</li>
</ul>
<p>For every message received in the tick, <code>values</code> will be set (which means that they can also be empty if no message at all was received on that port).</p>
<p>There are actually three options for implementing <code>values</code>.</p>
<ul>
<li>
<p>Option A: <code>std::map&lt;int, float&gt; values</code>: the simplest case. Can be slow. A helper which uses <code>boost::small_flat_map</code> is provided: it provides neat performance and won't allocate unless the port is spammed.</p>
</li>
<li>
<p>Option B: <code>std::optional&lt;float&gt;* values;</code>: here, a <code>std::optional&lt;float&gt;</code> array of the same length than audio channels will be allocated. Indexing is the same than for audio samples.</p>
</li>
<li>
<p>Option C can only be used for inputs:</p>
</li>
</ul>
<pre><code class="language-cpp">struct timestamped_value {
  T value;
  int frame;
 };
  std::span&lt;timestamped_value&gt; values;
</code></pre>
<p>This is the most efficient storage if you expect to receive few values (and also the most "my device has extremely little RAM"-friendly one), however the ability to just do <code>values[frame_index]</code> is lost as the index now only goes up to the allocated messages (which can be zero if no message was received for this tick).</p>
<h1 id="helpers-5"><a class="header" href="#helpers-5">Helpers</a></h1>
<p>A single helper is provided for now: <code>halp::accurate&lt;T&gt;</code>.</p>
<p>It can be used like this to wrap an existing control type to add it a sample-accurate storage buffer:</p>
<pre><code>halp::accurate&lt;halp::val_port&lt;"Out", float&gt;&gt; my_port;
halp::accurate&lt;halp::knob_i32&lt;"Blah", int&gt;&gt; my_widget;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sample-accurate-processing-example"><a class="header" href="#sample-accurate-processing-example">Sample-accurate processing example</a></h1>
<pre><code class="language-cpp">#pragma once
#include &lt;avnd/concepts/audio_port.hpp&gt;
#include &lt;avnd/concepts/parameter.hpp&gt;
#include &lt;cmath&gt;
#include &lt;halp/audio.hpp&gt;
#include &lt;halp/controls.hpp&gt;
#include &lt;halp/meta.hpp&gt;
#include &lt;halp/sample_accurate_controls.hpp&gt;

namespace examples
{
struct SampleAccurateFilterExample
{
  halp_meta(name, "My sample-accurate filter");
  halp_meta(c_name, "sample_acc_filt");
  halp_meta(category, "Demo");
  halp_meta(author, "&lt;AUTHOR&gt;");
  halp_meta(description, "&lt;DESCRIPTION&gt;");
  halp_meta(uuid, "43818edd-63de-458b-a6a5-08033cefc051");

  /**
   * Here we define an input and an output pair.
   */
  struct
  {
    halp::accurate&lt;halp::val_port&lt;"In", float&gt;&gt; value;
  } inputs;

  struct
  {
    halp::accurate&lt;halp::val_port&lt;"Out", float&gt;&gt; value;
  } outputs;

  void operator()()
  {
    // The output is copied at the same timestamp at which each input happened.
    for(auto&amp; [timestamp, value] : inputs.value.values)
    {
      outputs.value.values[timestamp] = cos(value * value) * cos(value);
    }
  }
};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-channel-mimicking"><a class="header" href="#audio-channel-mimicking">Audio channel mimicking</a></h1>
<blockquote>
<p>Supported bindings: ossia, VST, Clap, Max/MSP</p>
</blockquote>
<p>As discussed when introducing audio ports, for the sake of simplicity, a processor with one input and one output audio bus, if it does not specify a specific channel count, is assumed to have as many input as it has output channels.</p>
<p>For instance, consider the following case:</p>
<pre><code class="language-cpp">struct
{
  halp::audio_input_bus&lt;"Main Input"&gt; audio;
} inputs;

struct
{
  halp::audio_output_bus&lt;"Output"&gt; audio;
} outputs;
</code></pre>
<p>Here, everything is fine: the host can send 1, 2, ... channels to the input, and Avendish will make sure that the audio output matches that.</p>
<p>Now imagine that we add another bus:</p>
<pre><code class="language-cpp">struct ins
{
  halp::audio_input_bus&lt;"Main Input"&gt; audio;
  halp::audio_input_bus&lt;"Sidechain"&gt; sidechain;
} inputs;

struct outs
{
  halp::audio_output_bus&lt;"Output"&gt; audio;
} outputs;
</code></pre>
<p>Even if for us, humans, it is reasonable to assume that there will be as many output channels, as there are in the main input, it is not something that a computer can assume that easily.</p>
<p>Thus, there is a way to indicate that a given port will use the same channel count as a specific input.</p>
<p>In raw terms, this is done by adding the following function in the output port definition:</p>
<pre><code class="language-cpp">static constexpr auto mimick_channel = &amp;ins::audio;
</code></pre>
<p>Taking the member function pointer to an input will allow Avendish to match the channel count at run-time.</p>
<p>An helper is provided: for instance, in the above case, it would give:</p>
<pre><code class="language-cpp">struct ins
{
  halp::audio_input_bus&lt;"Main Input"&gt; audio;
  halp::audio_input_bus&lt;"Sidechain"&gt; sidechain;
} inputs;

struct outs
{
  halp::mimic_audio_bus&lt;"Output", &amp;ins::audio&gt; audio;
} outputs;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workers"><a class="header" href="#workers">Workers</a></h1>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p>It is relatively common to require to perform some long-running work in a separate thread:
processing samples, etc.</p>
<p>Avendish provides two APIs for doing this: a general one, and a simpler one for the specific case of pre-processing
the data of a port (for instance when a file is loaded).</p>
<p>The general idea is that the processor code sends a request to the worker with some data.
The host processes the request in a thread. This returns a function which is then called back
onto the processor, to update its state with the result of the computations.</p>
<h2 id="general-worker-api-usage"><a class="header" href="#general-worker-api-usage">General worker API Usage</a></h2>
<p>In the main class, define a <code>worker</code> struct/instance ; the arguments can be anything.
Here we'll have a request that takes an <code>int, std::string</code> set of arguments ; to have multiple
behaviours one can use a std::variant of potential requests.</p>
<pre><code class="language-cpp">struct MyObject
{
  struct worker
  {
    // Called from DSP thread
    std::function&lt;void(int, std::string)&gt; request;

    // "work" is called from a worker thread
    static std::function&lt;void(MyObject&amp;)&gt; work(int, std::string);

    // The std::function object returned by work is called from the DSP thread
  } worker;
};
</code></pre>
<p>Here is how to use it:</p>
<pre><code class="language-cpp">// 1. Within the DSP thread:
void operator()(...) {
  if(something_happened) {
    this-&gt;worker.request(123, "foo");
  }
}

// 2. Implement the worker::work function:
std::function&lt;void(MyObject&amp;)&gt; MyObject::worker::work(int x, std::string foo)
{
  // 3. Implement the "threaded" work part:
  // This is executed in a separate worker thread, slow operations can be done here 
  // safely.

  // Repeat the string x times:
  std::string orig = foo;
  while(x &gt; 0) {
    foo += orig;
  }

  // 4. Return a function which will update the internal state of MyObject:
  return [str = std::move(foo)] (MyObject&amp; obj) {
    // Executed in the DSP thread again, so don't do long operations here!
    obj.internal_string = str;
  };
}
</code></pre>
<p>The astute reader will have noticed a fairly bad performance issue in the function above: we
are copying the entire string in the DSP thread! This is very bad.</p>
<p>How can that be improved?</p>
<pre><code class="language-cpp">// Sadly does not do anything as the object inside the lambda is const by default, 
// so this is still making a copy
return [str = std::move(foo)] (MyObject&amp; obj) {
  obj.internal_string = std::move(str);
};

// Adding mutable at least removes the copy... but there is still a performance issue!
return [str = std::move(foo)] (MyObject&amp; obj) mutable {
  obj.internal_string = std::move(str);
};

// Replacing the string even with std::move may call `free` on `obj.internal_string` 
// which is not a real-time-safe operation.
// Instead, if the data is swapped with the string variable in the lambda, 
// a well-written host will make sure that the lambda ends its lifetime outside of 
// the DSP thread, ensuring perfectly safe real-time operation.
return [str = std::move(foo)] (MyObject&amp; obj) mutable {
  std::swap(obj.internal_string, str);
};
</code></pre>
<p>A complete example is available here: <a href="https://github.com/ossia/score-addon-threedim/blob/main/Threedim/StructureSynth.hpp">https://github.com/ossia/score-addon-threedim/blob/main/Threedim/StructureSynth.hpp</a></p>
<h2 id="simple-threaded-port-processing-api-usage"><a class="header" href="#simple-threaded-port-processing-api-usage">Simple threaded port-processing API usage</a></h2>
<p>This API is a "simplified" version of the above one for the common case of wanting
to pre-process some data which was loaded from the hard drive.</p>
<p>It is accessed by adding the following to a port:</p>
<pre><code class="language-cpp">struct : my_file_port {
  static std::function&lt;void(MyObject&amp;)&gt; process(file_type data)
  {
    // 1. Process the raw file data. This happens in a worker thread.
    int N = long_operation(data);

    // 2. Return a function that will apply the change to the object.
    return [N] (MyObject&amp; obj) { 
      // Executed in the processing thread.
      obj.foo(N); 
    };
  }
} my_port;
</code></pre>
<p>A complete example is available here: <a href="https://github.com/ossia/score-addon-threedim/blob/main/Threedim/ObjLoader.hpp">https://github.com/ossia/score-addon-threedim/blob/main/Threedim/ObjLoader.hpp</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-with-cmake"><a class="header" href="#configuration-with-cmake">Configuration with CMake</a></h1>
<p>So far, the "building" side of things has been left under the carpet.</p>
<p>It is actually not very complicated.</p>
<p>We have:</p>
<ul>
<li>A processor, <code>MyProcessor</code>.</li>
<li>A binding for which we want to build this processor, for instance a Python or VST3 binding.</li>
</ul>
<p>What CMake does is that it generates a small <code>.cpp</code> file that combines both.</p>
<p>Here is for instance how it is done for Python:</p>
<pre><code class="language-cpp">/* SPDX-License-Identifier: GPL-3.0-or-later */

#include &lt;@AVND_MAIN_FILE@&gt;
#include &lt;avnd/binding/python/configure.hpp&gt;
#include &lt;avnd/binding/python/processor.hpp&gt;

PYBIND11_MODULE(py@AVND_C_NAME@, m)
{
  using type = decltype(avnd::configure&lt;python::config, @AVND_MAIN_CLASS@&gt;())::type;
  static const python::processor&lt; type &gt; instance{m};
}
</code></pre>
<p>Here, <code>AVND_MAIN_FILE</code>, <code>AVND_C_NAME</code> and <code>AVND_MAIN_CLASS</code> are options that are passed to CMake.
For an actual processor though, it's likely that you would have to write your own entrypoint.</p>
<p>Here is the Clap entrypoint, which is fairly similar:</p>
<pre><code class="language-cpp">/* SPDX-License-Identifier: GPL-3.0-or-later */

#include &lt;@AVND_MAIN_FILE@&gt;
#include &lt;avnd/binding/clap/audio_effect.hpp&gt;
#include &lt;avnd/binding/clap/configure.hpp&gt;

// clang-format off
using plug_type = decltype(avnd::configure&lt;avnd_clap::config, @AVND_MAIN_CLASS@&gt;())::type;
using effect_type = avnd_clap::SimpleAudioEffect&lt;plug_type&gt;;

AVND_EXPORTED_SYMBOL extern const struct clap_plugin_entry clap_plugin_entry = {
   CLAP_VERSION,
   +[] (const char* path) -&gt; bool { /* init */ return true; },
   +[] () { /* deinit */ },
   +[] (const char* factory_id) -&gt; const void* {
      static constexpr const clap_plugin_factory factory {
        .get_plugin_count = +[] (const struct clap_plugin_factory *factory) -&gt; uint32_t { /* count */ return 1; }
      , .get_plugin_descriptor =  +[] (const struct clap_plugin_factory *factory, uint32_t) -&gt; const clap_plugin_descriptor* { return &amp;effect_type::descriptor; }
      , .create_plugin = +[] (const struct clap_plugin_factory *factory, const clap_host_t *host, const char *plugin_id) -&gt; const clap_plugin_t* { return new effect_type{host}; }
      };
      if(!strcmp(factory_id,CLAP_PLUGIN_FACTORY_ID))
        return &amp;factory;
      return nullptr;
#if 0
   +[] () -&gt; uint32_t { return 0; };
   +[] (uint32_t) -&gt; const clap_plugin_invalidation_source* { return nullptr; };

   +[] () { /* refresh */ };
#endif
   }
};
</code></pre>
<h2 id="cmake-functions"><a class="header" href="#cmake-functions">CMake functions</a></h2>
<p>The CMake script currently provides pre-made integrations with the bindings we support.</p>
<p>There are helper functions that build every binding possible in one go:</p>
<pre><code class="language-cmake"># Create bindings for everything under the sun
avnd_make_all(...)

# Create bindings for general object-based systems: 
# - PureData, Max/MSP
# - Python
# - Ossia
# - Standalone demo examples
avnd_make_object(...)

# Create bindings for audio APIs: Vintage, VST3, Clap
avnd_make_audioplug(...)
</code></pre>
<p>Which just call the individual functions:</p>
<pre><code class="language-cmake">avnd_make_vst3(...)
avnd_make_pd(...)
avnd_make_max(...)
etc...
</code></pre>
<p>These functions all have the same syntax:</p>
<pre><code>avnd_make_all(
  # The CMake target:
  TARGET PerSampleProcessor2

  # The file to include to get a complete definition of the processor
  MAIN_FILE examples/Raw/PerSampleProcessor2.hpp

  # The C++ class name
  MAIN_CLASS examples::PerSampleProcessor2

  # A name to give for systems which depend on C-ish names for externals, like Max/MSP and PureData.
  C_NAME avnd_persample_2
)
</code></pre>
<h2 id="doing-it-by-hand"><a class="header" href="#doing-it-by-hand">Doing it by hand</a></h2>
<p>This is not very hard: Avendish is a header-only library, so you just have to add the <code>avendish/include</code> folder to your include path,
and the <code>-std=c++20</code> flag to your build-system.</p>
<blockquote>
<p>Depending on your compiler, you may also need to add flags such as <code>-fconcepts</code> (GCC &lt;= 9) ; <code>-fcoroutines</code> (GCC &lt;= 11) ; <code>-fcoroutines-ts</code> (Clang &lt;= 14).</p>
</blockquote>
<blockquote>
<p>Until the reflection TS gets merged, we have a dependency on Boost.PFR so you also need to include <code>boost</code>. Boost.PFR is header-only.</p>
</blockquote>
<blockquote>
<p>You also likely want to add <code>fmt</code> to get nice logging.</p>
</blockquote>
<p>Finally, we have to wrap our class with the binding.</p>
<pre><code class="language-cpp">// Defines struct MyProcessor { ... };
#include "MyProcessor.hpp"
#include "MyBinding.hpp"
// Set up those typedefs to provide services to plug-ins which need it
struct my_config {
   using logger_type = ...;
   using fft_1d_type = ...;
};

int main()
{
  // This will instantiate my_processor with the configuration passed as template argument if needed:
  using plug_type = decltype(avnd::configure&lt;my_config, my_processor&gt;())::type;

  // Finally create the binding object
  MyBinding&lt;plug_type&gt; the_binding;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gpu-based-draw-nodes"><a class="header" href="#gpu-based-draw-nodes">GPU-based draw nodes</a></h1>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p>The techniques shown so far for writing cross-system audio and media processors can be extended to the general ontology of "modern GPU pipeline",
in order to define API-independent GPU-based objects.</p>
<p>Here are some useful readings to get an idea of the problem space:</p>
<ul>
<li><a href="https://alain.xyz/blog/comparison-of-modern-graphics-apis">https://alain.xyz/blog/comparison-of-modern-graphics-apis</a></li>
<li><a href="https://www.qt.io/blog/qt-quick-on-vulkan-metal-direct3d">https://www.qt.io/blog/qt-quick-on-vulkan-metal-direct3d</a></li>
<li><a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/RHI/">https://docs.unrealengine.com/4.27/en-US/API/Runtime/RHI/</a></li>
<li><a href="https://zeux.io/2020/02/27/writing-an-efficient-vulkan-renderer/">https://zeux.io/2020/02/27/writing-an-efficient-vulkan-renderer/</a></li>
<li><a href="https://zeux.io/2020/02/27/writing-an-efficient-vulkan-renderer/">https://www.o3de.org/docs/atom-guide/dev-guide/rhi/</a></li>
</ul>
<p>What we are trying to do is define a declarative RHI (see Qt RHI, NVRHI, Unreal RHI, etc.): we do not want to call any API function
in order to preserve independence of the written nodes from the underlyling API: stating that one needs to allocate and upload a buffer prior to executing
a pipeline should not depend on any concrete GPU API and should be doable in the simplest possible way: the code
should be defined in terms of its absolute minimal requirements in order to enable it to work on the widest range of systems possible.</p>
<p>Just like we have done so far, we provide "helper types" which are entirely optional but can reduce wrist strain :-)
Bindings have zero dependency on any of the helper types and namespaces (<code>halp</code>, <code>gpp</code>) shown here -- everything depends on the shape of things.</p>
<h2 id="why-are-we-doing-this"><a class="header" href="#why-are-we-doing-this">Why are we doing this</a></h2>
<p>To reduce code duplication across projects which define visual plug-ins for media software:</p>
<ul>
<li>An <a href="https://github.com/resolume/ffgl/blob/master/source/plugins/AddSubtract/AddSubtract.cpp">FFGL plug-in</a></li>
<li>A <a href="https://git.sesse.net/?p=movit;a=blob;f=dither_effect.cpp;h=3fa6aebc3fa8f674674ca37e37ac6932be78c6fe;hb=HEAD">Movit plug-in</a></li>
<li><a href="https://github.com/MeridianPoint/TouchDesignerOpenGLTOP/blob/master/OpenGLTOP/OpenGLTOP.cpp">TouchDesigner TOPs</a></li>
<li>Max <a href="https://cycling74.com/sdk/max-sdk-8.0.3/html/chapter_jit_ob3dqs.html">jit.gl and OB3D objects</a></li>
<li>etc...</li>
</ul>
<p>which are all about the same thing: processing a fixed set of input and output data on the GPU and exposing this as a data flow node
with cute UI controls to the user.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ul>
<li>We assume a specific shader language (Vulkan-compatible GLSL 4.5), any ideas to improve this are welcome.</li>
<li>The only binding so far is being developed in <a href="https://ossia.io">ossia score</a> on top of the Qt RHI which inspired this quite a bit.</li>
</ul>
<h2 id="defining-a-primitive-pipeline-ontology"><a class="header" href="#defining-a-primitive-pipeline-ontology">Defining a primitive pipeline ontology</a></h2>
<p>A GPU pipeline carries much more information than the average audio object, as GPUs are pretty configurable and specialized systems, with various possible qualifications on their inputs and outputs that are unfamiliar to the programmer accustomed to working with a CPU.</p>
<p>The core of a GPU pipeline is the program that will run on it: a shader. Shaders are in themselves very similar to data-flow objects: they define inputs (often the mesh data, textures, and parameters to control the rendering) and outputs (often the color).</p>
<p>The pipeline may have multiple stages: most commonly and in an extremely broad and inaccurate way, the vertex stage positions triangles in the GPU API's coordinate system, and the fragment stage renders these triangles.</p>
<p>The pipeline has a layout: it is the definition of its inputs and outputs. For instance, such a layout may be:</p>
<ul>
<li>
<p>A <code>vec2</code> attribute input at location 0 representing each vertex's position.</p>
</li>
<li>
<p>A <code>vec4</code> attribute input at location 1 representing each vertex's color.</p>
</li>
<li>
<p>A texture at binding 0.</p>
</li>
<li>
<p>A buffer at binding 1 containing parameters for drawing the texture. For instance:</p>
</li>
</ul>
<pre><code class="language-glsl">uniform my_parameters {
  vec4 global_color;
  vec2 sun_position;
  float brightness;
};
</code></pre>
<p>The way it conceptually works is that, for each vertex of each triangle, the vertex shader is called with that vertex, plus the shared global parameters bound. Here is an example</p>
<pre><code class="language-glsl">// Input attributes
layout(location = 0) in vec3 position;
layout(location = 1) in vec4 color;

// Outputs of the vertex shader
layout(location = 0) out vec3 v_color;

// Where we tell the GPU at which position the current 
// fragment is.
out gl_PerVertex { vec4 gl_Position; };

// Shared parameters
layout(std140, binding = 0) uniform my_parameters {
  vec4 global_color;
  vec2 sun_position;
  float brightness;
};

// The actual vertex program
void main() 
{
  // Do some math that transforms pos's coordinates to show it where we want.
  vec4 pos = vec4(position.xt, 0.0, 1.);
  /* ... many matrix multiplications go here ... */
  gl_Position = pos;

  // Just copy the associated color directly to the next stage
  v_color = color;
}
</code></pre>
<p>Once this is done, the outputs of this stage are passed to the fragment shader, which
will end up computing the color that is to be shown on screen:</p>
<pre><code class="language-glsl">// Input of the fragment shader ; must be the same name, types and locations
// than the output of the vertex shader
layout(location = 0) in vec3 v_color;

// Output of the fragment shader: a color
layout(location = 0) out vec4 fragColor;

// Shared parameters ; must be the same name, types and locations
// than in the vertex shader
layout(std140, binding = 0) uniform my_parameters {
  vec4 global_color;
  vec2 sun_position;
  float brightness;
};

layout(binding = 1) uniform sampler2D tex;

// The actual fragment program
void main() {
  vec4 color = v_color
             + global_color
             + texture(tex, gl_FragCoord);

  fragColor = brightness * color;
}
</code></pre>
<p>The main problem is ensuring that the pipeline's layout as used from the C++ code matches the pipeline's layout as declared in the shader ; as every time there is an information duplication in a system, there is the possibility for errors there.</p>
<p>Here, we have duplication:</p>
<ul>
<li>Between the outputs of the vertex and the input of the fragment - some drivers and APIs are lenient regarding errors here, others are not.</li>
<li>In the C++ side, which must have some way to tell the GPU:
<ul>
<li>The first attribute  will be a vec2</li>
<li>The second attribute will be a vec4</li>
<li>The texture is bound at position 1</li>
<li>etc etc.</li>
</ul>
</li>
</ul>
<p>The idea is that we can use the same principles than saw before to define our layout through a C++ struct, and get our library to automatically generate the relevant inputs and outputs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-the-layout"><a class="header" href="#defining-the-layout">Defining the layout</a></h1>
<p>Defining the layout of a draw pipeline is fairly similar to defining the inputs and outputs of our nodes:</p>
<pre><code class="language-cpp">struct layout
{
  // Indicate that this is a layout for a graphics pipeline
  enum { graphics };

  struct vertex_input 
  {
    struct my_first_attribute { 
      // ...
    } my_first_attribute;

    struct my_second_attribute { 
      // ...
    } my_second_attribute;

    // etc...
  };

  struct vertex_output 
  {
    // ...
  };

  struct fragment_input 
  {
    // ...
  };
  struct fragment_output 
  {
    // ...
  };
  
  struct bindings 
  {
    struct my_ubo 
    {
      // ..
    } my_ubo;

    struct my_sampler 
    {
      // ..
    } my_sampler;
  };
};
</code></pre>
<h2 id="defining-attributes"><a class="header" href="#defining-attributes">Defining attributes</a></h2>
<p>An attribute is defined by the matching C++ data type.</p>
<p>For instance:</p>
<pre><code class="language-glsl">layout(location = 1) in vec3 v_pos;
</code></pre>
<p>is defined through the following C++ code:</p>
<pre><code class="language-cpp">struct {
  // Name of the variable in the shader
  static constexpr auto name() { return "v_pos"; }

  // Location
  static constexpr int location() { return 1; }
 
  // Optional standardized semantic usage for compatibility with usual engines
  enum { position };

  // Corresponding data type
  float data[3];
} my_first_attribute;
</code></pre>
<p>An helper macro is provided to reduce typing:</p>
<pre><code class="language-cpp">// location, name, type, meaning
gpp_attribute(1, v_pos, float[3], position) my_first_attribute;
</code></pre>
<h2 id="defining-samplers"><a class="header" href="#defining-samplers">Defining samplers</a></h2>
<p>Samplers are locations to which textures are bound during the execution of a pipeline.
They are defined in the <code>bindings</code> section of the <code>layout</code> struct.</p>
<p>For instance:</p>
<pre><code class="language-glsl">layout(binding = 2) uniform sampler2D my_tex;
</code></pre>
<p>is defined through:</p>
<pre><code class="language-cpp">struct bindings {
  struct { 
    // Name of the variable in the shader
    static constexpr auto name() { return "my_tex"; }
  
    // Location
    static constexpr int binding() { return 2; }
   
    // Type flag
    enum { sampler2D };  
  } my_sampler;
};
</code></pre>
<p>or the helper version:</p>
<pre><code class="language-cpp">struct bindings {
  gpp::sampler&lt;"my_tex", 2&gt;  my_sampler;
};
</code></pre>
<h2 id="defining-uniform-buffers"><a class="header" href="#defining-uniform-buffers">Defining uniform buffers</a></h2>
<pre><code class="language-glsl">layout(std140, binding = 2) uniform my_params {
  vec2 coords;
  float foo;
};
</code></pre>
<p>is defined as follows:</p>
<pre><code class="language-cpp">struct bindings {
  struct custom_ubo {
    static constexpr auto name() { return "my_params"; }
    static constexpr int binding() { return 2; }
    enum { std140, ubo };
  
    struct {
      static constexpr auto name() { return "coords"; }
      float value[2];
    } coords;
  
    struct
    {
      static constexpr auto name() { return "foo"; }
      float value;
    } foo;
  } ubo;
};
</code></pre>
<p>And can be refactored a bit to:</p>
<pre><code class="language-cpp">struct bindings {
  struct {
    halp_meta(name, "my_params");
    halp_meta(binding, 2);
    halp_flags(std140, ubo);
  
    gpp::uniform&lt;"coords", float[2]&gt; coords;
    gpp::uniform&lt;"foo", float&gt; foo;
  } ubo;
};
</code></pre>
<p>Note that this is only used as a way to enable us to synthesize the UBO layout in the shader.
In particular, depending on the types used, the GLSL variable packing rules are sometimes different than the C++ ones,
thus we cannot just send this struct as-is to GPU memory. Maybe when metaclasses happen one will be able to write something
akin to:</p>
<pre><code class="language-cpp">std140_struct { ... } ubo;
</code></pre>
<blockquote>
<p>Note that not everything GLSL feature is supported yet, but is on the roadmap: arrays, ssbos, sampler2DShadow, etc...
Contributions welcome !</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-calls"><a class="header" href="#api-calls">API calls</a></h1>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p>In general, programming for the GPU involves some level of calling into a graphics API: OpenGL, Vulkan, Metal, or various abstractions on top of them such as the Qt, Unreal, etc... RHIs, libraries such as BGFX, etc.</p>
<p>Like every non-declarative code, this has the sad side-effect of tying you to said library ; it's pretty hard to migrate to, say, Qt's RHI to pure OpenGL or BGFX.
Here, we propose a method that aims to keep the algorithms reusable by having them state their needs without making any API calls.</p>
<p>The API comes with three optional methods that can be implemented in your processor to control behaviour for now:</p>
<pre><code class="language-cpp">// Allocates ressources and sends data from the CPU to the GPU.
// This method *must* be implemented if there are uniforms or samplers that 
// aren't bound to ports (and the pipeline wouldn't be very useful otherwise)
/* ??? */ update();

// Releases allocated ressources
// This method must take care of releasing anything allocated in update()
/* ??? */ release();

// Submit a draw call. If not implemented a default draw call will be done 
// for the mesh in input of the node.
/* ??? */ draw();
</code></pre>
<h2 id="defining-a-call"><a class="header" href="#defining-a-call">Defining a call</a></h2>
<p>Here is how an <code>update()</code> method which allocates and update a texture may look:</p>
<pre><code class="language-cpp">gpp::texture_handle tex_handle{};

gpp::co_update update()
{
    int sz = 16*16*4;
    // If the texture hasn't been allocated yet
    if(!tex_handle)
    {
      // Request an allocation
      this-&gt;tex_handle = co_yield gpp::texture_allocation{
          .binding = 0
        , .width = 16
        , .height = 16
      };
    }

    // Generate some data
    tex.resize(sz);
    for(int i = 0; i &lt; sz; i++)
      tex[i] = rand();

    // Upload it to the GPU
    co_yield gpp::texture_upload{
        .handle = tex_handle
      , .offset = 0
      , .size = sz
      , .data = tex.data()
    };
  }
}
</code></pre>
<h2 id="commands"><a class="header" href="#commands">Commands</a></h2>
<p>Note that there isn't any direct API call here. Instead, we return user-defined structs:
for instance, <code>texture_allocation</code> is simply defined like this:</p>
<pre><code class="language-cpp">struct texture_allocation
{
  // Some keywords to allow the command to be matched to an API call
  enum { allocation, texture };

  // What this call is supposed to return
  using return_type = texture_handle;

  // Parameters of the command
  int binding;
  int width;
  int height;
};
</code></pre>
<p>The actual concrete type does not matter: the only important thing is for the following to be possible with the returned struct <code>C</code>:</p>
<pre><code class="language-cpp">// Identify the command
C::allocation; 
C::texture;

// Create a return value
typename C::return_type ret;

// Access the parameters of the call
void f(C&amp; command) {
  int b = command.binding;
  int w = command.weight;
  int h = command.height;
  // etc.
}
</code></pre>
<p>This allows complete independence from the graphics API, as a node only specifies exactly the allocation / update / draw calls it needs to do in the most generic possible way ; for instance, a node that only allocates and uploads a texture should be easily bindable to any graphics API on earth.</p>
<p>An in-progress set of common commands is provided.</p>
<h2 id="coroutines"><a class="header" href="#coroutines">Coroutines</a></h2>
<p>To allow this to work, <code>gpp::co_update</code> is a coroutine type.
Here too, the binding code does not depend on the concrete type of the coroutine ; only that it matches a concept.</p>
<p><code>gpp::co_update</code> is defined as:</p>
<pre><code class="language-cpp">// All the possible commands that can be used in update()
using update_action = std::variant&lt;
  static_allocation, static_upload,
  dynamic_vertex_allocation, dynamic_vertex_upload, buffer_release,
  dynamic_index_allocation, dynamic_index_upload,
  dynamic_ubo_allocation, dynamic_ubo_upload, ubo_release,
  sampler_allocation, sampler_release,
  texture_allocation, texture_upload, texture_release,
  get_ubo_handle
&gt;;

// What the commands are allowed to return
using update_handle = std::variant&lt;std::monostate, buffer_handle, texture_handle, sampler_handle&gt;;

// Definition of the update() coroutine type
using co_update = gpp::generator&lt;update_action, update_handle&gt;;
</code></pre>
<p>Where <code>gpp::generator</code> is a type similar to <code>std::generator</code> which is not available yet in C++20 but will be in C++23.</p>
<h2 id="benefits-of-the-approach"><a class="header" href="#benefits-of-the-approach">Benefits of the approach</a></h2>
<p>This has interesting benefits besides the separation of concern which is achieved:</p>
<ol>
<li>It allows to restrict what kind of call can be done in which function.
For instance, the Qt RHI forbids uploading data during a draw operation: the coroutine type for <code>draw</code> does not contain
the update commands, which allows to enforce this at compile-time. Yay C++ :-)</li>
</ol>
<p>A node which only ever uploads textures could optimize a little bit by defining instead:</p>
<pre><code class="language-cpp">using update_action = std::variant&lt;texture_allocation, texture_upload, texture_release&gt;;
using update_handle = std::variant&lt;std::monostate, texture_handle&gt;;

using my_co_update = gpp::generator&lt;update_action, update_handle&gt;;
</code></pre>
<blockquote>
<p>Of course, we would love this to be performed automatically as part of compiler optimizations... it seems that the science is not there yet though !</p>
</blockquote>
<ol start="2">
<li>
<p>This gives some amount of named-parameter-ness for GPU API calls which is also a good way to reduce bugs :-)</p>
</li>
<li>
<p>As no "library" functions are called, the possibility to have ODR issues due to multiple function definitions is less likely, and can trivially be solved by wrapping the entirety of the user-provided code and command definitions in a custom namespace as the namespaces do not matter at all.</p>
</li>
</ol>
<h1 id="how-does-it-work-"><a class="header" href="#how-does-it-work-">How does it work ??</a></h1>
<p>It's very simple: the code which invokes <code>update()</code> more-or-less looks like this:</p>
<pre><code class="language-cpp">void invoke_update()
{
  if constexpr(requires { node.update(); })
  {
    for (auto&amp; promise : node.update())
    {
      promise.result = visit(update_handler{}, promise.command);
    }
  }
}
</code></pre>
<p>where <code>update_handler</code> looks like:</p>
<pre><code class="language-cpp">struct update_handler
{
  template&lt;typename C&gt;
  auto operator()(C command) {
    if constexpr(requires { C::allocation; })
    {
      if constexpr(requires { C::texture; })
        my_gpu_api_allocate_texture(command.width, command.height);
      else if constexpr(requires { C::ubo; })
        my_gpu_api_allocate_buffer(command.size);
      else ...
    }
    else ...
  }
};
</code></pre>
<p>One can check that given the amount of abstraction involved, the compiler can still generate <a href="https://gcc.godbolt.org/z/rcqT91d7f">reasonable amounts of code</a> for this (when provided with a decent std::variant implementation :p).</p>
<blockquote>
<p>Note that the implementation does not depend on the variant type being <code>std::variant</code> -- I also tested with <code>boost.variant2</code> and <code>mpark::variant</code> which follow the same concepts.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minimal-shaders"><a class="header" href="#minimal-shaders">Minimal shaders</a></h1>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p>Sometimes only very simple fragment shaders are needed.</p>
<p>In this case, one can omit all the functions and most of the pipeline layout,
and only define for instance an UBO, samplers and a fragment shader.</p>
<pre><code class="language-cpp">#pragma once
#include &lt;gpp/commands.hpp&gt;
#include &lt;gpp/layout.hpp&gt;
#include &lt;gpp/meta.hpp&gt;
#include &lt;gpp/ports.hpp&gt;
#include &lt;halp/controls.hpp&gt;

namespace examples
{
struct GpuSolidColorExample
{
  halp_meta(name, "Solid color");
  halp_meta(uuid, "c9a5fd8e-b66e-41ff-8feb-bca2cdab4990");
  halp_meta(category, "Visuals/Textures")
  halp_meta(c_name, "solid_color")
  halp_meta(author, "Jean-Michaël Celerier")
  halp_meta(
      manual_url,
      "https://ossia.io/score-docs/processes/"
      "graphics-utilities.html#solid-color")
  halp_meta(description, "Render a solid color")

  struct layout
  {
    enum
    {
      graphics
    };

    // Here we only need a fragment output
    struct fragment_output
    {
      gpp_attribute(0, fragColor, float[4])
      fragColor;
    } fragment_output;

    // We define one UBO with a vec4: our solid color
    struct bindings
    {
      struct custom_ubo
      {
        halp_meta(name, "custom");
        halp_meta(binding, 0);
        halp_flags(std140, ubo);

        gpp::uniform&lt;"color", float[4]&gt; col;
      } ubo;
    };
  };

  struct
  {
    // Make this uniform visible as a port
    gpp::uniform_control_port&lt;
        halp::color_chooser&lt;"Color"&gt;, &amp;layout::bindings::custom_ubo::col&gt;
        color;
  } inputs;

  struct
  {
    // Make an output port from the fragment output
    gpp::color_attachment_port&lt;"Color output", &amp;layout::fragment_output&gt; out;
  } outputs;

  // Trivial fragment shader
  std::string_view fragment()
  {
    return R"_(
void main() {
  fragColor = color;
}
)_";
  }
};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="draw-example"><a class="header" href="#draw-example">Draw example</a></h1>
<p>This example draw a triangle with two controls.</p>
<ul>
<li>One control is an uniform exposed directly to the object.</li>
<li>Another is a CPU-only control which the author of the node then maps to another uniform in a custom way.</li>
<li>The texture also comes from the node's code.</li>
</ul>
<pre><code class="language-cpp">#pragma once
#include &lt;avnd/common/member_reflection.hpp&gt;
#include &lt;cmath&gt;
#include &lt;gpp/commands.hpp&gt;
#include &lt;gpp/meta.hpp&gt;
#include &lt;gpp/ports.hpp&gt;
#include &lt;halp/controls.hpp&gt;
#include &lt;halp/static_string.hpp&gt;
namespace examples
{

struct GpuFilterExample
{
  halp_meta(name, "Helpers GPU pipeline");
  halp_meta(uuid, "ebe6f07a-5e7f-4cf8-bd2b-e5dc3e22a1f9");

  // Define the layout of our pipeline in C++ simply through the structure of a struct
  static constexpr struct layout
  {
    halp_flags(graphics);
    struct vertex_input
    {
      gpp_attribute(0, v_position, float[3], position)
      pos;
      gpp_attribute(1, v_texcoord, float[2], texcoord)
      tex;
    } vertex_input;

    struct vertex_output
    {
      gpp_attribute(0, texcoord, float[2], texcoord)
      tex;
      gpp::vertex_position_out position;
    } vertex_output;

    struct fragment_input
    {
      gpp_attribute(0, texcoord, float[2], texcoord)
      tex;
    } fragment_input;

    struct fragment_output
    {
      gpp_attribute(0, fragColor, float[4], color)
      col;
    } fragment_output;

    // Define the ubos, samplers, etc.
    struct bindings
    {
      struct custom_ubo
      {
        halp_meta(name, "custom");
        halp_flags(std140, ubo);

        static constexpr int binding() { return 0; }

        gpp::uniform&lt;"foo", float[2]&gt; pad;
        gpp::uniform&lt;"bar", float&gt; slider;
      } ubo;

      gpp::sampler&lt;"tex", 1&gt; texture_input;
    } bindings;
  } lay{};
  using bindings = decltype(layout::bindings);
  using uniforms = decltype(bindings::ubo);

  struct
  {
    // If samplers &amp; buffers are referenced here the GPU side of things
    // will be automatically allocated as they are expect to come from "outside"
    gpp::uniform_control_port&lt;halp::hslider_f32&lt;"Alpha"&gt;, &amp;uniforms::slider&gt; bright;

    // It's also possible to have purely CPU-side controls to manage e.g. texture sizes, etc...
    halp::hslider_f32&lt;"Other"&gt; other;
  } inputs;

  struct
  {
    gpp::color_attachment_port&lt;"Main out", &amp;layout::fragment_output::col&gt; fragColor;
  } outputs;

  std::string_view vertex()
  {
    return R"_(
void main()
{
  texcoord = v_texcoord;
  gl_Position = vec4(v_position.x / 3., v_position.y / 3, 0.0, 1.);
}
)_";
  }

  std::string_view fragment()
  {
    return R"_(
void main()
{
  fragColor = vec4(texture(tex, texcoord.xy * foo).rgb, bar) ;
}
)_";
  }

  gpp::co_update update()
  {
    // In this example we test the automatic UBO filling with the inputs declared above.

    // Here the surrounding environment makes sure that the UBO already has a handle
    auto ubo = co_yield gpp::get_ubo_handle{.binding = lay.bindings.ubo.binding()};

    // Upload some data into it, using an input (non-uniform) of our node
    using namespace std;
    float xy[2] = {cos(inputs.other), sin(inputs.other)};

    co_yield gpp::dynamic_ubo_upload{
        .handle = ubo, .offset = 0, .size = sizeof(xy), .data = &amp;xy};

    // The sampler is not used by the inputs block, so we have to allocate it ourselves
    int sz = 16 * 16 * 4;
    if(!tex_handle)
    {
      this-&gt;tex_handle = co_yield gpp::texture_allocation{
          .binding = lay.bindings.texture_input.binding(), .width = 16, .height = 16};
    }

    // And upload some data
    tex.resize(sz);
    for(int i = 0; i &lt; sz; i++)
      tex[i] = rand();

    co_yield gpp::texture_upload{
        .handle = tex_handle, .offset = 0, .size = sz, .data = tex.data()};
  }

  gpp::co_release release()
  {
    if(tex_handle)
    {
      co_yield gpp::texture_release{.handle = tex_handle};
      tex_handle = nullptr;
    }
  }

private:
  std::vector&lt;uint8_t&gt; tex;
  gpp::texture_handle tex_handle{};
};

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compute-nodes"><a class="header" href="#compute-nodes">Compute nodes</a></h1>
<blockquote>
<p>Supported bindings: ossia</p>
</blockquote>
<p>Compute is simpler than draw, as the pipeline only has one shader (the compute shader).
Instead of <code>draw</code>, the method in which to run compute dispatch calls is called <code>dispatch</code>.</p>
<p>Here is an example:</p>
<pre><code class="language-cpp">#pragma once
#include &lt;avnd/common/member_reflection.hpp&gt;
#include &lt;fmt/format.h&gt;
#include &lt;fmt/printf.h&gt;
#include &lt;gpp/commands.hpp&gt;
#include &lt;gpp/meta.hpp&gt;
#include &lt;gpp/ports.hpp&gt;
#include &lt;halp/controls.hpp&gt;
#include &lt;halp/static_string.hpp&gt;

#include &lt;vector&gt;
namespace examples
{

struct GpuComputeExample
{
  // halp_meta is a short hand for defining a static function:
  // #define halp_meta(name, val) static constexpr auto name() return { val; }
  halp_meta(name, "Average color");
  halp_meta(uuid, "03bce361-a2ca-4959-95b4-6aac3b6c07b5");
  halp_meta(category, "Visuals/Analysis")
  halp_meta(c_name, "average_color")
  halp_meta(author, "Jean-Michaël Celerier")
  halp_meta(
      manual_url,
      "https://ossia.io/score-docs/processes/"
      "computer-vision-utilities.html#average-color")
  halp_meta(description, "Extract the average color of an input video feed")

  static constexpr int downscale = 16;

  // Define the layout of our pipeline in C++ simply through the structure of a struct
  struct layout
  {
    halp_meta(local_size_x, 16)
    halp_meta(local_size_y, 16)
    halp_meta(local_size_z, 1)
    halp_flags(compute);

    struct bindings
    {
      // Each binding is a struct member
      struct
      {
        halp_meta(name, "my_buf");
        halp_meta(binding, 0);
        halp_flags(std140, buffer, load, store);

        using color = float[4];
        gpp::uniform&lt;"result", color*&gt; values;
      } my_buf;

      // Define the members of our ubos
      struct custom_ubo
      {
        halp_meta(name, "custom");
        halp_meta(binding, 1);
        halp_flags(std140, ubo);

        gpp::uniform&lt;"width", int&gt; width;
        gpp::uniform&lt;"height", int&gt; height;
      } ubo;

      struct
      {
        halp_meta(name, "img")
        halp_meta(format, "rgba32f")
        halp_meta(binding, 2);
        halp_flags(image2D, readonly);
      } image;
    } bindings;
  };

  using bindings = decltype(layout::bindings);
  using uniforms = decltype(bindings::ubo);

  // Definition of our ports which will get parsed by the
  // software that instantiate this class
  struct
  {
    // Here we use some helper types in the usual fashion
    gpp::image_input_port&lt;"Image", &amp;bindings::image&gt; tex;

    gpp::uniform_control_port&lt;
        halp::hslider_i32&lt;"Width", halp::range{1, 1000, 100}&gt;, &amp;uniforms::width&gt;
        width;

    gpp::uniform_control_port&lt;
        halp::hslider_i32&lt;"Height", halp::range{1, 1000, 100}&gt;, &amp;uniforms::height&gt;
        height;
  } inputs;

  // The output port on which we write the average color
  struct
  {
    struct
    {
      halp_meta(name, "color")
      float value[4];
    } color_out;
  } outputs;

  std::string_view compute()
  {
    return R"_(
void main()
{
  // Note: the algorithm is most likely wrong as I know FUCK ALL
  // about compute shaders ; fixes welcome ;p

  ivec2 call = ivec2(gl_GlobalInvocationID.xy);
  vec4 color = vec4(0.0, 0.0,0,0);

  for(int i = 0; i &lt; gl_WorkGroupSize.x; i++)
  {
    for(int j = 0; j &lt; gl_WorkGroupSize.y; j++)
    {
      uint x = call.x * gl_WorkGroupSize.x + i;
      uint y = call.y * gl_WorkGroupSize.y + j;

      if (x &lt; width &amp;&amp; y &lt; height)
      {
        color += imageLoad(img, ivec2(x,y));
      }
    }
  }

  if(gl_LocalInvocationIndex &lt; ((width * height) / gl_WorkGroupSize.x * gl_WorkGroupSize.y))
  {
    result[gl_GlobalInvocationID.y * gl_WorkGroupSize.x + gl_GlobalInvocationID.x] = color;
  }
}
)_";
  }

  // Allocate and update buffers
  gpp::co_update update()
  {
    // Deallocate if the size changed
    const int w = this-&gt;inputs.width / downscale;
    const int h = this-&gt;inputs.height / downscale;

    if(last_w != w || last_h != h)
    {
      if(this-&gt;buf)
      {
        co_yield gpp::buffer_release{.handle = buf};
        buf = nullptr;
      }
      last_w = w;
      last_h = h;
    }

    if(w &gt; 0 &amp;&amp; h &gt; 0)
    {
      // No buffer: reallocate
      const int bytes = w * h * sizeof(float) * 4;
      if(!this-&gt;buf)
      {
        this-&gt;buf = co_yield gpp::static_allocation{
            .binding = lay.bindings.my_buf.binding(), .size = bytes};
      }
    }
  }

  // Relaease allocated data
  gpp::co_release release()
  {
    if(buf)
    {
      co_yield gpp::buffer_release{.handle = buf};
      buf = nullptr;
    }
  }

  // Do the GPU dispatch call
  gpp::co_dispatch dispatch()
  {
    if(!buf)
      co_return;

    const int w = this-&gt;inputs.width / downscale;
    const int h = this-&gt;inputs.height / downscale;
    const int downscaled_pixels_count = w * h;
    const int bytes = downscaled_pixels_count * sizeof(float) * 4;

    // Run a pass
    co_yield gpp::begin_compute_pass{};

    co_yield gpp::compute_dispatch{.x = 1, .y = 1, .z = 1};

    // Request an asynchronous readback
    gpp::buffer_awaiter readback
        = co_yield gpp::readback_buffer{.handle = buf, .offset = 0, .size = bytes};

    co_yield gpp::end_compute_pass{};

    // The readback can be fetched once the compute pass is done
    // (this needs to be improved in terms of asyncness)
    auto [data, size] = co_yield readback;

    using color = float[4];
    auto flt = reinterpret_cast&lt;const color*&gt;(data);

    // finish summing on the cpu
    auto&amp; final = outputs.color_out.value;

    final[0] = 0.f;
    final[1] = 0.f;
    final[2] = 0.f;
    final[3] = 0.f;

    for(int i = 0; i &lt; downscaled_pixels_count; i++)
    {
      for(int j = 0; j &lt; 4; j++)
      {
        final[j] += flt[i][j];
      }
    }

    final[0] /= downscaled_pixels_count;
    final[1] /= downscaled_pixels_count;
    final[2] /= downscaled_pixels_count;
    final[3] /= downscaled_pixels_count;
  }

private:
  static constexpr auto lay = layout{};
  int last_w{}, last_h{};
  gpp::buffer_handle buf{};
  std::vector&lt;float&gt; zeros{};
};

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-predicates-and-introspection"><a class="header" href="#type-predicates-and-introspection">Type predicates and introspection</a></h1>
<p>The core enabler of Avendish is the ability to filter struct definitions according to predicates.</p>
<p>That is, given:</p>
<pre><code class="language-cpp">struct Foo {
  int16_t x;
  float y;
  int32_t z;
  std::string txt;        
};
</code></pre>
<p>we want to filter for instance all integral types, and get:</p>
<pre><code class="language-cpp">tuple&lt;int16_t, int32_t&gt; filtered = filter_integral_types(Foo{});
</code></pre>
<p>or run code on the members and other similar things.</p>
<h2 id="fields-introspection"><a class="header" href="#fields-introspection">Fields introspection</a></h2>
<p>The template <code>fields_introspection&lt;T&gt;</code> allows to introspect the fields of a struct in a generic way.</p>
<h3 id="doing-something-for-each-member-of-a-struct-without-an-instance"><a class="header" href="#doing-something-for-each-member-of-a-struct-without-an-instance">Doing something for each member of a struct without an instance</a></h3>
<pre><code class="language-cpp">fields_instrospection&lt;T&gt;::for_all(
    [] &lt;std::size_t Index, typename T&gt; (avnd::field_reflection&lt;Index, T&gt;) {
      // Index is the index of the struct member, e.g. 1 for y in the above example
      // T is the type of the struct member
});
</code></pre>
<h3 id="doing-something-for-each-member-of-a-struct-with-an-instance"><a class="header" href="#doing-something-for-each-member-of-a-struct-with-an-instance">Doing something for each member of a struct with an instance</a></h3>
<pre><code class="language-cpp">Foo foo;
fields_instrospection&lt;T&gt;::for_all(
    foo,
    [] &lt;typename T&gt; (T&amp; t) {
      // t will be x, y, z, txt.
});
</code></pre>
<h3 id="doing-something-for-the-nth-member-of-a-struct-without-an-instance"><a class="header" href="#doing-something-for-the-nth-member-of-a-struct-without-an-instance">Doing something for the Nth member of a struct without an instance</a></h3>
<p>This function lifts a run-time index into a compile-time value.
This is useful for instance for mapping a run-time parameter id coming from a DAW,
into a field, such as when a parameter changes.</p>
<pre><code class="language-cpp">fields_instrospection&lt;T&gt;::for_nth(
    index,
    [] &lt;std::size_t Index, typename T&gt; (avnd::field_reflection&lt;Index, T&gt;) {
      // Index is the index of the struct member, e.g. 1 for y in the above example
      // T is the type of the struct member
});
</code></pre>
<h3 id="doing-something-for-each-member-of-a-struct-with-an-instance-1"><a class="header" href="#doing-something-for-each-member-of-a-struct-with-an-instance-1">Doing something for each member of a struct with an instance</a></h3>
<p>Same as above but with an actual instance.</p>
<pre><code class="language-cpp">Foo foo;
fields_instrospection&lt;T&gt;::for_nth(
    foo,
    index,
    [] &lt;typename T&gt; (T&amp; t) {
      // t will be x, y, z, txt.
});
</code></pre>
<h3 id="getting-the-index-of-a-member-pointer"><a class="header" href="#getting-the-index-of-a-member-pointer">Getting the index of a member pointer</a></h3>
<pre><code class="language-cpp">Foo foo;
avnd::index_in_struct(foo, &amp;Foo::z) == 2;

</code></pre>
<h2 id="predicate-introspection"><a class="header" href="#predicate-introspection">Predicate introspection</a></h2>
<p>The type <code>predicate_introspection&lt;T, Pred&gt;</code> allows similar operations on a filtered subset of the struct members.</p>
<p>For instance, given the predicate:</p>
<pre><code class="language-cpp">template&lt;typename Field&gt;
using is_int&lt;Field&gt; = std::integral_constant&lt;bool, std::is_integral_v&lt;Field&gt;&gt;;
</code></pre>
<p>then</p>
<pre><code class="language-cpp">using ints = predicate_introspection&lt;Foo, is_int&gt;;
</code></pre>
<p>will allow to query all the <code>int16_t</code> and <code>int32_t</code> members of the struct.
This example is assumed for all the cases below.</p>
<p><code>predicate_introspection&lt;Foo, is_int&gt;</code> will work within this referential: indices will refer to
these types. That is, the element 0 will be <code>int16_t</code> and element 1 will be <code>int32_t</code>.
Multiple methods are provided to go from and to indices in the complete struct, to indices in the filtered version:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>member</td><td>x</td><td>y</td><td>z</td><td>txt</td></tr>
<tr><td>field index</td><td>0</td><td>1</td><td>2</td><td>3</td></tr>
<tr><td>filtered index</td><td>0</td><td>-</td><td>1</td><td>-</td></tr>
</tbody></table>
</div>
<h3 id="doing-something-for-each-member-of-a-struct-without-an-instance-1"><a class="header" href="#doing-something-for-each-member-of-a-struct-without-an-instance-1">Doing something for each member of a struct without an instance</a></h3>
<pre><code class="language-cpp">predicate_instrospection&lt;T, P&gt;::for_all(
    [] &lt;std::size_t Index, typename T&gt; (avnd::field_reflection&lt;Index, T&gt;) {
        // Called for x, z
        // Index is 0 for x, 1 for z
});
</code></pre>
<h3 id="doing-something-for-each-member-of-a-struct-with-an-instance-2"><a class="header" href="#doing-something-for-each-member-of-a-struct-with-an-instance-2">Doing something for each member of a struct with an instance</a></h3>
<pre><code class="language-cpp">Foo foo;
predicate_instrospection&lt;T, P&gt;::for_all(
    foo,
    [] &lt;typename T&gt; (T&amp; t) {
      // Called for x, z
});
</code></pre>
<pre><code class="language-cpp">// This version also passes the compile-time index
Foo foo;
predicate_instrospection&lt;T, P&gt;::for_all_n(
    foo,
    [] &lt;std::size_t Index, typename T&gt; (T&amp; t, avnd::predicate_index&lt;Index&gt;) {
      // x: Index == 0
      // y: Index == 1
});
</code></pre>
<pre><code class="language-cpp">// This version passes both the field index and the filtered index
Foo foo;
predicate_instrospection&lt;T, P&gt;::for_all_n(
    foo,
    [] &lt;std::size_t LocalIndex, std::size_t FieldIndex, typename T&gt; (T&amp; t, avnd::predicate_index&lt;LocalIndex&gt;, avnd::field_index&lt;FieldIndex&gt;) {
      // x: LocalIndex == 0 ; FieldIndex == 0
      // y: LocalIndex == 1 ; FieldIndex == 2
});
</code></pre>
<pre><code class="language-cpp">// This version will return early if the passed lambda returns false
Foo foo;
bool ok = predicate_instrospection&lt;T, P&gt;::for_all_unless(
    foo,
    [] &lt;typename T&gt; (T&amp; t) -&gt; bool {
      return some_condition(t);
});
</code></pre>
<h3 id="doing-something-for-the-nth-member-of-a-struct-without-an-instance-1"><a class="header" href="#doing-something-for-the-nth-member-of-a-struct-without-an-instance-1">Doing something for the Nth member of a struct without an instance</a></h3>
<p>Two cases are possible depending on whether one has an index in the struct,
or an index in the filtered part of it:</p>
<pre><code class="language-cpp">predicate_instrospection&lt;T, P&gt;::for_nth_raw(
    field_index,
    [] &lt;std::size_t Index, typename T&gt; (avnd::field_reflection&lt;Index, T&gt;) {
       // field_index == 0: x
       // field_index == 1: nothing
       // field_index == 2: z
       // field_index == 3: nothing
});
</code></pre>
<pre><code class="language-cpp">predicate_instrospection&lt;T, P&gt;::for_nth_mapped(
    filtered_index,
    [] &lt;std::size_t Index, typename T&gt; (avnd::field_reflection&lt;Index, T&gt;) {
       // filtered_index == 0: x
       // filtered_index == 1: z
});
</code></pre>
<h3 id="doing-something-for-each-member-of-a-struct-with-an-instance-3"><a class="header" href="#doing-something-for-each-member-of-a-struct-with-an-instance-3">Doing something for each member of a struct with an instance</a></h3>
<p>Same as above but with an actual instance.</p>
<pre><code class="language-cpp">Foo foo;
predicate_instrospection&lt;T, P&gt;::for_nth_raw(
    foo,
    field_index,
    [] &lt;std::size_t Index, typename T&gt; (T&amp; t) {
       // field_index == 0: x
       // field_index == 1: nothing
       // field_index == 2: z
       // field_index == 3: nothing
});
</code></pre>
<pre><code class="language-cpp">Foo foo;
predicate_instrospection&lt;T, P&gt;::for_nth_mapped(
    foo,
    filtered_index,
    [] &lt;std::size_t Index, typename T&gt; (T&amp; t) {
       // filtered_index == 0: x
       // filtered_index == 1: z
});
</code></pre>
<h3 id="getting-the-type-of-the-nth-element"><a class="header" href="#getting-the-type-of-the-nth-element">Getting the type of the Nth element</a></h3>
<pre><code class="language-cpp">// int16_t
using A = typename predicate_instrospection&lt;T, P&gt;::nth_element&lt;0&gt;;
// int32_t
using B = typename predicate_instrospection&lt;T, P&gt;::nth_element&lt;1&gt;;
</code></pre>
<h3 id="getting-the-nth-element"><a class="header" href="#getting-the-nth-element">Getting the Nth element</a></h3>
<pre><code class="language-cpp">Foo foo;

int16_t&amp; a = predicate_instrospection&lt;T, P&gt;::get&lt;0&gt;(foo);
int32_t&amp; b = predicate_instrospection&lt;T, P&gt;::get&lt;1&gt;(foo);
</code></pre>
<h3 id="getting-a-tuple-of-the-elements"><a class="header" href="#getting-a-tuple-of-the-elements">Getting a tuple of the elements</a></h3>
<pre><code class="language-cpp">Foo foo;

// Get references:
std::tuple&lt;int16_t&amp;, int32_t&amp;&gt; tpl = predicate_instrospection&lt;T, P&gt;::tie(foo);

// Get copies:
std::tuple&lt;int16_t, int32_t&gt; tpl = predicate_instrospection&lt;T, P&gt;::make_tuple(foo);

// Apply a function to each and return the tuple of that
std::tuple&lt;std::vector&lt;int16_t&gt;, std::vector&lt;int32_t&gt;&gt; tpl = 
  predicate_instrospection&lt;T, P&gt;::filter_tuple(
    foo, 
    [] &lt;typename T&gt;(T&amp; member) { return std::vector&lt;T&gt;{member}; });
</code></pre>
<h3 id="getting-the-index-of-the-filtered-element"><a class="header" href="#getting-the-index-of-the-filtered-element">Getting the index of the filtered element</a></h3>
<pre><code class="language-cpp">// Go from index in the filtered members to index in the struct
predicate_instrospection&lt;T, P&gt;::map&lt;0&gt;() == 0;
predicate_instrospection&lt;T, P&gt;::map&lt;1&gt;() == 2;
predicate_instrospection&lt;T, P&gt;::map&lt;...&gt;() == compile-error;

// Go from index in the host struct to index in the filtered members
predicate_instrospection&lt;T, P&gt;::unmap&lt;0&gt;() == 0;
predicate_instrospection&lt;T, P&gt;::unmap&lt;1&gt;() == compile-error;
predicate_instrospection&lt;T, P&gt;::unmap&lt;2&gt;() == 1;
predicate_instrospection&lt;T, P&gt;::unmap&lt;...&gt;() == compile-error;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flags"><a class="header" href="#flags">Flags</a></h1>
<p>Flags are a very simple concept in Avendish to declare that a given struct (most of the time a port) has some specific feature.</p>
<p>It just means that a specific keyword has to be in some way visible inside the struct.</p>
<p>The simplest way is through an anonymous enumeration:</p>
<pre><code class="language-cpp">struct my_port
{
  // Defines the bamboozle flag
  enum { bamboozle };

  // Other ways to define flags, A, B, C, D, E, F....:
  enum A { };
  struct B;
  using C = void;
  int D; // Really wasteful though!
  static constexpr bool E = 0;
  void F() { }
};
</code></pre>
<p>From there, the binding code can check for the flag at compile-time:</p>
<pre><code class="language-cpp">template&lt;typename T&gt; 
concept has_bamboozle_flag = 
   requires { T::bamboozle; } 
|| requires { sizeof(typename T::bamboozle*); }
;
</code></pre>
<p>The <code>halp_flag()</code> and <code>halp_flags()</code> macro wrap the basic enum definition:</p>
<pre><code class="language-cpp">struct my_port
{
  halp_flag(bamboozle_flag);
  halp_flags(foo, bar);
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-a-new-concept"><a class="header" href="#implementing-a-new-concept">Implementing a new concept</a></h1>
<p>Let's say one wants to implement a new concept / feature that will be
recognized by the Avendish bindings.</p>
<p>There are a few simple steps which separate concerns.</p>
<h2 id="1-making-an-example"><a class="header" href="#1-making-an-example">1. Making an example</a></h2>
<p>The first step is to prototype the expected API through an example.
This helps making sure the idea is sound and useable.</p>
<p>For instance, let's say we want to add support for ports with a member variable <code>int color;</code> which would enable
ports to have an associated color.</p>
<p>The color could be depending on the object a compile-time constant or a run-time property.</p>
<p>We will write a simple example object:</p>
<pre><code class="language-cpp">struct MyProcessor
{
  static consteval auto name() { return "Foo"; }

  struct
  {
    // A port with a color, "a";
    struct { 
      int color = 0xFF0000;
      // could also be int color() { return 0xFF0000; } 
      // or static constexpr int color = 0xFF0000;
      // etc...
      float value; 
    } a;
    
    // A port without a color, "b";
    struct { float value; } b; 
  } inputs;

  void operator()() { 
  }
};
</code></pre>
<h2 id="2-defining-the-concept"><a class="header" href="#2-defining-the-concept">2. Defining the concept</a></h2>
<p>For instance, in <code>&lt;avnd/concepts/color.hpp&gt;</code>:</p>
<pre><code class="language-cpp">template&lt;typename T&gt; 
concept has_color = 
   requires { T::color; } 
|| requires (T t) { t.color; }
// etc as needed.
;

</code></pre>
<h2 id="3-defining-getter-functions-to-access-it"><a class="header" href="#3-defining-getter-functions-to-access-it">3. Defining getter functions to access it</a></h2>
<p>For instance, in <code>&lt;avnd/introspection/color.hpp&gt;</code>:</p>
<pre><code class="language-cpp">template &lt;avnd::has_color T&gt;
consteval auto get_color()
{
  if constexpr(requires { T::color(); })
    return T::color();
  else if constexpr(requires { sizeof(decltype(T::color)); })
    return T::color;
  else
    // Anything that may create a compile error
    // for instance static_assert(std::is_void_v&lt;T&gt;);
    return T::there_is_no_color_here; 
}

template &lt;typename T&gt;
consteval auto get_color(const T&amp; t)
{
  if constexpr(requires { int(t.color); })
    return t.color;
  else
    return get_color&lt;T&gt;();
}
</code></pre>
<h2 id="4-defining-predicates-to-access-ports-that-specifically-have-colors"><a class="header" href="#4-defining-predicates-to-access-ports-that-specifically-have-colors">4. Defining predicates to access ports that specifically have colors</a></h2>
<p>For instance, in <code>&lt;avnd/introspection/port.hpp&gt;</code></p>
<pre><code class="language-cpp">template &lt;typename Field&gt;
using is_parameter_with_color_t = boost::mp11::mp_bool&lt;has_color&lt;Field&gt; &amp;&amp; parameter&lt;Field&gt;&gt;;
template &lt;typename T&gt;
using parameter_with_color_introspection = predicate_introspection&lt;T, is_parameter_with_color_t&gt;;
</code></pre>
<p>And then some useful shortcuts for quickly sorting input: and output ports:</p>
<p>For instance, in <code>&lt;avnd/introspection/input.hpp&gt;</code></p>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct parameter_with_color_input_introspection
    : parameter_with_color_introspection&lt;typename inputs_type&lt;T&gt;::type&gt;
{
};
</code></pre>
<p>Now we can access all the ports that have a <code>color</code> member this way:</p>
<pre><code class="language-cpp">MyProcessor obj;
avnd::parameter_with_color_input_introspection&lt;MyProcessor&gt;::for_all(
    obj.inputs
  , [] (auto&amp; field) { 
    // This function will only be called for input fields of `MyProcessor` which 
    // satisfy avnd::has_color
});
</code></pre>
<h2 id="5-in-bindings-storing-some-ancillary-data-for-each-field-with-a-color"><a class="header" href="#5-in-bindings-storing-some-ancillary-data-for-each-field-with-a-color">5. In bindings, storing some ancillary data for each field with a <code>color</code></a></h2>
<p>This is one of the most powerful zero-cost abstractions provided by Avendish:
it is possible to create arrays of data that specifically match the ports with specific properties,
attached with the binding, in a way that an object without any ports using the feature won't bear a single byte of wasted
space or instruction generated caused by the implementation of said feature.</p>
<p>For this, let's define an ancillary state that we want to store for each port that have a color.</p>
<pre><code class="language-cpp">template &lt;typename Field&gt;
struct color_state_type;

template &lt;avnd::has_color Field&gt;
struct color_state_type&lt;Field&gt;
{
  int count = 0;
};
</code></pre>
<p>Then a storage class for the feature:</p>
<pre><code class="language-cpp">// If no ports have a color, the storage will be an empty class.
template &lt;typename T&gt;
struct ports_with_color_storage
{
};

// Otherwise...
template &lt;typename T&gt;
  requires(avnd::parameter_with_color_input_introspection&lt;T&gt;::size &gt; 0)
struct ports_with_color&lt;T&gt;
{
  using in_tuple = avnd::filter_and_apply&lt;
    color_state_type, avnd::parameter_with_color_input_introspection, T&gt;;

  [[no_unique_address]] in_tuple in_handles;
  
  // Here, in_tuple == std::tuple&lt;color_state_type&lt;decltype(a)&gt;&gt;;
  // b is completely ignored as it does not have a color.
};
</code></pre>
<p>Finally, in the binding class:</p>
<pre><code class="language-cpp">[[no_unique_address]] ports_with_color_storage&lt;T&gt; colors;
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
